<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>查找</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Order_Search(int *a,int n,int key)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">    for（i &#x3D; 0;i &lt; n;++i）</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i] &#x3D;&#x3D; key)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>总结：时间复杂度为O(n),当n变大，效率变低。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Binary_Search(int *a,int n,int key)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line"> ?int low,mid,high;</span><br><span class="line">  low &#x3D; 0 ;</span><br><span class="line">  high &#x3D; n -1;</span><br><span class="line">  while(low &lt; &#x3D;high)</span><br><span class="line">  &#123;</span><br><span class="line">  	mid &#x3D; low +(high - low)&#x2F;2;</span><br><span class="line"> ? if(a[mid] &lt; key)</span><br><span class="line">   		low &#x3D; mid + 1;</span><br><span class="line">   else if (a[mid] &gt; key )</span><br><span class="line">   		high &#x3D; mid - 1;</span><br><span class="line">   else</span><br><span class="line">   return mid;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">    return -1;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>总结：log（2n）,前提有序Q~Q!!!</p>
<h5 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Binary_Search(int *a,int n,int key)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line"> ?int low,mid,high;</span><br><span class="line">  low &#x3D; 0 ;</span><br><span class="line">  high &#x3D; n -1;</span><br><span class="line">  while(low &lt; &#x3D;high)</span><br><span class="line">  &#123;</span><br><span class="line">  	mid &#x3D; low +(key - a[low])&#x2F;(a[high] - a[low])*(high - low)</span><br><span class="line"> ? if(a[mid] &lt; key)</span><br><span class="line">   		low &#x3D; mid + 1;</span><br><span class="line">   else if (a[mid] &gt; key )</span><br><span class="line">   		high &#x3D; mid - 1;</span><br><span class="line">   else</span><br><span class="line">   return mid;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">    return -1;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>总结：mid值的变化更靠近关键字key，这样也就间接地减少了比较次数</p>
<h5 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max_size&#x3D;20;</span><br><span class="line"></span><br><span class="line">&#x2F;*构造一个斐波那契数组*&#x2F; </span><br><span class="line">void Fibonacci(int * F)</span><br><span class="line">&#123;</span><br><span class="line">    F[0]&#x3D;0;</span><br><span class="line">    F[1]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;2;i&lt;max_size;++i)</span><br><span class="line">        F[i]&#x3D;F[i-1]+F[i-2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FibonacciSearch(int *a, int n, int key)  </span><br><span class="line">&#123;</span><br><span class="line">  int low&#x3D;0;</span><br><span class="line">  int high&#x3D;n-1;</span><br><span class="line">  </span><br><span class="line">  int F[max_size];</span><br><span class="line">  Fibonacci(F);&#x2F;&#x2F;构造一个斐波那契数组F </span><br><span class="line"></span><br><span class="line">  int k&#x3D;0;</span><br><span class="line">  while(n&gt;F[k]-1)&#x2F;&#x2F;计算n位于斐波那契数列的位置</span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  int  * temp;&#x2F;&#x2F;将数组a扩展到F[k]-1的长度</span><br><span class="line">  temp&#x3D;new int [F[k]-1];</span><br><span class="line">  memcpy(temp,a,n*sizeof(int));</span><br><span class="line"></span><br><span class="line"> ?for(int i&#x3D;n;i&lt;F[k]-1;++i) &#x2F;&#x2F;数组扩展</span><br><span class="line">  temp[i]&#x3D;a[n-1];</span><br><span class="line">  </span><br><span class="line">  while(low&lt;&#x3D;high)</span><br><span class="line">  &#123;</span><br><span class="line">    int mid&#x3D;low+F[k-1]-1;</span><br><span class="line">    if(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high&#x3D;mid-1;</span><br><span class="line">      k-&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low&#x3D;mid+1;</span><br><span class="line">     k-&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       if(mid&lt;n)</span><br><span class="line">           return mid; &#x2F;&#x2F;若相等则说明mid即为查找到的位置</span><br><span class="line">       else</span><br><span class="line">           return n-1; &#x2F;&#x2F;若mid&gt;&#x3D;n则说明是扩展的数值,返回n-1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  delete [] temp;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：黄金分割，时间复杂度为O(log2n)</p>
<h5 id="二叉查找树-了解"><a href="#二叉查找树-了解" class="headerlink" title="二叉查找树(了解)"></a>二叉查找树(了解)</h5><p>//对二叉查找树进行中序遍历，即可得到有序的数列。<br>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>3）任意节点的左、右子树也分别为二叉查找树。</p>
<h5 id="B树-（特点-“又矮又胖”）"><a href="#B树-（特点-“又矮又胖”）" class="headerlink" title="B树 （特点:“又矮又胖”）"></a>B树 （特点:“又矮又胖”）</h5><p>（1）每个节点最多有m-1个关键字（可以存有的键值对）1 &lt;= k &lt;= m-1<br>（2）根节点最少可以只有1个关键字。<br>（3）非根节点至少有m/2个关键字。m/2 &lt;= k &lt;= m-1<br>（4）M为结阶数：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。<br><code><br>leetcode题目<br>10阶的B-树，每个树根结点2中所含关键字数目最多9，最少允许4。</code></p>
<h5 id="B-树-是b树的一种变体，查询性能"><a href="#B-树-是b树的一种变体，查询性能" class="headerlink" title="B+树(是b树的一种变体，查询性能)"></a>B+树(是b树的一种变体，查询性能)</h5><p>（1）根节点至少一个元素<br>（2）非根节点元素范围：m/2 &lt;= k &lt;= m-1<br>（3）节点之间含有重复元素,而且叶子节点还用指针连在一起。<br>（4）每一个父节点的元素都出现在子节点中,是子节点的最大(或最小)元素。<br>（5）根节点元素保持最大<br>（6）没有卫星数据，容纳更多节点元素<br>（7）每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
<p>输入顺序文件—磁盘未排序文件<br>索引—关键码和数据位置关联<br>磁盘IO访问次数</p>
<p>相比优点：IO次数更少，查询稳定、范围查询简便</p>
<h5 id="红黑树（自平衡）"><a href="#红黑树（自平衡）" class="headerlink" title="红黑树（自平衡）"></a>红黑树（自平衡）</h5><p>（1）节点是红色或黑色。<br>（2）根节点是黑色。<br>（3）每个叶子节点都是黑色的空节点（NUIL节点）。<br>（4）每个红色节点的两个子节点都是黑色。<br>(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>破坏红黑树的规则？<br>变色、旋转（变色无法解决的时候，两个个红色的时候，左旋与右旋）。</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/uncategorized/%E5%A0%86/</url>
    <content><![CDATA[<p>这里的堆有区别于内存空间的堆概念！</p>
<p>（大顶堆或者小顶堆）  二叉树层序遍历？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct NODE_ST</span><br><span class="line">&#123;</span><br><span class="line">int value;</span><br><span class="line">&#125;node_st;</span><br><span class="line"></span><br><span class="line">typedef struct D_TREE&#123;</span><br><span class="line">	node_st cur;</span><br><span class="line">	struct D_TREE *lchild,*rchild;</span><br><span class="line">&#125;d_tree;</span><br><span class="line"></span><br><span class="line">d_tree *tree_Create()</span><br><span class="line">&#123;</span><br><span class="line">	d_tree *tmp &#x3D; NULL;</span><br><span class="line">	char ch &#x3D; 0;</span><br><span class="line">	printf(&quot;请输入字符：\n&quot;);</span><br><span class="line">	scanf(&quot; %c&quot;,&amp;ch);&#x2F;&#x2F;%c</span><br><span class="line">	if(ch &#x3D;&#x3D; &#39;#&#39;)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		tmp &#x3D; (d_tree *)calloc(1,sizeof(d_tree));</span><br><span class="line">		if(tmp &#x3D;&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	    tmp-&gt;cur.value &#x3D; ch;</span><br><span class="line">	    tmp-&gt;lchild &#x3D; tree_Create();</span><br><span class="line">	    tmp-&gt;rchild &#x3D; tree_Create();</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void inOrder(void *Node)&#x2F;&#x2F;先序变遍历</span><br><span class="line">&#123;</span><br><span class="line">	d_tree *node &#x3D; Node;</span><br><span class="line">    if(node &#x3D;&#x3D; NULL)</span><br><span class="line">    return;</span><br><span class="line">	inOrder(node-&gt;lchild);</span><br><span class="line">	printf(&quot;%d&quot;,node-&gt;cur.value);</span><br><span class="line">    inOrder(node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">void tree_Free(d_tree *T) &#x2F;&#x2F;后序销毁</span><br><span class="line">&#123;</span><br><span class="line">	if(T &#x3D;&#x3D; NULL)</span><br><span class="line">		return;</span><br><span class="line">	if(T-&gt;lchild !&#x3D; NULL)&#123;</span><br><span class="line">		tree_Free(T-&gt;lchild);</span><br><span class="line">		T-&gt;lchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	if(T-&gt;rchild !&#x3D; NULL)&#123;</span><br><span class="line">		tree_Free(T-&gt;rchild);</span><br><span class="line">		T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	if(T !&#x3D; NULL)&#123;</span><br><span class="line">		free(T);</span><br><span class="line">		T &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void )</span><br><span class="line">&#123;</span><br><span class="line">	d_tree *node &#x3D; NULL;</span><br><span class="line">	node &#x3D; tree_Create();</span><br><span class="line">	inOrder(node);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	tree_Free(node);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、重点是#号创建和递归的使用。<br>2、我其实觉得可以二叉树的框架直接替代，</p>
]]></content>
  </entry>
  <entry>
    <title>栈</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%A0%88/</url>
    <content><![CDATA[<h5 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct  node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct linkqueue</span><br><span class="line">&#123;</span><br><span class="line">	node *zhandi;</span><br><span class="line">	node *top;</span><br><span class="line">&#125;queue;</span><br><span class="line"></span><br><span class="line">queue*push(queue* HQ,int x)</span><br><span class="line">&#123;</span><br><span class="line">	node *pm;</span><br><span class="line">	pm &#x3D; (node *)malloc(sizeof(node));</span><br><span class="line">	pm-&gt;data &#x3D; x;</span><br><span class="line">	pm-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (HQ-&gt;zhandi &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		HQ-&gt;zhandi &#x3D; pm;</span><br><span class="line">		HQ-&gt;top &#x3D; pm;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		HQ-&gt;top-&gt;next &#x3D; pm;</span><br><span class="line">		HQ-&gt;top &#x3D; pm;</span><br><span class="line">	&#125;</span><br><span class="line">	return HQ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">queue * pop(queue *HQ)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*还是要用这个p指向最后top前驱节点*&#x2F;</span><br><span class="line">	node *p;</span><br><span class="line">	int x;</span><br><span class="line">	if (HQ-&gt;zhandi &#x3D;&#x3D;NULL ) </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n 溢出&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		x &#x3D; HQ-&gt;zhandi-&gt;data;</span><br><span class="line">		p &#x3D; HQ-&gt;zhandi;</span><br><span class="line">		if (HQ-&gt;zhandi &#x3D;&#x3D; HQ-&gt;top)</span><br><span class="line">		&#123;</span><br><span class="line">			HQ-&gt;zhandi &#x3D; NULL;</span><br><span class="line">			HQ-&gt;top &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			while (p-&gt;next !&#x3D; HQ-&gt;top)</span><br><span class="line">			&#123;</span><br><span class="line">				p &#x3D; p-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			HQ-&gt;top &#x3D; p;</span><br><span class="line">			HQ-&gt;top-&gt;next &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		return HQ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序栈</span><br><span class="line">#include&lt;stdio.h&gt;	</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define MAX  10</span><br><span class="line">typedef struct SqStack</span><br><span class="line">&#123;</span><br><span class="line">	int data[MAX];</span><br><span class="line">	int top;	</span><br><span class="line"></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化栈</span><br><span class="line">void InitStack(SqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;top &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断是否为空</span><br><span class="line">int Stackempty(SqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	if (s-&gt;top &#x3D;&#x3D; -1)</span><br><span class="line">	return 0;</span><br><span class="line">	else </span><br><span class="line">	return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;进栈</span><br><span class="line">int push(SqStack *s,int e)</span><br><span class="line">&#123;</span><br><span class="line">if (s-&gt;top &#x3D;&#x3D; MAX -1)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;栈满\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;data[++s-&gt;top] &#x3D; e;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">int pop(SqStack *s,int *e)</span><br><span class="line">&#123;</span><br><span class="line">	if(s-&gt;top&#x3D;&#x3D;-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;栈空\n&quot;);</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	*e&#x3D;s-&gt;data[s-&gt;top--];&#x2F;&#x2F;出栈 的赋值给e</span><br><span class="line">	return 1;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-本地usb摄像头的调用</title>
    <url>/QT-Lover/QT-%E6%9C%AC%E5%9C%B0usb%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h5 id="心得小记"><a href="#心得小记" class="headerlink" title="心得小记"></a>心得小记</h5><p>1、QvideoWidgat类的提升<br>2、QCamera的了解<br>3、图片的简单处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    this-&gt;setWindowTitle(&quot;QT 调用本地 USB 摄像头&quot;);</span><br><span class="line"></span><br><span class="line">    QList &lt;QCameraInfo&gt; cameras &#x3D; QCameraInfo::availableCameras();</span><br><span class="line"></span><br><span class="line">     foreach (const QCameraInfo &amp;cameraInfo, cameras)</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">          if (cameraInfo.deviceName() &#x3D;&#x3D; &quot;@device:pnp:\\\\?\\usb#vid_0bda&amp;pid_57de&amp;mi_00#6&amp;2a01fa54&amp;0&amp;0000#&#123;65e8773d-8f56-11d0-a3b9-00a0c9223196&#125;\\global&quot;)</span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">             if (cameraInfo.deviceName() &#x3D;&#x3D; &quot;@device:pnp:\\\\?\\usb#vid_0c45&amp;pid_6366&amp;mi_00#6&amp;183af011&amp;0&amp;0000#&#123;65e8773d-8f56-11d0-a3b9-00a0c9223196&#125;\\global&quot;)</span><br><span class="line">          &#123;</span><br><span class="line">               m_camera &#x3D; new QCamera(cameraInfo);</span><br><span class="line">               qDebug()&lt;&lt;cameraInfo.deviceName();</span><br><span class="line"></span><br><span class="line">               QString str &#x3D;   QString(cameraInfo.deviceName());</span><br><span class="line"></span><br><span class="line">               qDebug() &lt;&lt; str ;</span><br><span class="line">               ui-&gt;comboBox-&gt;addItem(str);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;   m_camera &#x3D; new QCamera(this);&#x2F;&#x2F;初始化摄像头设备</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       m_camera-&gt;setCaptureMode(QCamera::CaptureVideo);&#x2F;&#x2F;设置捕捉模式为视频</span><br><span class="line"></span><br><span class="line">       m_camera-&gt;setViewfinder(ui-&gt;widget);&#x2F;&#x2F;设置 摄像头画面的显示位置</span><br><span class="line">     &#x2F;&#x2F;  m_camera-&gt;start();&#x2F;&#x2F;开启摄像头</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool MainWindow::checkCameraAvailability()</span><br><span class="line"> &#123;</span><br><span class="line">     if (QCameraInfo::availableCameras().count() &gt; 0)</span><br><span class="line">         return true;</span><br><span class="line">     else</span><br><span class="line">         return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MainWindow::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">        if( m_camera-&gt;state() !&#x3D;  QCamera::ActiveState)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        m_camera-&gt;start();&#x2F;&#x2F;开启摄像头</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::on_pushButton_2_clicked()</span><br><span class="line">&#123;</span><br><span class="line">      m_camera-&gt;stop();&#x2F;&#x2F;关闭摄像头</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::on_pushButton_4_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        if( m_camera-&gt;state() &#x3D;&#x3D;  QCamera::ActiveState)&#x2F;&#x2F;摄像头开启状态下才抓拍</span><br><span class="line">&#x2F;&#x2F;        &#123;</span><br><span class="line">&#x2F;&#x2F;            QPixmap pixmap &#x3D; ui-&gt;widget-&gt;grab();&#x2F;&#x2F;将widget内容保存为pixmap图像信息</span><br><span class="line">&#x2F;&#x2F;            pixmap.save(&quot;Snap.bmp&quot;);&#x2F;&#x2F;保存为Snap.bmp</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">    QString filename1 &#x3D; QFileDialog::getSaveFileName(this,tr(&quot;Save Image&quot;),&quot;&quot;,tr(&quot;Images (*.png *.bmp *.jpg)&quot;)); &#x2F;&#x2F;选择路径</span><br><span class="line">     QScreen *screen &#x3D; QGuiApplication::primaryScreen();</span><br><span class="line">     screen-&gt;grabWindow(ui-&gt;label_picture-&gt;winId()).save(filename1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MainWindow::on_pushButton_3_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;label_picture-&gt;clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::on_pushButton_5_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QPixmap pixmap &#x3D; QPixmap::grabWidget(ui-&gt;widget);</span><br><span class="line"></span><br><span class="line">    ui-&gt;label_picture-&gt;setPixmap(pixmap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><img src="/QT-Lover/QT-%E6%9C%AC%E5%9C%B0usb%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%B0%83%E7%94%A8/picture.gif" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式考试三级备考（2）</title>
    <url>/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h5 id="选择填空"><a href="#选择填空" class="headerlink" title="选择填空"></a>选择填空</h5><p>嵌入式系统的软件配置有多种情况,有些简单,有些比较复杂<br>而嵌入式系统的CPU有ARM, DSP和FPGA等。</p>
<p>数字信号处理器英文缩写为DSP,它是一种适用于数字信号处理的微处理器,。<br>它支持单指令多数据(SIMD )并行处理的指令；<br>能显著提高音频、视频等数字信号的数据处理效率。</p>
<p>随着电子设计自动化水平的提高和VLS1制造技术的飞速发展,半导体加工已经从微米、亚微米进入到深亚微米的时代,单个芯片上可以集成几亿个甚至几十亿个晶体管,因而能够把计算机或其他一些电子系统的全部电路都集成在单个芯片上,这种芯片就是所谓的片上系统。</p>
<p>嵌入式系统的分类有多种。<br>按系统的软硬件技术复杂度,嵌入式系统分为低端系统、中端系统和高端系统。</p>
<p>集成电路根据其集成度的高低可以分为小规模(SSI )、中规模(MSI )、大规模(LSI )、超大规模(VLSI )和极大规模(ULSI )等几种。嵌入式处理芯片大多属于VLSI和ULSl,集成电路的制造</p>
<p>以太网数据帧<br>前导码(7字节)、帧起始定界符(1字节)、目的MAC地址(6字节)、源MAC地址(6字节)、类型/长度(2字节)、数据(46-1500字节)、帧校验序列(4字节),A项IP地址不属于以太网数据帧内容。</p>
<p>一个A类IP地址由1字节(每个字节是8位)的网络地址和3个字节主机地址组成,网络地址的最高位必须是”0” ,即第一段数字范围为1~127,每个A类地址可连接16387064台主机, Internet有126个A类地址。</p>
<p>ARM的总线结构称为AMBA (先进微控器制总线结构) ,是ARM推出的开放式总线结构是目前流行的一种工业标准片上结构; </p>
<p>在ARM的体系结构中,处理器可以工作在3种不同的状态, QARM状态2Thumb/Thumb-2状态③调试状态。</p>
<p>GPIO的引脚一般是多功能复用的,一般具有0态和1态和高阻状态;作为输入接口时具有缓冲功能,作为输出接口时具有锁存功能</p>
<p>ARM芯片中的UART收发信息时,可以采用FIFO模式,也可以采用普通模式;<br>UART传送信息的格式以起始位开始,以停止位结束;<br>UART传送信息时一次传送的数据位可为5、6、7、8位,由编程决定;<br>基于UART可组成RS-232接口。</p>
<p>利用嵌入式芯片的GPIO构成线性键盘时,一个按键需要占用一个GPIO引脚;采用矩阵键盘结构时,8个GPIO引脚最多能构成64个按键的键盘;</p>
<p>任务处于休眠态,相当于该任务驻留在内存中,但还没有交给内核管理<br>任务处于就绪态,意味着该任务已经准备好,可以运行了,但由于该任务的优先级比正在运行的任务的优先级低,还暂时不能运行<br>任务处于运行态,指任务得到了CPU的控制权正在运行之中<br>任务处于被中断态,是指发生中断时执行相应的中断服务,原来正在运行的任务暂时停止运行,进入了被中断状态</p>
<p>uC/OS-11许中断嵌套,嵌套层数可达255层。节拍率应在每秒10次到100次之间,即10-100Hz。 uC/OS-11的事件控制块有4种类型,需要使用4个不同的函数来创建。4个不同的函数分别是: OSSemCreate ()、OSMutexCreate ()、OSMboxCreate ( )、 osQCreate ()。</p>
<p>进程调度模块负责控制进程对CPU资源的使用,所采取的调度策略是使得各个进程能够公平合理地访问CPU ,同时保证内核能及时地执行硬件操作。</p>
<p>属于微内核结构的典型嵌入式操作系统有Symbian, VxWorks（小型）， QNX,uC/OS-11, ios等。而Symbian系统属于普通实时系统。</p>
<p>arm-linux-gcc-g-o test test.c<br>要对源程序进行调试,通常需要在GCC命令中加入参数-g。</p>
<p>目前32位嵌入式处理器主要采用的是ARM内核处理器,是由英国一家专门从事RISC处理器内核设计公司设计的。</p>
<p>汉字编码  GB2312  GB18030   2个字节表示 </p>
<p>TCP/IP协议簇中的IP协议,在Internet中负责选择合适的路由,使发送的数据分组( packet )能够正确无误地按照地址找到目的计算机。</p>
<p>ARM 七种异常：<br>复位、<br>未定义指令、<br>软件中断、<br>指令预取中止<br>、数据访问中止、<br>外部中断请求、<br>快速中断请求。</p>
<p>。在ARM处理器中, RO~R15是通用寄存器,其中有两个较特殊,作为堆栈指针SP使用的寄存器是R13,作为程序链接寄存器LR使用的是R14</p>
<p>已知ARM处理器进位标志C= 1, R1 = 1000, R2-99,<br>执行指令ADDC RO , R1 , R2之后, RO=1100；R1=1000<br>ADDC是带进位加法,指令执行完后, RO中是R1和R2带进位相加之后的值;而R1中的值不变。</p>
<p>ADDCEQ R3,R1,R2</p>
<p>SUBHIS R3,R1,R2</p>
<p>AMBA 总线规范，总线体系结构</p>
<p>模拟组件包括ADC与DAC</p>
<p>。目前有两种主要的闪存技术,一种是NOR Flash ,其特点是以字节为单位随机存取,另一种是NAND Flash ,以页(行)为单位随机存取。</p>
<p>带宽＝数据线宽度＊传输线时钟频率＊每个时钟脉冲传输数据次数／8　;</p>
<p>SPI的信号线MISO称为主机输入从机输出数据线, MOSI称为主机输出从机输入数据线。<br>内核只提供任务调度、任务间通信与同步、任务管理、时间管理和存储管理等基本功能,资源消耗非常小。<br>响应时间( Response Time )是计算机从识别一个外部事件到做出响应的时间,其具体指标包括:中断延迟时间和任务切换时间。</p>
<p>引导加载程序Bootloader的执行过程。系统中引导加载程序主要完成加电自检、外设存在自检、内存地址映射、初始化外围设备、内存寻址定位、加载并启动操作系统.</p>
<p>以太网控制电路和驱动电路</p>
<h5 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h5><p>（1）rGPECON=(rGPECON | x00005555)&amp; oxFFFF5555</p>
<pre><code>: rGPEDAT  =  r GPEDAT | 0x0020</code></pre><p>(2) 0x000000AA</p>
<img src="/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%882%EF%BC%89/1.jpg" class="">

 <img src="/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%882%EF%BC%89/2.jpg" class="">

<p>//串口控制器   8位 奇 1 停止<br>0010 0011</p>
<img src="/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%882%EF%BC%89/3.jpg" class="">

 <img src="/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%882%EF%BC%89/4.jpg" class="">

<p>波特率设置？？<br>(9600× 16)+0.5 </p>
<p>（3）9600/（8+3） = 872  4k 4.7s<br>奇偶校验包括停止位 3 个</p>
<p>（4）41250<br>计数常数的计算</p>
<p>0x00000003<br>0x00000003</p>
<p>（5）0xA122    ==== 41250</p>
<p>（6）</p>
<p>（7）0x00000018   IRQ<br> 4 个字节<br>OxCo<br>BL_main</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式考试三级备考（1）</title>
    <url>/ARM-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%80%83%E8%AF%95%E4%B8%89%E7%BA%A7%E5%A4%87%E8%80%83%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>1、嵌入式系统以应用为中心,以计算机技术为基础,软硬件可裁剪、适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。巨型计算机实际上是一个巨大的计算机系统。</p>
<p>2、在uC/OS-11中有多种方法可以保护任务之间的共享数据和提供任务之间的通信。其中主要有以下三种:利用宏OS ENTER CRITICALO和OS EXIT CRITICAL)来关闭中断和打开中断;利用函数OSSchedLock0和OsschedUnlock0对任务调度函数上锁和开锁;利用信号量、互斥信号量、邮箱和消息队列进行任务间通信。利用内存文件进行任务间的大规模数据共享是达不到保护任务之间的共享数据的作用。</p>
<p>3、 HAL系统库提供以下服务:结合Newlib ANSIC标准库,向用户提供熟知的标准库函数;提供设备驱动,使用户可以访问系统中的所有设备;为用户提供了与HAL服务柜统一的标准接口( HAL API ) ,例如数据访问、中断处理和报警设施;系统初始化,在main ()函数之前完成软核处理器Nios和运行库环境的初始化任务;设备初始化,在main ()函数之前完成每个设备的实例化和初始化。</p>
<p>不提供的TCP/IP协议栈服务。</p>
<p>3、iOS的前身是UNIX-BSD.</p>
<p>4、MPEG-2,在3-10Mbits/sec间.</p>
<p>5、IP地址分为A类、B类、C类三个基本类,另有两类分别作为组播地址和备用地址(D类和E类)。C类IP地址范围: 192.0.0.1到223.255.255.254,第1字节、第2字节和第3个字节为网络地址,第4个字节为主机地址。C类网络地址数量较多,适用于小规模的局域网络,每个网络最多只能包含254台计算机。</p>
<p>6、嵌入式处理器的体系结构按指令集可分为两大类:CISC和RISC ;<br>按存储机制分为冯诺依曼结构及哈佛结构;<br>按字长分为8位、16位、32位和64位。</p>
<p>7、 ARM公司，经典家族ARM7\ARM9\ARM11.<br>在经典处理器ARM11以后的产品改用Cortex命名,并分成A,R和M三类,旨在为各种不同的市场提供服务。Cortex系列属于ARMv7架构,这是到2010年为止ARM公司最新的指令集架构。(2011年, ARMv8架构在TechCon上推出) ARMv7架构定义了三大分工明确的系列: “A”系列面向尖端的基于虚拟内存的操作系统和用户应用: “R”系列针对实时系统; “M”系列对微控制器。</p>
<p>8、在ARM的体系结构中,处理器可以工作在3种不同的状态<br>①ARM状态<br>②是Thumb状态及Thumb-2状态<br>③调试状态。<br>除支持Thumb-2的ARM处理器外,其他所有ARM处理器都可以工作在ARM状态。ARM状态是ARM处理器工作于32位指令的状态,所有指令均为32位宽度。复位后处于ARM状态。</p>
<p>9、大多数嵌入式处理器内置了时钟信号发生器,因此时钟电路只需要外接一个石英晶体振荡器和两只电容就可以工作了,但有些场合(如为了减少功耗、需要严格同步等)需要使用外部振荡源提供时钟信号。</p>
<p>10、前向通道通常指的是輸入接口,由模拟量輸入接口和数字量输入接口组成,模拟输入接口包括传感器,信号调节电路(滤波,放大器等) , A/D转换器等构成。后向通道是输出接口,由模拟量和数字量接口组成,包括D/A转换器,功率放大器,执行器等。<br>11、DMA ( Direct Memory Access )控制器是一种在系统内部转移数据的独特外设,可以将其视为种能够通过一组专用总线将内部和外部存储器与每个具有DMA能力的外设连接起来的控制器。</p>
<p>填空题<br>考查IP核的分类。按照C设计文件的类型, IP核通常分为三种:软核、固核和硬核</p>
<p>（1）什么是软核?<br>         IP软核通常是用HDL文本形式提交给用户，它经过RTL级设计优化和功能验证，但其中不含有任何具体的物理信息。<br>据此，用户可以综合出正确的门电路级设计网表，并可以进行后续的结构设计，具有很大的灵活性，借助于EDA综合工具<br>可以很容易地与其他外部逻辑电路合成一体，根据各种不同半导体工艺，设计成具有不同性能的器件。软IP内核也称为虚<br>拟组件（VC-Virtual Component）。<br>    （2）什么是固核?<br>         IP固核的设计程度则是介于软核和硬核之间，除了完成软核所有的设计外，还完成了门级电路综合和时序仿真等设<br>计环节。一般以门级电路网表的形式提供给用户。<br>    （3）什么是硬核?<br>         IP硬核是基于半导体工艺的物理设计，已有固定的拓扑布局和具体工艺，并已经过工艺验证，具有可保证的性能。<br>其提供给用户的形式是电路物理结构掩模版图和全套工艺文件，是可以拿来就用的全套技术。 </p>
<p>65536色 像素16位<br>Flash寄存器，1024x1024x16/8 = 2M<br>80x2/4 = 40M</p>
<p>考查WLAN的通信协议以及数据传输速率。WLAN所采用的主要通信协议是802.11 ;数据传输速率可达到11 Mbps, 54Mbps, 108Mbps甚至更高。</p>
<p>考查ARM处理器的7种异常及相应优先级。<br>经典ARM处理器有7种异常:主要包括复位RESET,未定义指令UND,软件中断SWI、指令预取中止PABT、数据访问中止DABT、外部中断请求IRQ以及快速中断,其中优先級最高的是复位。</p>
<p>本题考查对Thumb-2指令集的掌握,开关中断指令属于程序状态类指令用于更改处理器状态。<br>关外部中断使用的指令为: CPSID I<br>开外部中断的指令为: CPSIE I</p>
<p>调用子程序<br>BL<br>返回<br>MOV PC LR;</p>
<p>AMBA总线规范,基于ARM内核的嵌入式处理器芯片采用系统总线与外围总线两层结构的方式构建片上系统。其中的系统总线主要用于连接高带宽快速组件。<br>FRAM<br>铁性随机存储器<br>MRAM<br>磁性存随机储器</p>
<p>存储器的容量取决于存储单元的个数和存储器各单元的位数,而单元个数与存储器的地址总线有密切关系因此存储器芯片的容量完全取决于存储器芯片的地址线条数和数据线的位数。</p>
<p>12C总线被启动后,多个主机在每发送一个,数据位时都要对SDA信号线电平进行检测,只要检测的电平与自己发出的电平相同就会继续占用总线。总线的控制遵循”低电平优先”的原则。</p>
<p>UART的构成发送器、接收器、控制单元、波特率发送器。</p>
<p>嵌入式系统与通用计算机系统软件的相同之处,指的是嵌入式系统通常也具备引导加载程序,外设驱动程序,操作系统,文件系统,网络协议栈,图形用户界面,数据库,以及各种各样的应用程序等。</p>
<p>基于操作系统的外围工具软件运行在嵌入式系统上,往往具有内部结构精简,代码轻量化,占用存储资源少的特点。</p>
<p>实时系统的任务时限有两种:<br>截止时间也就是任务开始执行时间到任务必须完成的时间间隔。<br>任务执行预设时间,或者叫做任务最快完成时间,这是无中断响应情况下的任务最快执行时间。<br>实时系统的任务时限有两种:截止时间也就是任务开始执行时间到任务必须完成的时间间隔。任务执行预设时间,或者叫做任务最快完成时间,这是无中断响应情况下的任务最快执行时间。</p>
<p>实时系统对时间约束要求的严格性,使可预测性成为实时系统的一项重要性能要求,它是指RTOS能够对外部事件的响应时间和实时任务的执行时间进行判断,以确定被事件触发的实时任务能否在规定的时间内完成。</p>
<p>实时系统按响应时间一般分成三类:强实时系统,其响应时间一般在毫秒级或微秒级;普通实时系统,其响应时间一般在秒级;弱实时系统,其响应时间一般在数十秒级。</p>
<p>一般嵌入式系统的开发过程,通常分为需求分析与规格说明、系统设计、构件设计、系统集成与测试等4个阶段。</p>
<p>综合题。（）</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>位运算细节入手QVQ</p>
<h6 id="用来判定奇偶"><a href="#用来判定奇偶" class="headerlink" title="用来判定奇偶"></a>用来判定奇偶</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (i &amp; 1)</span><br><span class="line">printf(&quot;%d &quot;, i);&#x2F;&#x2F;1为奇，0为偶</span><br></pre></td></tr></table></figure>
<h6 id="用来交换"><a href="#用来交换" class="headerlink" title="用来交换"></a>用来交换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a^ &#x3D;b ;</span><br><span class="line">b^&#x3D;a;</span><br><span class="line">a^&#x3D; b;</span><br></pre></td></tr></table></figure>

<h6 id="求一个整数中-二进制中1的个数"><a href="#求一个整数中-二进制中1的个数" class="headerlink" title="求一个整数中,二进制中1的个数"></a>求一个整数中,二进制中1的个数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bitsum(int n)&#123;</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">while(n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n&#x3D;(n-1)&amp;n;</span><br><span class="line">        &#125;</span><br><span class="line">    return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h6 id="高低位交换"><a href="#高低位交换" class="headerlink" title="高低位交换"></a>高低位交换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	核心：a &#x3D; (a &gt;&gt; 8) | (a &lt;&lt; 8);</span><br><span class="line">		</span><br><span class="line">	打印出二进制函数</span><br><span class="line">void printfbit(int a)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; sizeof(a)*8 - 1 ; i &gt;&#x3D; 0 ; --i) &#123;</span><br><span class="line">        &#x2F;* code *&#x2F;</span><br><span class="line">        if((a &gt;&gt; i  )&amp;1)</span><br><span class="line">        &#123;</span><br><span class="line">        putchar(&#39;1&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">       putchar(&#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;*一字节 空 一&quot; &quot;*&#x2F;</span><br><span class="line">    if(i %8 &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        putchar(&#39; &#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   测试 ：44 输出： 00000000 00000000 00000000 00101100</span><br></pre></td></tr></table></figure>

<h6 id="判断位是否为1或置0"><a href="#判断位是否为1或置0" class="headerlink" title="判断位是否为1或置0"></a>判断位是否为1或置0</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如一个数a的bit3~5位为1，并且置为0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>μcosII实时操作系统</title>
    <url>/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><img src="/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UCOSII%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" class="">

<p>UCOSII 是专门为计算机的嵌入式应用设计的， 绝大部分代码是用 C 语言编写的。CPU 硬件相关部分是用汇编语言编写的、总量约 200 行的汇编语言部分被压缩到最低限度，为的是便于移植到任何一种其它的 CPU 上。（V2.91）</p>
<p>只支持 64 个任务—&gt;&gt;&gt;支持任务数提高到 255 个</p>
<p>UCOSII 一般只占用了最低 2 个优先级，分别用于空闲任务（倒数第一）和统计任务（倒数第二），所以剩下253 个UCOSII 的移植，我们只需要修改：os_cpu.h、os_cpu_a.asm 和 os_cpu.c等三个文件即可。</p>
<h5 id="定时器作用"><a href="#定时器作用" class="headerlink" title="定时器作用"></a>定时器作用</h5><p>定时器的作用提供系统时钟节拍，实现任务切换和任务延时等功能。这个时钟节拍OS_TICKS_PER_SEC（在 os_cfg.h 中定义）设置，系统时钟节拍为 1ms~100ms，具SYSTICK 定时器来提供 UCOSII 时钟节拍。</p>
<h5 id="控制任务"><a href="#控制任务" class="headerlink" title="控制任务"></a>控制任务</h5><p>UCOSII 的任何任务都是通过一个叫任务控制块（TCB）的东西来控制的，每个任务管理块有 3 个最重要的参数：1，任务函数指针；2，任务堆栈指针；3，任务优先级；<br>注：UCOSII 不支持多个任务优先级相同，也就是每个任务的优先级必须不一样</p>
<h5 id="任务状态转化关系"><a href="#任务状态转化关系" class="headerlink" title="任务状态转化关系"></a>任务状态转化关系</h5><img src="/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UCOSII%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.jpg" class="">


<h5 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h5><p>1） 建立任务函数<br>OSTaskCreate(void(<em>task)(void</em>pd),void<em>pdata,OS_STK</em>ptos,INTU prio)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;START 任务</span><br><span class="line">#define START_TASK_PRIO 10 &#x2F;&#x2F;设置任务优先级</span><br><span class="line">#define START_STK_SIZE 64 &#x2F;&#x2F;设置任务堆栈大小</span><br><span class="line">OS_STK START_TASK_STK[START_STK_SIZE]; &#x2F;&#x2F;任务堆栈 </span><br><span class="line">void start_task(void *pdata); &#x2F;&#x2F;任务函数</span><br></pre></td></tr></table></figure>
<p>2） 任务删除函数<br>INT8U OSTaskDel(INT8U prio)<br>3） 请求任务删除函数<br>INT8U OSTaskDelReq(INT8U prio)<br>4） 改变任务的优先级函数<br>INT8U OSTaskChangePrio(INT8U oldprio,INT8U newprio)<br>5） 任务挂起函数<br>INT8U OSTaskSuspend(INT8U prio)<br>6） 任务恢复函数<br>INT8U OSTaskResume(INT8U prio))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Main(void)</span><br><span class="line">&#123;</span><br><span class="line">TargetInit(); &#x2F;&#x2F;初 初 始 化 目标板</span><br><span class="line">OSInit(); &#x2F;&#x2F;初 初 始 化操作系统</span><br><span class="line">OSTaskCreate(Task0,&amp;StackTask0[StackSizeTask0 - 1],PrioTask0); &#x2F;&#x2F; 创 创 建 一个任务</span><br><span class="line">Uart_Printf(&quot;Ready to start OS\n&quot;);</span><br><span class="line">OSStart(); &#x2F;&#x2F; 运行 操作系统</span><br><span class="line">return 0; &#x2F;&#x2F;程 程 序 不 会运行至此</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号量与邮箱"><a href="#信号量与邮箱" class="headerlink" title="信号量与邮箱"></a>信号量与邮箱</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">INT8U OSEventType; &#x2F;&#x2F;事件的类型</span><br><span class="line">INT16U OSEventCnt;  &#x2F;&#x2F;信号量计数器</span><br><span class="line">void *OSEventPtr; &#x2F;&#x2F;消息或消息队列的指针</span><br><span class="line">INT8U OSEventGrp;  &#x2F;&#x2F;等待事件的任务组</span><br><span class="line">INT8U OSEventTbl[OS_EVENT_TBL_SIZE];&#x2F;&#x2F;任务等待表</span><br><span class="line">#if OS_EVENT_NAME_EN &gt; 0u</span><br><span class="line">INT8U *OSEventName; &#x2F;&#x2F;事件名</span><br><span class="line">#endif</span><br><span class="line">&#125; OS_EVENT;</span><br></pre></td></tr></table></figure>
<img src="/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1.jpg" class="" title="事件通信">

<h5 id="消息队列、-信号量集"><a href="#消息队列、-信号量集" class="headerlink" title="消息队列、 信号量集"></a>消息队列、 信号量集</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct os_q</span><br><span class="line">&#123;</span><br><span class="line">struct os_q *OSQPtr; &#x2F;&#x2F;指向下一个空的队列控制块</span><br><span class="line">void **OSQStart;  </span><br><span class="line">void **OSQEnd;   </span><br><span class="line">void **OSQIn;    </span><br><span class="line">void **OSQOut;   </span><br><span class="line">INT16U OSQSize;</span><br><span class="line">INT16U OSQEntries;&#x2F;&#x2F;已存放消息指针的元素数目</span><br><span class="line">&#125; OS_Q;&#x2F;&#x2F;消息队列</span><br></pre></td></tr></table></figure>
<img src="/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpg" class="" title="消息队列">


<img src="/MCU-Lover/%CE%BCcosII%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1.jpg" class="" title="信号量集">]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式工具</title>
    <url>/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h5 id="UML建模工具"><a href="#UML建模工具" class="headerlink" title="UML建模工具"></a>UML建模工具</h5><p>程序员的画图设计工具<br>1、startUML<br>2、astah （付费）<br>3、process on 网站 [<a href="https://www.processon.com/]" target="_blank" rel="noopener">https://www.processon.com/]</a></p>
<h5 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h5><p>(1)关联关系(association)<br>一个类作为另一个类的成员变量。</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.jpg" class="">

<p>关联的加强，缺一不可—组合关系（有生命中的整体和部分概念）composition</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.jpg" class="">


<p>(2)依赖关系(dependency)<br>一个类用到另外一个类作为参数传入，ming用到了别人的车，虚线</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.jpg" class="">


<p>(3)泛化关系(generalization)<br>父类实现子类例子，如支付宝（功能1，功能2，。。。）</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.jpg" class="">


<p>(4)包含关系<br>一个用例可以包含其他用例具有的行为, 并把它包含的用例行为作为自身行为的一部分</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB.jpg" class="">

<h5 id="UML10种图"><a href="#UML10种图" class="headerlink" title="UML10种图"></a>UML10种图</h5><p>静态模型图: 描述系统的静态结构</p>
<p>•类图<br>•对象图<br>•包图<br>•组件图Component </p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E7%BB%84%E4%BB%B6%E5%9B%BE.jpg" class="">

<p>•部署图deploy</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E9%83%A8%E7%BD%B2%E5%9B%BE.jpg" class="">

<p>动态模型图: 描述系统行为的各个方面</p>
<p>•用例图</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" class="">

<p>•时序图（sequence）</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" class="">


<p>•协作图 Collaboration</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E5%8D%8F%E4%BD%9C%E5%9B%BE.jpg" class="">

<p>•状态图statechart</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" class="">

<p>•活动图(流程图)activity</p>
<img src="/C-C-Lover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%85%B7/%E6%B4%BB%E5%8A%A8%E5%9B%BE.jpg" class="">
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-日历显示</title>
    <url>/QT-Lover/QT-%E6%97%A5%E5%8E%86%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>#include <QCalendarWidget><br>#include <QTextCharFormat></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QDate date&#x3D;QDate::currentDate();</span><br><span class="line">QTextCharFormat t;</span><br><span class="line">t.setBackground(Qt::yellow);</span><br><span class="line"></span><br><span class="line">calendarWidget &#x3D; new QCalendarWidget(this);</span><br><span class="line">calendarWidget-&gt;setGeometry(0,0,600,400);</span><br><span class="line">calendarWidget-&gt;setGridVisible(true);</span><br><span class="line">calendarWidget-&gt;setHorizontalHeaderFormat(QCalendarWidget::ShortDayNames);</span><br><span class="line">calendarWidget-&gt;setVerticalHeaderFormat(QCalendarWidget::NoVerticalHeader);</span><br><span class="line">calendarWidget-&gt;setDateTextFormat(date,t);</span><br><span class="line"></span><br><span class="line">connect(prev_month, SIGNAL(clicked()), calendar_widget, SLOT(showPreviousMonth()));</span><br><span class="line"> connect(next_month, SIGNAL(clicked()), calendar_widget, SLOT(showNextMonth()));</span><br></pre></td></tr></table></figure>

<img src="/QT-Lover/QT-%E6%97%A5%E5%8E%86%E6%98%BE%E7%A4%BA/calendar.gif" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-绘图事件学习闹钟</title>
    <url>/QT-Lover/QT-%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0%E9%97%B9%E9%92%9F/</url>
    <content><![CDATA[<p><strong>用到的参数或函数</strong><br>QRectF 矩形坐标<br>qreal 类似于float<br>绝对值qAbs<br>最大qMax<br>最小qMin<br>开根号Sqr<br>N次方是pow</p>
<p>save() 用于保存 QPainter 的状态<br>restore() 用于恢复 QPainter 的状态<br>translate ( )设置一个逻辑原点<br>roate()  就绕”逻辑原点”旋转<br>painter.setRenderHint(QPainter::Antialiasing);//抗锯齿</p>
<p> /* 信号、槽连接 */<br>connect(timer, SIGNAL(timeout()), this, SLOT(update()));</p>
<p>主要绘图事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oid MainWindow::paintEvent(QPaintEvent *event) &#123;</span><br><span class="line">    Q_UNUSED(event); &#x2F;&#x2F;防止编译报错</span><br><span class="line"></span><br><span class="line">    QPainter painter(this);</span><br><span class="line">    &#x2F;*逻辑原点*&#x2F;</span><br><span class="line">    painter.translate(painPara.translateX, painPara.translateY);</span><br><span class="line"></span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing);</span><br><span class="line">    painter.scale(painPara.scale, painPara.scale);</span><br><span class="line">    painter.setPen(painPara.painterColor);</span><br><span class="line">    painter.setBrush(painPara.painterColor);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 获取系统时间 *&#x2F;</span><br><span class="line">    QTime time &#x3D; QTime::currentTime();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;* 描画时针刻度线 *&#x2F;</span><br><span class="line">    painter.save();</span><br><span class="line">    &#x2F;* 描画时钟数字文本   调用文本函数 *&#x2F;</span><br><span class="line">    int nHour &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 12; ++i) &#123;</span><br><span class="line">        nHour &#x3D; i + 3;</span><br><span class="line">        if (nHour &gt; 12)</span><br><span class="line">            nHour -&#x3D; 12;</span><br><span class="line">        &#x2F;*确定文本位置函数*&#x2F;</span><br><span class="line">        painter.drawText(textRectF(75, 14, i * 30), Qt::AlignCenter, QString::number(nHour));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*时刻度线*&#x2F;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 12; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        painter.rotate(30.0);&#x2F;&#x2F;原来的基础上选旋转30度</span><br><span class="line">        painter.drawLine(82,0,90,0);&#x2F;&#x2F;  100,120</span><br><span class="line">    &#125;</span><br><span class="line">    painter.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;* 描画分针刻度线 *&#x2F;</span><br><span class="line">    painter.save();</span><br><span class="line">    for(int i &#x3D; 0; i&lt;60;i++) &#123;</span><br><span class="line">        if(i % 5)</span><br><span class="line">            painter.drawLine(82,0,87,0);</span><br><span class="line">        painter.rotate(6.0);</span><br><span class="line">    &#125;</span><br><span class="line">    painter.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;* 时针   一个小时30度*&#x2F;</span><br><span class="line">    painter.save();&#x2F;&#x2F;保存</span><br><span class="line">    painter.rotate(30.0 * (time.hour() + time.minute() &#x2F; 60.0)); &#x2F;&#x2F;角度转换30度</span><br><span class="line">    painter.drawConvexPolygon(painPara.coordinateHourHand, 3);   &#x2F;&#x2F;描画的形状</span><br><span class="line">    painter.restore();&#x2F;&#x2F;恢复</span><br><span class="line"></span><br><span class="line">    &#x2F;* 分针 *&#x2F;</span><br><span class="line">    painter.save();</span><br><span class="line">    painter.rotate(6.0 * (time.minute() + time.second() &#x2F; 60.0));</span><br><span class="line">    painter.drawConvexPolygon(painPara.coordinateMinuteHand, 3);</span><br><span class="line">    painter.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;* 秒针 *&#x2F;</span><br><span class="line">    painter.save();</span><br><span class="line">    painter.rotate(6.0 * time.second());</span><br><span class="line">    painter.drawConvexPolygon(painPara.coordinateSecondHand, 3);</span><br><span class="line">    painter.restore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 参考一去二三里的方法 *&#x2F;</span><br><span class="line">QRectF MainWindow::textRectF(double radius, int pointSize, double angle)</span><br><span class="line">&#123;</span><br><span class="line">    QRectF rectF;</span><br><span class="line">    rectF.setX(radius*qCos(angle*M_PI&#x2F;180.0) - pointSize*2);</span><br><span class="line">    rectF.setY(radius*qSin(angle*M_PI&#x2F;180.0) - pointSize&#x2F;2.0);</span><br><span class="line">    rectF.setWidth(pointSize*4);</span><br><span class="line">    rectF.setHeight(pointSize);</span><br><span class="line">    return rectF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图</p>



]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Linux-Lover/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h5 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h5><p>在OSI参考模型中,物理层的作用是<code>透明的传输比特流</code>。对等实体在一次交互作用中传送的信息单位称为<code>协议数据单元</code> ,它包括<code>控制信息和用户信息</code>两部分。上下层实体之间的接口称为服务访问点(SAP) ,网络层的服务访问点也称为<code>网络地址</code> ,通常分为<code>网络号和主机地址</code>两部分。</p>
<h5 id="网络协议问题"><a href="#网络协议问题" class="headerlink" title="网络协议问题"></a>网络协议问题</h5><p>大量发出IP请求,肯定很多不可达,返回不可达错误。<br>网络问题,包未达到终点不可能重组,但可以分散成碎片。<br>网络阻塞问题。拥塞导致丢包。<br>SYN攻击。</p>
<p>如果把一个网络40.15.0.0分为两个子网,第一个子网40.15.0.0/17,那么第二个子网将会是 。 40.15.128.0/17。<br> 解析:/17表示前高17为网络地址，让主网分成两个网段</p>
<h5 id="网络安全问题"><a href="#网络安全问题" class="headerlink" title="网络安全问题"></a>网络安全问题</h5><p>入侵检测与防火墙有何不同,各有什么优缺点?</p>
<p>防火墙的优点:它能增强机构内部网络的安全性,用于加强网络间的访问控制,防止外,部用户非法使用内部网的资源,保护内部网络的设备不被破坏,防止内部网络的敏感数据被窃取。<br>缺点:对于发生在内网的攻击无能为力;</p>
<p>入侵检测的优点:入侵监测系统扫描当前网络的活动,监视和记录网络的流量,根据定义好的规则来过滤从主机网卡到网线上的流量,提供实时报警。大多数的入侵监测系统可以<br>缺点:目前入侵检测技术的方法主要停留在异常检测统计方法和误用检测方法上,入侵的行为表现出不确定性、多样性等特点。</p>
<p>防火墙就相当于一栋大楼外的,门卫系统,而入侵检测就相当于大楼内的监控系统,两者缺一不可。<br>应该将入侵检测系统与防火墙联动起来,当入侵检测系统发现到有入侵行为时,应及时报告防火墙,以阻断入侵。</p>
<p>常见的包括FTP服务的21端口, Telnet服务的23端口,SMTP服务的25端口,以及HTTP服务的80端口,等等。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
  </entry>
  <entry>
    <title>数据库试题</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%98-1/</url>
    <content><![CDATA[<p>数据库面试题主要包括范式、事物、存储过程、SQL语言,以及索引等语方面。</p>
<p><strong>范式</strong></p>
<p>1NF:第一范式。符合1NF的关系中的每个属性都不可再分。<br>2NF:第二范式。2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。模式分解。<br>3NF:第三范式。3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖<br>BCNF:存在着主属性对于码的部分函数依赖与传递函数依赖。<br>4NF:第四范式。不存在非平凡依赖函数。多值依赖的缺点是:数据冗余太大。</p>
<p><strong>存储过程和函数的区别</strong></p>
<p>存储过程是用户定义的一系列SQL语句的集合,涉及特定表或其他对象的任务,用户可以调用存储过程。而函数通常是数据库已定义的方法,它接收参数并返回某种类型的值,并且不涉及特定用户表。</p>
<p><strong>什么是数据库事务</strong></p>
<p>数据库事务是指作为单个逻辑工作单元执行的一系列操作,这些操作要么全做要么全不做,是一个不可分割的工作单位。<br>事务具有原子性、一致性、独立性及持久性等特点</p>
<p><strong>SQL语言</strong></p>
<p> select top 1 num from ppp order by num</p>
<p>–复制表(复制数据,源表名: A,新表名: B):<br>select * into B from A</p>
<p>–临时表<br>create table #Temp（）</p>
<p>primary unique  唯一索引<br>连接字符串符号 “+”</p>
<p>已知tm_employee表中具有默认约束df_adress，删除该约束的语句<br>alter talbe tm_employee drop constraint df_adress</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统试题</title>
    <url>/Linux-Lover/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="临界区和互斥对象"><a href="#临界区和互斥对象" class="headerlink" title="临界区和互斥对象"></a>临界区和互斥对象</h5><p>线程互斥：临界区只能在同一个进程中使用。CRITICAL_SECTION<br>进程互斥：比如共享内存，使用互斥对象。MUTEX OBJECT</p>
<h5 id="请描述进程和线程的差别"><a href="#请描述进程和线程的差别" class="headerlink" title="请描述进程和线程的差别"></a>请描述进程和线程的差别</h5><p>进程是程序的一次执行。线程可以理解为进程中执行的一段程序片段。在一个多任务环境中下面的概念可以帮助我们理解两者间的差别。</p>
<p>进程间是独立的,这表现在内存空间、上下文环境上;线程运行在进程空间内。一般来讲(不使用特殊技术),进程无法突破进程边界存取其他进程内的存储空间;而线程由于处于进程空间内,所以同一进程所产生的线程共享同一内存空间。</p>
<p>同一进程中的两段代码不能够同时执行,除非引入线程。<br>线程是属于进程的,当进程退出时该进程所产生的线程都会被强制退出并清除。</p>
<p>线程占用的资源要少于进程所占用的资源。进程和线程都可以有优先级。进程间可以通过IPC通信,但线程不可以。</p>
<h5 id="当程序不指定DLL的绝对位置时-将使用默认搜索顺序"><a href="#当程序不指定DLL的绝对位置时-将使用默认搜索顺序" class="headerlink" title="当程序不指定DLL的绝对位置时,将使用默认搜索顺序"></a>当程序不指定DLL的绝对位置时,将使用默认搜索顺序</h5><p>搜索顺序为:(1)内存; (2) KnownDLLs; (3)清单与local; (4)应用程序目录; (5)当前工作目录; (6)系统目录; (7)path路径变量。</p>
<h5 id="某虚拟内存系统采用页式内存管理-使用LRU页面管理算法。"><a href="#某虚拟内存系统采用页式内存管理-使用LRU页面管理算法。" class="headerlink" title="某虚拟内存系统采用页式内存管理,使用LRU页面管理算法。"></a>某虚拟内存系统采用页式内存管理,使用LRU页面管理算法。</h5><p>假设内存为4，考虑下面的页面访问地址流(每次访问在一个时间单位内完成)中一共有几次页面失败:<br>1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7</p>
<p>解析: LRU算法的提出,是基于这样一个事实:在前面几条指令中使用频繁的页面,很可能在后面的几条指令中频繁使用。反过来说,已经很久没有使用的页面,很可能在未来软长的一段时间内不会被用到。6次失败</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算与嵌入式编程</title>
    <url>/C-C-Lover/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>优先级</strong></p>
<p>1 &lt;&lt; 3 + 2 &amp; 7等价于 (1 &lt;&lt; (3 + 2))&amp;7</p>
<img src="/C-C-Lover/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B/%E4%BC%98%E5%85%88%E7%BA%A7.png" class="">


<p><strong>位制转化</strong></p>
<p>#include <iostream><br>using namespace std;<br>int main()<br>{<br>    printf(“%f\n”,5);//0.000000<br>    printf(“%d”,5.01);//大整数<br>    system(“pause “);<br>    return 0;<br>}</p>
<p> <strong>进制</strong></p>
<p> 13<em>16=244 可以用几进制表示？<br> （X+3）</em>（X+6）=2X^2+4X+4<br> X=7</p>
<p> <strong>转换</strong></p>
<p> // 基本类型能转换 但是不能转换指针类型<br>p2 = static_cast&lt;int *&gt; (p1);</p>
<p>//法从char*转换为int *可以使用<br>reinterpret_cast 进行重新解释<br>p2 = reinterpret_cast&lt;int *&gt; (p1);</p>
<p>//reinterpret_cast 可以强制类型转换<br>Book *book2= reinterpret_cast&lt;Book *&gt; (base);</p>
<p>而(dynamic cast &lt;B*&gt;(pa))-&gt;foo0);将导致程序崩溃,因为调用了虚函数,编译器需要根据对象的虚函数指针查找虚函数表,但此时是空,为非法访问。B对象实例化才有虚</p>
<p>如果将A a;改为B b;就可正常运行了。</p>
<p><strong>嵌入式编程</strong></p>
<p>ISR 中断子程序<br>(1) ISR不能返回一个值。<br>(2) ISR不能传递参数。<br>(3)在许多处理器/编译器中,浮点一般都是不可重入的。<br>(4) printf经常有重入和性能上的问题,所以一般不使用printf</p>
<p>volatile<br>volatile修饰符的主要目的是提示编译器该对象的值可能在编译器未监测到的情况下被改变,因此编译器不能武断地对引用这些对象的代码做优化处理。</p>
<p><strong>补码</strong></p>
<p>正数的补码等于他的原码<br>负数的补码等于反码+1。<br>常用：-10<br>-（128-（10））= -118</p>
<p><strong>static</strong></p>
<p>(1)函数体内static变量的作用范围为该函数体,因此其值在下次调用时仍维持上次的值。<br>(2)在模块内的static全局变量可以被模块内所有函数访问,但不能被模块外其他函数访问。<br>(3)在模块内的static函数只可被这一模块内的其他函数调用,这个函数的使用范围被限制在声明它的模块内。<br>(4)在类中的static成员变量属于整个类所拥有,对类的所有对象只有一份复制。<br>(1)在类中的static成员函数属于整个类所拥有,这个函数不接收this指针,因而只能访问类的static成员变量。�</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>继承与接口</title>
    <url>/C-C-Lover/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>虚函数继承和虚继承是完全不同的两个概念。<br><strong>重载、重写</strong></p>
<p>函数重载<br>必须在同一个类中进行<br>子类无法重载父类的函数，父类同名函数将被名称覆盖<br>重载是在编译期间根据参数类型和个数决定函数调用</p>
<p>函数重写<br>必须发生于父类与子类之间<br>并且父类与子类中的函数必须有完全相同的原型<br>使用virtual声明之后能够产生多态<br>(如果不使用virtual，那叫重定义)</p>
<p><strong>为什么虚函数效率低?</strong></p>
<p>因为虚函数需要一次间接的寻址,而一般的函数可以在编译时定位到函数的地址,虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程,效率肯定会低一些,但带来了运行时的多态。<br><strong>多重继承的优缺点</strong></p>
<p>优点：简单清晰，更有利于复用。不会因为基类一个小小的改变而大张旗鼓去改代码。<br>缺点：二义性。两个基类中有同名方法的时候，你不得不在子类的调用中指明此方法出自那个基类。用虚继承会带来性能损失。</p>
<p><strong>构造函数中需要初始化列表初始化</strong></p>
<p>1）对象初始化列表出现原因<br>1.如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数。</p>
<p>2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。</p>
<p><strong>纯虚函数</strong></p>
<p>virtual fun()=0;<br>一个纯虚函数,不能实例化一个对象的。是把函数修改成一般的虚函数。<br>virtual fun(){};</p>
<p>虚指针或虚函数指针是一个虚函数的实现细节。带有虚函数的类中的每一个对象,都有一个虚指针指向该类的虚函数表。</p>
<p>虚函数的入口地址和普通函数有什么不同?<br>当一个包含虚函数的对象(注意,不是对象的指针)被创建的时候,它在头部附加一个指针,指向vtable中相应的位置。调用虚函数的时候,不管你是用什么指针调用的,它先根据vtable找到入口地址再执行,从而实现了“动态联编”。而不像普通函数那样简单地跳转到一个固定地址。</p>
<p>C++如何阻止一个类被实例化？<br>(1)定义一个无用的抽象函数，使得类成为抽象类<br>(2)将构造函数定义为private.<br>一些工具类,没有被实例化的必要.</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象基础</title>
    <url>/C-C-Lover/%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>面向对象设计的三原则</strong></p>
<p>封装,继承,多态。<br>封装关键字：private、protect之类，访问控制，信息隐藏。</p>
<p><strong>对于一个空类,编译器默认产生4个成员函数</strong></p>
<p>默认构造函数、析构函数、复制造函数和赋值函数</p>
<p><strong>成员变量</strong></p>
<p>静态成员数据类中共享。<br>程序错在设定了静态成员变量,却没有给静态成员变量赋初值。如果把静态成」员数据设为私有,可以通过公有静态成员函数访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	const int size &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line">修改1：</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line"> A()</span><br><span class="line"> &#123;</span><br><span class="line"> const int size &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">修改1：</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">static  const int size &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数与析构函数</strong></p>
<p>无论析构函数是不是虚函数,派生类对象被撤销时,最后调其基类的析构函数。<br>为什么虚析构函数？<br>所有对象都存在于栈框中,当离开其所处的作用域时,该对象会被自动撤销,似乎看不出什么大问题。但是试想,如果CChild类的构造函数CChild()在堆中分配了内存,而其析构函数又不是virtual型的,那么撤销pBase时,将不会调用CChild::~CChildo().从而不会释放CChild:CChild()占据的内存,造成内存泄漏。</p>
<p>析构函数可以为virtual型,构造函数则不能。那么为什么构造函数不能为虚呢?<br>虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的情况下工作的机制,特别允许我们调用一个只知道接口而不知道其准确对象类型的函数。但是如果要创建一个对象,你势必要知道对象的准确类型,因此构造函数不能为虚。</p>
<p>如果虚函数是非常有效的,我们是否可以把每个函数都声名为虚函数?</p>
<p>不行,这是因为虚函数是有代价的:由于每个虚函数的对象都必须维护一个v表,因此在使用虚函数的时候都会产生一个系统开销。</p>
<p>析构函数可以内联？<br>可以。</p>
<p><strong>多态的概念</strong></p>
<p>多态性可以简单地概括为“一个接口,多种方法”,在程序运行的过程中才决定调用的。<br>静态，动态，多态？<br>分为静态多态（函数重载，泛型编程）和动态多态（虚函数）<br>宏,内联函数,模板都可以在编译时候解析,唯独虚函数不行,它必须在运行时才能确定。</p>
<p>重载与覆盖？<br>重载：已有的函数同名，参数不一致。<br>覆盖：虚函数，派生重写基类虚函数。</p>
<p><strong>友元friend</strong></p>
<p>类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有成员,程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员,但是如果将数据成员都定义为公有的,这又破坏了隐藏的特性。<br>使用友元的方案。友元是一种定义在类外部的普通函数.</p>
<p><strong>异常</strong></p>
<p>catch代码块必须出现在try后，并且在try块后可以出现多个catch代码块，以捕捉各种不同类型的抛掷。<br>异常机制是基于这样的原理：程序运行实质上是数据实体在做一些操作，因此发生异常现象的地方，一定是某个实体出了差错，该实体所对应的数据类型便作为抛掷和捕捉的依据。</p>
<p>栈解旋;异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。</p>
<p>1）为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如：<br>void func() throw (A, B, C , D); //这个函数func（）能够且只能抛出类型A B C D及其子类型的异常。<br>2）如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的异常，例如：<br>void func();<br>3）一个不抛掷任何类型异常的函数可以声明为：<br>void func()  throw();</p>
<p>构造函数有必要异常抛出。<br>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int divide(int x, int y )</span><br><span class="line">&#123;</span><br><span class="line">	if (y &#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		throw x;</span><br><span class="line">	&#125;</span><br><span class="line">	return x&#x2F;y;</span><br><span class="line"></span><br><span class="line">void main41()</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;8&#x2F;2 &#x3D; &quot; &lt;&lt; divide(8, 2) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;10&#x2F;0 &#x3D;&quot; &lt;&lt; divide(10, 0) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (int e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;e&quot; &lt;&lt; &quot; is divided by zero!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</span><br><span class="line"> 	system(&quot;pause&quot;);</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL模板与容器</title>
    <url>/C-C-Lover/STL%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p><strong>STL容器介绍</strong></p>
<p>   标准模板库是一个基于模板的容器类库,包括链表、列表、队列和堆栈。标准模板库还包含许多常用的算法,包括排序和查找。<br>   标准模板库容器类有两种类型,分别为顺序和关联。顺序容器可以提供对其成员的顺序访问和随机访问。关联容器则经过优化关键值访问它们的元素。标准模板库在不同操作系统间是可移植的。所有标准模板库容器类都namespace std 定义。</p>
<p><strong>二次析构 深拷贝与浅拷贝</strong></p>
<p>构造函数的问题深复制<br>CDemo(const CDemo &amp;cd)<br>{<br>    this-&gt;str = new char[strlen(cd.str)+1];<br>    strcp(str,cd.str);<br>}</p>
<p><strong>erase()</strong><br>错误:野指针<br>for(vector<int>::iterator iter=veci.begin(); iter!=veci.end(); iter++)<br>{<br>      if( *iter == 3)<br>             veci.erase(iter);<br>}<br>错误：无法删除连续3<br>for(vector<int>::iterator iter=veci.begin(); iter!=veci.end(); iter++)<br>{<br>      if( *iter == 3)<br>             iter = veci.erase(iter);<br>}<br>正确1：<br>for(vector<int>::iterator iter=veci.begin(); iter!=veci.end(); )<br>{<br>     if( *iter == 3)<br>          iter = veci.erase(iter); //返回值指向删除元素的下一个元素<br>      else<br>            iter ++ ;<br>}</p>
<p>正确2：<br>veci.earse(remove(veci.begin(),veci.end(),3),veic.end());<br>remove函数删除元素后并不会改变vector的大小，只是把后面的元素往前移，并返回一个指向vector末尾的新迭代器。</p>
<p><strong>泛型编程</strong></p>
<p>泛型编程是一种基于发现高效算法的最抽象表示的编程方法。也就是说,以算法为起点并寻找能使其工作且有效率工作的最一般的必要条件集。泛型编程假定有某些基本的法则在支配软件组件的行为,并且基于这些法则有可能设计可互操作的模块,甚至还有可以使用此法则去指导我们的软件设计。STL就是一个泛型编程的例子。</p>
<p>普通函数转为泛型函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int* find1(const int * array,int n ,int x)</span><br><span class="line">&#123;</span><br><span class="line">	const int * p &#x3D; array;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*p &#x3D;&#x3D; x)</span><br><span class="line">		&#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">const T* find1(const T * array, T n, T x)</span><br><span class="line">&#123;</span><br><span class="line">	const T * p &#x3D; array;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*p &#x3D;&#x3D; x)</span><br><span class="line">		&#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;求除</span><br><span class="line">int jug(int x ,int y)</span><br><span class="line">&#123;</span><br><span class="line">	if (x &gt;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(y &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return x &#x2F; y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求差</span><br><span class="line">int  mins(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	return (x - y);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求和</span><br><span class="line">int  sub(int x ,int y)</span><br><span class="line">&#123;</span><br><span class="line">	return (x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  mytest(int (*p)(int ,int),int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret &#x3D; (*p)(a, b);</span><br><span class="line">	cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	mytest(sub, 1, 4);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool check[10] &#x3D; &#123;false&#125;;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">void nineBitInteger(int k, long long a)</span><br><span class="line">&#123;  </span><br><span class="line">	if (k&amp;&amp;a%k !&#x3D; 0)return;</span><br><span class="line">	if (k &#x3D;&#x3D; 9)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(a);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; 9; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!check[i])  &#x2F;&#x2F;互斥的感觉</span><br><span class="line">		&#123; </span><br><span class="line">			check[i] &#x3D; 1;</span><br><span class="line">			mysum(k + 1, a * 10 + i);</span><br><span class="line">			check[i] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	mysum(0, 0);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; v.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针复习</title>
    <url>/C-C-Lover/%E6%8C%87%E9%92%88%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>指针和引用的差别</strong><br>(1)非空区别。在任何情况下都不能使用指向空值的引用。<br>(2)合法性区别。在使用引用之前不需要测试它的合法性。指针则应该总是被测试,防止其为空。<br>(3)可修改区别。指针可以被重新赋值以指向另一个不同的对象。引用则总是指向在初始化时被指定的对象不能改变,但其内容可以改变。<br>(4)应用区别。<br>·一是考虑到存在不指向任何对象的可能(在这种情况下,能够设置指针为空),二是需要能够在不同的时刻指向不同的对象。<br>·如果总是指向一个对象并且一旦指向一个对象后就不会改变指向,那么应该使用引用。</p>
<p><strong>传递动态内存</strong></p>
<p>//禁止写法：<br>int *tmp;<br>*tmp = *P;<br>//系统随即安排tmp的地址，函数结束不回收，造成内存泄漏<br>例如下列也是不予许的。<br> int *ptr;<br> ptr = (int *)0x8000;   //这里<br> *ptr = 0xaabb;<br> 因为如果0x8000的内存地址已被其它程序占用，则会崩溃</p>
<p><strong>函数指针</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	数组参数					等效的指针参数</span><br><span class="line">一维数组 char a[30]				指针 char*</span><br><span class="line">指针数组 char *a[30]				指针的指针 char **a</span><br><span class="line">二维数组 char a[10][30]			数组的指针 char(*a)[30]  &#x2F;&#x2F;行</span><br><span class="line"></span><br><span class="line"> int a[10]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">看出 &amp;a+1 实际上增长是40，就是整个数组的长度。</span><br><span class="line"></span><br><span class="line">char str3[][80] &#x3D; &#123;&quot;C++&quot;,&quot;JAVA&quot;,&quot;C&quot;,&quot;PYTHON&quot;&#125;;</span><br><span class="line">char *str &#x3D; &quot;123456789&quot;; &#x2F;&#x2F;8 字节 64位系统 </span><br><span class="line">printf(&quot;%d,&quot;, sizeof(str)); &#x2F;&#x2F;320</span><br><span class="line">printf(&quot;%d,&quot;, strlen((char* )str3)); &#x2F;&#x2F;3</span><br><span class="line">printf(&quot;%d,&quot;, sizeof(str3)); &#x2F;&#x2F;320</span><br></pre></td></tr></table></figure>
<p><strong>迷途指针</strong></p>
<p>delete 后,使用迷途指针并且重新赋值，造成系统崩溃。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef unsigned short int USHORT;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">USHORT *pInt &#x3D; new USHORT ;</span><br><span class="line">*pInt &#x3D; 10 ;</span><br><span class="line">std::cout &lt;&lt; &quot;pInt：&quot; &lt;&lt; *pInt &lt;&lt; std::endl ;</span><br><span class="line">delete pInt ;</span><br><span class="line">long *pLong &#x3D; new long ;</span><br><span class="line">*pLong &#x3D; 90000 ;</span><br><span class="line">std::cout &lt;&lt; &quot;*pLong：&quot; &lt;&lt; *pLong &lt;&lt; std::endl ;</span><br><span class="line">*pInt &#x3D; 20 ;</span><br><span class="line">std::cout &lt;&lt; &quot;pInt：&quot; &lt;&lt; *pInt &lt;&lt; std::endl ;</span><br><span class="line">*pInt &#x3D; 20 ;</span><br><span class="line">std::cout &lt;&lt; &quot;*pInt：&quot; &lt;&lt; *pInt &lt;&lt; std::endl ;</span><br><span class="line">std::cout &lt;&lt; &quot;*pLong：&quot; &lt;&lt; *pLong &lt;&lt; std::endl;</span><br><span class="line">delete pLong ;</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">*pInt：10</span><br><span class="line">*pLong：90000</span><br><span class="line">*pInt：20</span><br><span class="line">*pInt ：65556</span><br></pre></td></tr></table></figure>
<p>90000存储到pLong指向的内存中。它指向的是pInt原来指向的内存块，带来麻烦的是 pInt = 20，它将20赋值到pInt原先指向的内存，将覆盖pLong指向的内存。这被称为重踏指针，它通常是使用迷途指针产生的不幸后果。<br>15F90H   被0014H  覆盖 == 10014 == 65556</p>
<p><strong>迷途指针和空指针</strong></p>
<p>当delete一个指针的时候,实际上仅是让编译器释放内存,但指针本身依然存在。,这时它就是一个迷途指针。<br>当使用以下语句时,可以把迷途指针改为空指针<br>ptr= 0；</p>
<p><strong>野指针</strong></p>
<p>如果程序定义了一个指针，就必须要立即让它指向一个我们设定的空间或者把它设为NULL，如果没有这么做，那么这个指针里的内容是不可预知的，即不知道 它指向内存中的哪个空间（即野指针）。</p>
<p><strong>句柄和指针</strong></p>
<p>如果简单地理解,似乎我们只要获知这个内存的首地址,那么就可以随时用这个地址访问对象？那么就大错特错了。</p>
<p>内存来回移动。部分对换，内存空间。<br>句柄地址(稳定)一记载着对象在内存中的地址<br>对象在内存中的地址(不稳定)一实际对象。</p>
<p>程序每次重新启动,系统不能保证分配给这个程序的句柄还是原来的那个句柄。句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源,隐藏系统的信息。32bit的uint,指针则标记某个物理内存地址,两者是不同的概念。</p>
<p><strong>this指针</strong></p>
<p>(1)this指针本质一个函数参数，编译器隐藏<br>(2)this成员函数开始前构造，成员结束后清除<br>(3)this不占用对象空间<br>(4)this指针会因编译器不同而有不同的放置位置。可能是堆、栈,也可能是寄存器。<br>(5)this成员函数内使用使用</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式试题自测——20200723</title>
    <url>/C-C-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AF%95%E9%A2%98%E8%87%AA%E6%B5%8B%E2%80%94%E2%80%9420200723/</url>
    <content><![CDATA[<p>1、强制转化</p>
<p>其中单精度浮点数float遵从IEEE R32.24<br>32bits<br>1 符号S   8 阶数E  23 尾数M</p>
<p>1.0f<br>二进制：1.0<br>E=e+127=127<br>0 01111111  00000000000000000000000</p>
<p>125.5f<br>二进制：1111101.1<br>科学计数为：1.111101*2^6<br>E=e+127=133，而E的二进制码为10000101<br>0 10000101 11110100000000000000000</p>
<p>2、宏定义<br>#define SECONDS_PRE_YEAR (365<em>24</em>60*60)UL<br>#define MIN(A,B)   ((A)&lt;=(B)？(A):(B))</p>
<p>3、const与#define区别</p>
<p>（1）const常量有数据类型，#define 没有数据类型<br>（2）const可集成化调试，不能对宏进行调试<br>（3）const常量必须同时初始化。<br>C中const外连接，C++const内连接。<br>在C++中调用extern const buff;</p>
<p>4、sizeof与strlen<br>sizeof<br>strlen:含有’/0’</p>
<p>5、inline 与宏定义<br>内联是代码嵌入，减少函数调用的资源消耗，函数体内无（for\while\switch）。<br>宏不是函数，预处理时的字符串替换。<br>void fun(int x,int y);<br>inline void fun(int x,int y);</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h5 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct  node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct linkqueue</span><br><span class="line">&#123;</span><br><span class="line">	node *first;</span><br><span class="line">	node *rear;</span><br><span class="line">&#125;queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入队列</span><br><span class="line"></span><br><span class="line">queue* insertqueue(queue * myqueue, int x )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	node * qm;</span><br><span class="line">	qm &#x3D; (node  *)malloc( sizeof(node));</span><br><span class="line">	qm-&gt;data &#x3D; x;</span><br><span class="line">	qm-&gt;next &#x3D; NULL;</span><br><span class="line">	if (myqueue-&gt;rear &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		myqueue-&gt;first &#x3D; qm;</span><br><span class="line">		myqueue-&gt;rear &#x3D; qm;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		myqueue-&gt;rear-&gt;next &#x3D; qm;</span><br><span class="line">		myqueue-&gt;rear &#x3D; qm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return myqueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;出队列</span><br><span class="line">queue* insertqueue(queue * myqueue)</span><br><span class="line">&#123;</span><br><span class="line">	node *pm&#x3D; NULL;</span><br><span class="line">	int x;</span><br><span class="line">	if (myqueue &#x3D;&#x3D; NULL )</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">		printf(&quot;队空，没有元素\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		x &#x3D; myqueue-&gt;first-&gt;data;</span><br><span class="line">		pm &#x3D; myqueue-&gt;first;</span><br><span class="line">		if (myqueue-&gt;first &#x3D;&#x3D; myqueue-&gt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			myqueue-&gt;first &#x3D; NULL;</span><br><span class="line">			myqueue-&gt;rear &#x3D; NULL;</span><br><span class="line">			printf(&quot;出队的元素是%d\n&quot;, x);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			myqueue-&gt;first &#x3D; myqueue-&gt;first-&gt;next;</span><br><span class="line">				free(pm);</span><br><span class="line">				printf(&quot;出队的元素是%d\n&quot;, x);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return myqueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int traversequeue(node * myqueuefirst)</span><br><span class="line">&#123;</span><br><span class="line">	if (myqueuefirst &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d &quot;, myqueuefirst-&gt;data);</span><br><span class="line">	traversequeue(myqueuefirst-&gt;next);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*自己先弄个队列，用来操作*&#x2F;</span><br><span class="line">	queue * myqueue &#x3D; (queue *)malloc(sizeof(queue));</span><br><span class="line">	node * s &#x3D; (node *)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; 0;</span><br><span class="line">	s-&gt;next &#x3D; NULL;</span><br><span class="line">	myqueue-&gt;first &#x3D; myqueue-&gt;rear &#x3D; s;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;myqueue &#x3D; insertqueue(myqueue,1);</span><br><span class="line">	&#x2F;&#x2F;myqueue &#x3D; insertqueue(myqueue, 4);</span><br><span class="line">	&#x2F;&#x2F;myqueue &#x3D; insertqueue(myqueue, 2);</span><br><span class="line">	myqueue &#x3D; insertqueue(myqueue);</span><br><span class="line">	myqueue &#x3D; insertqueue(myqueue, 6);</span><br><span class="line"></span><br><span class="line">	traversequeue(myqueue-&gt;first);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#define MAXSIZE  5    &#x2F;&#x2F;最大容量是5个元素</span><br><span class="line">struct queue   &#x2F;&#x2F;队列</span><br><span class="line">&#123;</span><br><span class="line">       int a[MAXSIZE];   &#x2F;&#x2F;队列元素</span><br><span class="line">       int front;          &#x2F;&#x2F;队头</span><br><span class="line">       int rear;           &#x2F;&#x2F;队尾</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void enqueue(struct queue *q)</span><br><span class="line">&#123;</span><br><span class="line">       int e;</span><br><span class="line">       if(q-&gt;rear&lt;MAXSIZE-1)</span><br><span class="line">       &#123;</span><br><span class="line">              printf(&quot;请输入入队的元素：&quot;);</span><br><span class="line">              scanf(&quot;%d&quot;,&amp;e);</span><br><span class="line">              q-&gt;a[q-&gt;rear]&#x3D;e;</span><br><span class="line">              q-&gt;rear++;</span><br><span class="line">              printf(&quot;入队成功\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">              printf(&quot;溢出\n&quot;);                                   </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dequeue(struct queue *q)</span><br><span class="line">&#123;</span><br><span class="line">       int e;</span><br><span class="line">       if(q-&gt;front&#x3D;&#x3D;q-&gt;rear)  &#x2F;&#x2F;用e接收出队的元素</span><br><span class="line">       &#123;</span><br><span class="line">              printf(&quot;队空，没有元素\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;          </span><br><span class="line">           e&#x3D;q-&gt;a[q-&gt;front];</span><br><span class="line">           q-&gt;front++;</span><br><span class="line">           printf(&quot;出队的元素是%d\n&quot;,e);                    </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两个栈模拟队列—leetcode"><a href="#两个栈模拟队列—leetcode" class="headerlink" title="两个栈模拟队列—leetcode"></a>两个栈模拟队列—leetcode</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 300</span><br><span class="line">#define REAR 1</span><br><span class="line">#define FRONT 0</span><br><span class="line">typedef struct CQueue</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置2个数组，即2个栈空间，分别定义2个宏REAR，FRONT现性的指明。</span><br><span class="line">    int data[2][MAXSIZE];</span><br><span class="line">    int front, rear;</span><br><span class="line">&#125; CQueue;</span><br><span class="line"></span><br><span class="line">CQueue* cQueueCreate() &#123;</span><br><span class="line">    </span><br><span class="line">    CQueue* obj &#x3D; (CQueue*)malloc(sizeof(CQueue));</span><br><span class="line">    if (!obj)</span><br><span class="line">        return NULL;</span><br><span class="line">    memset(obj, 0, sizeof(CQueue));</span><br><span class="line">    obj-&gt;rear &#x3D; obj-&gt;front &#x3D; -1;    &#x2F;&#x2F;rear和front分别为一个栈空间的栈顶指针,初始化指向栈底。</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cQueueAppendTail(CQueue* obj, int value) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否满队</span><br><span class="line">    if (obj-&gt;rear &#x3D;&#x3D; MAXSIZE - 1 || obj-&gt;front &#x3D;&#x3D; MAXSIZE - 1)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果数据在front栈，则转移数据到rear栈中</span><br><span class="line">    while (obj-&gt;front !&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">    obj-&gt;data[REAR][++obj-&gt;rear] &#x3D; obj-&gt;data[FRONT][obj-&gt;front--];&#x2F;&#x2F;核心</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;data[REAR][++obj-&gt;rear] &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cQueueDeleteHead(CQueue* obj) &#123;</span><br><span class="line">    if (obj-&gt;rear &#x3D;&#x3D; obj-&gt;front)&#x2F;&#x2F;队列为空</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果数据在rear栈，则转移数据到front栈中</span><br><span class="line">    while (obj-&gt;rear !&#x3D; -1)</span><br><span class="line">        obj-&gt;data[FRONT][++obj-&gt;front] &#x3D; obj-&gt;data[REAR][obj-&gt;rear--];&#x2F;&#x2F;核心</span><br><span class="line"></span><br><span class="line">    return obj-&gt;data[FRONT][obj-&gt;front--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cQueueFree(CQueue* obj) &#123;</span><br><span class="line">    free(obj);</span><br><span class="line">    obj &#x3D; NULL ;</span><br></pre></td></tr></table></figure>

<img src="/Data-Structure-and-Algorithms-Lover/%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97.jpg" class="">


]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-动画</title>
    <url>/QT-Lover/QT-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p><strong>QPropertyAnimation 属性动画</strong></p>
<p> /*  声明动画类，并将控制对象<br>  QPropertyAnimation* animation = new QPropertyAnimation(this, “geometry”);<br>/*  设置动画持续时长为 2 秒钟 <em>/<br>animation-&gt;setDuration(2000);<br>/</em>  设置动画的起始状态<br> animation-&gt;setStartValue(QRect(1, 2, 3, 4));<br>/*  设置动画的结束状态 结束点 (100,200)  结束大小 (300,400)*/<br>animation-&gt;setEndValue(QRect(100, 200, 300, 400));<br>animation-&gt;start();  </p>
<p><strong>QGraphicsEffect 修改图形效果</strong></p>
<p>–QGraphicsBlurEffect在给定的半径内模糊项目<br>QGraphicsBlurEffect *e0 = new QGraphicsBlurEffect(this);<br>e0-&gt;setBlurRadius(0.2);</p>
<p>QGraphicsColorizeEffect—以任何给定颜色<br>QGraphicsColorizeEffect *e1 = new QGraphicsColorizeEffect(this);<br>e1-&gt;setColor(QColor(0,0,192));</p>
<p>–qgraphicsdropshadowEffect用于设定阴影的颜色<br>QGraphicsDropShadowEffect *e2 = new QGraphicsDropShadowEffect(this);<br>e2-&gt;setOffset(8,8);</p>
<p>–QGraphicsOpacityEffect以不透明度呈现项目<br>QGraphicsOpacityEffect *e3 = new QGraphicsOpacityEffect(this);<br>e3-&gt;setOpacity(0.7);</p>
<p>例子：左边5下边10的阴影</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> for(int i&#x3D;0; i&lt;4; i++)&#123;</span><br><span class="line">&#x2F;* 绑定动画对象 *&#x2F;</span><br><span class="line">propertyAnimation[i] &#x3D; new QPropertyAnimation(loopWidgetArr[i], &quot;geometry&quot;);</span><br><span class="line">propertyAnimation[i]-&gt;setDuration(500);&#x2F;&#x2F;动画长度是0.5s</span><br><span class="line"> &#x2F;* 设置阴影效果，让循环面板不显生硬 *&#x2F;</span><br><span class="line"> loopGraphicsDropShadowEffect[i] &#x3D; new QGraphicsDropShadowEffect(this);</span><br><span class="line">loopGraphicsDropShadowEffect[i]-&gt;setOffset(-5,10);</span><br><span class="line">if (i &lt; 2)</span><br><span class="line">loopGraphicsDropShadowEffect[i]-&gt;setColor(QColor(&quot;#444444&quot;));</span><br><span class="line">        else</span><br><span class="line">loopGraphicsDropShadowEffect[i]-&gt;setColor(QColor(&quot;#eeeeee&quot;));</span><br><span class="line">loopGraphicsDropShadowEffect[i]-&gt;setBlurRadius(30);</span><br><span class="line">loopWidgetArr[i]&gt;setGraphicsEffect(loopGraphicsDropShadowEffect[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程小记——文件函数</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0-1/</url>
    <content><![CDATA[<h5 id="文件属性结构体stat"><a href="#文件属性结构体stat" class="headerlink" title="文件属性结构体stat"></a>文件属性结构体stat</h5><p>st_dev:文件所在磁盘的磁盘的 ID 号<br>st_ino：节点编号<br>st_mode:描述文件的类型和权限<br>st_nlink:硬链接的数量<br>st_uid:文件属于用户的 ID<br>st_gid:文件所属用户组 ID<br>st_rdev:如果是设备文件则是设备 ID 号<br>st_size:文件大小<br>st_blksize:文件内容对应的块的大小<br>st_blocks:文件内容对应得块数量<br>time_t st_atime; //文件最后被访问的时间<br>time_t st_mtime; //文件内容最后被修改的时间<br>time_t st_ctime; //文件状态改变时间</p>
<p>显示文件大小M<br> ls -l –block-size=m</p>
<p> st_mode<br> 头文件是使用8进制如st_mode=33279</p>
<p> dout=stat(“1.txt”,&amp;buf);//stat 后 buf 就有内容了</p>
<h5 id="access-函数检查权限设置"><a href="#access-函数检查权限设置" class="headerlink" title="access  函数检查权限设置"></a>access  函数检查权限设置</h5><p> ret=access(name,F_OK);  文件存在<br> ret=access(name,R_OK);  可读<br> ret=access(name,X_OK); 可写</p>
<p> #chown -R root /home/ming<br> #chgrp - R root /home/ming/file/a.txt</p>
<h5 id="目录文件函数"><a href="#目录文件函数" class="headerlink" title="目录文件函数"></a>目录文件函数</h5><p> opendir与readdir函数<br> 目录文件信息结构体 dirent</p>
<p> DIR *pDir = NULL;<br>struct dirent * pEnt = NULL;<br>pDir = opendir(argv[1]);<br>pEnt = readdir(pDir);</p>
<p>注意：readdir 调用一次，只能读取一个文件。要读取 n 个文件必须 n 次调用。readdir 函数内部会记忆哪个目录项已经被读过了哪个还没读，所以多次调用后不会重复返回已经返回过的目录项<br>目录操作函数 scandir<br>int scandir(const char <em>dirp, struct dirent **</em>namelist,<br>              int (<em>filter)(const struct dirent *),<br>              int (</em>compar)(const struct dirent *<em>, const                                     struct dirent *</em>));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用</span><br><span class="line">1、首字母为英语</span><br><span class="line">n&#x3D;(int)dp-&gt;d_name[0];</span><br><span class="line">if(n&gt;64&amp;&amp;n&lt;123)&#123;</span><br><span class="line"></span><br><span class="line">2、.c文件的</span><br><span class="line">int len &#x3D; strlen((*dent)-&gt;d_name);</span><br><span class="line"> if (len &gt;&#x3D; 2</span><br><span class="line">       &amp;&amp; (*dent)-&gt;d_name[len - 2] &#x3D;&#x3D; &#39;.&#39;</span><br><span class="line">       &amp;&amp; (*dent)-&gt;d_name[len - 1] &#x3D;&#x3D; &#39;c&#39;)</span><br><span class="line">printf(&quot;name：[%s] \n&quot;, (*dent)-&gt;d_name);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程小记——系统信息函数</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>time 函数</strong></p>
<p>time_t tNOW=-1;<br>tNOW= time(NULL);//返回值的方式<br>printf(“time:%ld\n\n”,tNOW);<br>输出：time:1595062647</p>
<p><strong>ctime 函数</strong></p>
<p>time_t tNOW=-1;<br>struct tm tmNow;<br>tNOW= time(NULL);//返回值的方式<br>printf(“ctime:%s\n”,ctime(&amp;tNOW));<br>输出：ctime:Sat Jul 18 16:57:29 2020</p>
<p> <strong>gtime 函数</strong></p>
<p> //UTC 时间，原子钟时间，非常精确，现在一般用这个<br>memset(&amp;tmNow,0,sizeof(tmNow));//将 tmNow 清零<br>gmtime_r(&amp;tNOW,&amp;tmNow);<br>printf(“年%d 月%d 日%d时%d\n\n”,tmNow.tm_year,tmNow.tm_mon,tmNow.tm_mday,tmNow.tm_hour);</p>
<p><strong>localtime 函数</strong></p>
<p>//localtime 以当前计算机中设置的时区为小时的时间基准 </p>
<p>memset(&amp;tmNow,0,sizeof(tmNow));//将 tmNow 清零<br>localtime_r(&amp;tNOW,&amp;tmNow);<br>printf(“年%d 月%d 日%d 时%d\n\n”,tmNow.tm_year,tmNow.tm_mon,tmNow.tm_mday,tmNow.tm_hour);</p>
<p>__mktime asctime函数 __</p>
<p>memset(&amp;tmNow,0,sizeof(tmNow));//将 tmNow 清零<br>localtime_r(&amp;tNOW,&amp;tmNow);<br>printf(“mktime:%ld\n”,mktime(&amp;tmNow));<br>printf(“asctime:%s\n”,asctime(&amp;tmNow));</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>八大排序</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>冒泡排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[5] &#x3D; &#123;5,4,3,2,1&#125;</span><br><span class="line">int i &#x3D; 0,j &#x3D; 0;</span><br><span class="line">int n &#x3D; sizeof(a) &#x2F; sizeof(a[0]);</span><br><span class="line">for(i &#x3D; 0;i &lt; n - 1;i++)  		&#x2F;&#x2F; 运行O(n)次</span><br><span class="line">&#123;  </span><br><span class="line">		for(j &#x3D; 0;j &lt; n - 1 - i;j++)	</span><br><span class="line">		&#123;</span><br><span class="line">				if(a[j] &gt; a[j + 1])</span><br><span class="line">				&#123;</span><br><span class="line">						a[j] ^&#x3D; a[j + 1];</span><br><span class="line">						a[j + 1] ^&#x3D; a[j];</span><br><span class="line">						a[j] ^&#x3D; a[j + 1];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>选择排序</strong> 先定最小值升序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[5] &#x3D; &#123;5,4,3,2,1&#125;</span><br><span class="line">int i &#x3D; 0,j &#x3D; 0,k &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(a) &#x2F; sizeof(a[0]);</span><br><span class="line">for(i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">		k &#x3D; i;  &#x2F;&#x2F;表示最小元素的下标</span><br><span class="line">		for(j &#x3D; i + 1;j &lt; len;j++)</span><br><span class="line">		&#123;</span><br><span class="line">				if(a[j] &lt; a[k])</span><br><span class="line">						k &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">		if(i !&#x3D; k)  &#x2F;&#x2F;k 变了就交换</span><br><span class="line">		&#123;</span><br><span class="line">				a[i] ^&#x3D; a[k];</span><br><span class="line">				a[k] ^&#x3D; a[i];</span><br><span class="line">				a[i] ^&#x3D; a[k];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序</strong></p>
<p>思路：先下标为1的开始，若第二个比第一个小，则第二个插入第一个前面，然后若第三个比第二个小，之后在比较第一个。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 0,temp &#x3D; 0;</span><br><span class="line">int a[] &#x3D; &#123;49,38,65,97,76,12,27&#125;; （从小到大）</span><br><span class="line">int len &#x3D; sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">for(i &#x3D; 1;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">		if(a[i] &lt; a[i - 1])</span><br><span class="line">		&#123;</span><br><span class="line">				temp &#x3D; a[i];</span><br><span class="line">	for(j &#x3D; i - 1;j &gt;&#x3D; 0 &amp;&amp; temp &lt; a[j];j--)</span><br><span class="line">			&#123;</span><br><span class="line">				a[j + 1] &#x3D; a[j];	</span><br><span class="line">			&#125;</span><br><span class="line">	a[j + 1] &#x3D; temp;&#x2F;&#x2F;循环j—的补偿 j+1</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序(插入排序的改进)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[] &#x3D; &#123;9,1,2,5,7,4,8,6,3,5&#125;;</span><br><span class="line">int i &#x3D; 0,j &#x3D; 0,k &#x3D; 0,temp &#x3D; 0;</span><br><span class="line">int len &#x3D; sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">for(k &#x3D; len &#x2F; 2;k &gt;&#x3D; 1;k &#x3D; k &#x2F; 2) &#x2F;&#x2F;分成的组数</span><br><span class="line">&#123;</span><br><span class="line">for(i &#x3D; k;i &lt; len;i++ )&#x2F;&#x2F;插入排序的次数  </span><br><span class="line">		&#123;		</span><br><span class="line">	temp &#x3D; a[i];</span><br><span class="line">for(j &#x3D; i - k;j &gt;&#x3D;0 &amp;&amp; a[j] &gt; temp ;j &#x3D; j - k)</span><br><span class="line">		&#123;												&#x2F;&#x2F;每组元素相隔k个</span><br><span class="line">		a[j + k] &#x3D; a[j];</span><br><span class="line">&#125;</span><br><span class="line">		a[j + k] &#x3D; temp;&#x2F;&#x2F;不换也要补偿 j-k</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序</strong></p>
<p>(1)先从数组中选取一个数作为基准数，用key来表示。（通常选取数组的第一个元素）<br>(2)开始分的过程，一般是定义两个变量i和j，分别表示 i j 判断是否停止。<br>(3)重复第二个步骤，知道每个区间只剩一个数为止（递归的思想）</p>
<p>初始先从后面往前面扫，( 在后面找前面找比它大的，在前面后面找比它小的)<br>19，15，12，18，21，36，45，10<br>一趟快速排序<br>19，15，12，18，21，36，45，10<br>10，15，12，18，21，36，45，19<br>10，15，12，18，19，36，45，21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void quick_sort(int a[],int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">		int i &#x3D; 0,j &#x3D; 0,key &#x3D; 0;</span><br><span class="line">		i &#x3D; low;</span><br><span class="line">		j &#x3D; high;</span><br><span class="line">		key &#x3D; a[low];</span><br><span class="line">		while(i &lt; j)&#x2F;&#x2F;i j相同跳出</span><br><span class="line">		&#123;</span><br><span class="line">				&#x2F;&#x2F;从j开始，找到比key小的</span><br><span class="line">				&#x2F;&#x2F;放到i的位置</span><br><span class="line">				while(i &lt; j &amp;&amp; a[j] &gt;&#x3D; key)	</span><br><span class="line">						j--;</span><br><span class="line">				if(i &lt; j)</span><br><span class="line">				&#123;</span><br><span class="line">						a[i] &#x3D; a[j];	</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;从i开始,找到比key大的位置</span><br><span class="line">				&#x2F;&#x2F;放到j的位置</span><br><span class="line">				while(i &lt; j &amp;&amp; a[i] &lt;&#x3D; key)</span><br><span class="line">					i++;</span><br><span class="line">					</span><br><span class="line">				if(i &lt; j)</span><br><span class="line">				&#123;</span><br><span class="line">						a[j] &#x3D; a[i];	</span><br><span class="line">				&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;循环结束后，a[i]的值没有变，</span><br><span class="line">		&#x2F;&#x2F;把key值放入</span><br><span class="line">		a[i] &#x3D; key;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;若是我们没有遍历到第一个元素的下标</span><br><span class="line">		if(j - 1 &gt;low)</span><br><span class="line">		&#123;</span><br><span class="line">				&#x2F;&#x2F;继续遍历,区间为[0,i-1]</span><br><span class="line">				quick_sort(a,low,i - 1);	</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;若是我们没有遍历到最后一个元素的下标</span><br><span class="line">		if(j - 1 &gt;low)</span><br><span class="line">		&#123;</span><br><span class="line">				&#x2F;&#x2F;继续遍历,区间为[i + 1,high]</span><br><span class="line">				quick_sort(a,i + 1,high);	</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int i ;</span><br><span class="line">int a[] &#x3D; &#123;12,12,3,100,23,56,8,45&#125;;</span><br><span class="line">int low &#x3D; 0; &#x2F;&#x2F;第一个元素的下标</span><br><span class="line">int high &#x3D; sizeof(a)&#x2F;sizeof(a[0]) - 1;</span><br><span class="line">quick_sort(a,low,high);</span><br><span class="line"></span><br><span class="line">for ( i&#x3D; 0;i&lt;high;i++)</span><br><span class="line">printf(&quot;%d\t&quot;,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>归并排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void merge(int a[], int start, int mid, int end)</span><br><span class="line">&#123;</span><br><span class="line">	int *tmp &#x3D; (int *)malloc((end-start+1)*sizeof(int));    </span><br><span class="line">    &#x2F;&#x2F; tmp是汇总2个有序区的临时区域</span><br><span class="line">    int i &#x3D; start;           </span><br><span class="line">    &#x2F;&#x2F; 第1个有序区的索引</span><br><span class="line">    int j &#x3D; mid + 1;       </span><br><span class="line">    &#x2F;&#x2F; 第2个有序区的索引</span><br><span class="line">    int k &#x3D; 0;              </span><br><span class="line">    &#x2F;&#x2F; 临时区域的索引</span><br><span class="line">    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i] &lt;&#x3D; a[j])</span><br><span class="line">            tmp[k++] &#x3D; a[i++];</span><br><span class="line">        else</span><br><span class="line">            tmp[k++] &#x3D; a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;&#x3D; mid)  &#x2F;&#x2F;多出一个</span><br><span class="line">        tmp[k++] &#x3D; a[i++];</span><br><span class="line">    while(j &lt;&#x3D; end)</span><br><span class="line">        tmp[k++] &#x3D; a[j++];</span><br><span class="line">    &#x2F;&#x2F; 将排序后的元素，全部都整合到数组a中。</span><br><span class="line">    for (i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">        a[start + i] &#x3D; tmp[i];</span><br><span class="line">    free(tmp);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[11] &#x3D; &#123;-1, 2, 4, -12, 4, 0, 0, 12, 23, -4, 7000&#125;;</span><br><span class="line">    merge_sort(arr, 0, 10);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 11; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基数排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">个位数排序-》》》十位数排序--》》。。。</span><br><span class="line">所以先求出位数</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int maxbit(int data[], int n) &#x2F;&#x2F;辅助函数，求数据的最大位数</span><br><span class="line">&#123;</span><br><span class="line">    int d &#x3D; 1; &#x2F;&#x2F;保存最大的位数</span><br><span class="line">    int p &#x3D; 10;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">        while(data[i] &gt;&#x3D; p) &#123;</span><br><span class="line">            p *&#x3D; 10;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line">void radixsort(int data[], int n)   &#x2F;&#x2F;基数排序</span><br><span class="line">&#123;</span><br><span class="line">    int d &#x3D; maxbit(data, n);   &#x2F;&#x2F;数组中的元素的最大位数</span><br><span class="line">    int *tmp &#x3D; (int *)malloc(n * sizeof(int));</span><br><span class="line">    int *count &#x3D; (int *)malloc(10 * sizeof(int));   &#x2F;&#x2F;计数器</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int radix &#x3D; 1;</span><br><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; d; i++) &#123;  &#x2F;&#x2F;进行d次排序</span><br><span class="line"></span><br><span class="line">        for(j &#x3D; 0; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; 0;    &#x2F;&#x2F;每次分配前清空计数器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10;   &#x2F;&#x2F;计算每次循环某一位的数字</span><br><span class="line">            count[k]++;    &#x2F;&#x2F;统计每个桶中的记录数</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; 1; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; count[j - 1] + count[j]; &#x2F;&#x2F;第j个桶以及之前所有桶中元素的总数，算出总数后面tmp可以节省空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#123;   &#x2F;&#x2F;将所有桶中记录依次收集到tmp中</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10;</span><br><span class="line">            tmp[count[k] - 1] &#x3D; data[j]; &#x2F;&#x2F;从后面的高位数开始存储</span><br><span class="line">            count[k]--;					&#x2F;&#x2F;个数减一</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++)   &#x2F;&#x2F;将临时数组的内容复制到data中</span><br><span class="line">            data[j] &#x3D; tmp[j];</span><br><span class="line">        radix &#x3D; radix * 10;</span><br><span class="line"></span><br><span class="line">   	 &#125;</span><br><span class="line">   	 free(tmp);</span><br><span class="line">   	 free(count);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] &#x3D; &#123;288, 52, 123, 30, 212, 23, 10, 233&#125;;</span><br><span class="line">    int n,k;</span><br><span class="line">    n &#x3D; sizeof(a) &#x2F; sizeof(a[0]);</span><br><span class="line">    radixsort(a, n);</span><br><span class="line">    for(k &#x3D; 0; k &lt; n; k++)</span><br><span class="line">        printf(&quot;%d &quot;, a[k]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>堆排序（树的层序遍历，大顶堆，小顶堆之分–选择排序）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标为0的位置不存储元素，从下标为1的位置开始存储元素，我们可以很方便地找到父节点。</span><br><span class="line">递归的方式</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    int temp &#x3D; *b;</span><br><span class="line">    *b &#x3D; *a;</span><br><span class="line">    *a &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">    &#x2F;&#x2F; 建立</span><br><span class="line">    int dad &#x3D; start;</span><br><span class="line">    int son &#x3D; dad * 2 + 1;</span><br><span class="line">    while (son &lt;&#x3D; end) &#123; &#x2F;&#x2F; 限制范围</span><br><span class="line">        if (son + 1 &lt;&#x3D; end &amp;&amp; arr[son] &lt; arr[son + 1]) </span><br><span class="line">            son++;</span><br><span class="line">        if (arr[dad] &gt; arr[son]) &#x2F;&#x2F;符合父节点大于子节点</span><br><span class="line">            return;</span><br><span class="line">        else &#123; &#x2F;&#x2F; 交换   父结点和子节点中最大的交换</span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);  </span><br><span class="line">            dad &#x3D; son;      &#x2F;&#x2F;下沉操作</span><br><span class="line">            son &#x3D; dad * 2 + 1;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    &#x2F;&#x2F; 初始化，初始排序，把最值放到堆顶</span><br><span class="line">    for (i &#x3D; len &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">        max_heapify(arr, i, len - 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 总是将第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span><br><span class="line">    for (i &#x3D; len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">      swap(&amp;arr[0], &amp;arr[i]);  &#x2F;&#x2F;把顶点放ar[i]</span><br><span class="line">        max_heapify(arr, 0, i - 1);  &#x2F;&#x2F;重新排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化层序遍历  多个0有父子结点关系</span><br><span class="line">    int arr[] &#x3D; &#123;0,91,88,42,23,24,16,5,13&#125;;</span><br><span class="line">   </span><br><span class="line">    int len &#x3D; (int) sizeof(arr) &#x2F; sizeof(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a[ ] &#x3D; &#123;-1,50,10,90,30,70,40,80,60,20&#125;;</span><br><span class="line">int len &#x3D; sizeof(a) &#x2F; sizeof(a[0]) – 1;</span><br><span class="line">&#x2F;&#x2F;把a[i]这个结点和其两个子节点比较，把最大的值赋值给父节点</span><br></pre></td></tr></table></figure>

<p><strong>拓扑排序(判断有环)</strong></p>
<p>从图中选择一个 没有前驱（即入度为0）的顶点并输出。<br>从图中删除该顶点和所有以它为起点的有向边。</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E5%9B%BE/</url>
    <content><![CDATA[<p>—————&gt;图概念<br>无向图（v,w）<br>互为邻接点，端点</p>
<p>有向图 &lt;v,w&gt;<br>v邻接到w，起始端点v 终止端点w</p>
<p>简单图：没有重边和自回路的图</p>
<p>无向完全图<br>|V|=n<br>|E|=n(n-1)/2</p>
<p>有向完全图(相反弧线)<br>|V|=n<br>|E|=n(n-1)</p>
<p>度、入度、出度<br>度=入度+出度</p>
<p>网络：具有权值</p>
<p>路径大小<br>无向图：边的个数<br>有向图：权值之和</p>
<p>连通图和连通分量<br>强连通分量和非强连通分量<br>—————&gt;图的存储</p>
<p>邻接矩阵<br>有关系1（边和弧存在）</p>
<p>邻接表=顶点表结点和边表结点</p>
<p>无向图：算终点<br>有向图：只算射入</p>
<p>—————&gt;深度优先遍历、广度优先遍历</p>
<p>深度优先遍历（最深处后退、不唯一）<br>广度优先遍历（层序、不唯一）</p>
<img src="/Data-Structure-and-Algorithms-Lover/%E5%9B%BE/%E5%9B%BE.png" class="">


<p>—————&gt;图的生成树概念</p>
<p>G=(V,E)无向联通图</p>
<p>1、生成树加上任意一边生成回路<br>2、生成树加上任意减一边不联通<br>3、不唯一</p>
<p>—————&gt;权值，可抽象为边的数值之和</p>
<p>权值最小为最小生成树</p>
<p>—————&gt;求解方法：贪心算法<br>Kruskal 算法 ：把森林看出树</p>
<p>排序，从权值小的连线，不形成回路就行 O(log2|E|)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct edgedata</span><br><span class="line">&#123;</span><br><span class="line">	int beg,en ;&#x2F;&#x2F;两个顶点序号</span><br><span class="line">  int len ;&#x2F;&#x2F;权值</span><br><span class="line">&#125;edge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edges表</span><br><span class="line">----------------------------------</span><br><span class="line">	beg	|</span><br><span class="line">----------------------------------</span><br><span class="line">	en	|</span><br><span class="line">----------------------------------</span><br><span class="line">	len |</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure>
<p>Prim算法:让一课小树慢慢长大，树的延生法</p>
<p>任选一顶点，选取权值最小连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct edgedata</span><br><span class="line">&#123;</span><br><span class="line">	int beg,en ;&#x2F;&#x2F;两个顶点序号</span><br><span class="line">   int cost ;&#x2F;&#x2F;最短权值</span><br><span class="line">&#125;edge</span><br></pre></td></tr></table></figure>

<p>1.Dijkstra算法是计算图中的一个点到其它点的最小路径.</p>
<p>2.Floyd算法计算图中任意一对点的最短路径.</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随记命令（2）</title>
    <url>/Linux-Lover/Linux%E9%9A%8F%E6%9C%BA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常用 proc 中的文件介绍<br>proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。常<br>/proc/cpuinfo - CPU 的信息 (型号, 家族, 缓存大小等)<br>/proc/meminfo - 物理内存、交换空间等的信息<br>/proc/mounts - 已加载的文件系统的列表<br>/proc/devices - 可用设备的列表<br>/proc/filesystems - 被支持的文件系统<br>/proc/modules - 已加载的模块<br>/proc/version - 内核版本<br>/proc/cmdline - 系统启动时输入的内核命令行参数<br>/proc/interrupts- 每个 IRQ 相关的中断号列表</p>
<p>sys 文件系统本质上和 proc 文件系统是一样的，都是虚拟文件系统，都在根目录下有个目录（一个是/proc 目录，另一个是/sys 目录），因此都不是硬盘中的文件，都是内核中的数据结构的可视化接口。<br>不同的是/proc 中的文件只能读，但是/sys 中的文件可以读写。读/sys 中的文件就是获取内核中数据结构的值</p>
<p>读取分析笔记<br>cat /proc/bus/input/devices</p>
<p>I: Bus=0019 Vendor=0001 Product=0001 Version=0100<br>N: Name=”gpio-keys”<br>P: Phys=gpio-keys/input0<br>S: Sysfs=/devices/platform/gpio-keys/input/input5<br>U: Uniq=<br>H: Handlers=kbd event4<br>B: PROP=0<br>B: EV=100003<br>B: KEY=10000000<br>I:总线类型 与厂商相关ID 与产品相关ID 版本ID</p>
<p>N：设备名称</p>
<p>P：系统层次结构中设备的物理路径</p>
<p>S：位于sys文件系统的路径</p>
<p>U：设备的唯一标识码</p>
<p>H：与设备关联的输入句柄列表。</p>
<p>B：<br>PROP:设备属性<br>EV:设备支持的事件类型<br>KEY:此设备具有的键/按钮<br>MSC:设备支持的其他事件<br>LED:设备上的指示灯</p>
<p>设备上报<br>核心层<br>事件上报</p>
<p>注意：要在管理员权限下调用！</p>
<p>shutdown -h now 立刻关机<br>-h  halt<br>shutdown -r now 系统立刻重启<br>-r  reboot<br>shutdown调用sync，内存写入硬盘</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程小记——多线程</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>线程的使用场景<br>1、程序在拷贝文件，解决计算刷新进度问题<br>2、用阻塞方式去读取数据，串口数据传输或者网络数据传输，解决发送数据问题</p>
<p>名为tid，其本质是一个pthread_t类型的变量</p>
<p>获取线程号<br>pthread_t pthread_self(void);</p>
<p>创建线程不传参<br>pthread_t tid1;<br>int ret = pthread_create(&amp;tid1,NULL,fun,NULL);</p>
<p>传一个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *fun1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s:arg &#x3D; %d Addr &#x3D; %p\n&quot;,__FUNCTION__,*(int *)arg,arg);</span><br><span class="line">&#125;</span><br><span class="line">int ret &#x3D; pthread_create(&amp;tid1,NULL,fun1,(void *)&amp;a);</span><br></pre></td></tr></table></figure>
<p>传多个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MyStruct1</span><br><span class="line">&#123;</span><br><span class="line">    int Id;</span><br><span class="line">    char Name[32];</span><br><span class="line">    float Mark;</span><br><span class="line">&#125;;</span><br><span class="line">void *fun1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">        struct MyStruct1 *tmp &#x3D; (struct MyStruct1 *)arg;</span><br><span class="line">       </span><br><span class="line">  printf(&quot;%s:Id &#x3D; %d Name &#x3D; %s Mark &#x3D; %.2f\n&quot;,</span><br><span class="line">            __FUNCTION__,tmp-&gt;Id,tmp-&gt;Name,tmp-&gt;Mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程的退出与回收</p>
<p>线程的退出情况有三种：<br>第一种是进程结束，进程中所有的线程也会随之结束。<br>第二种是通过函数pthread_exit()来主动的退出线程返回参数。<br>第三种通过函数pthread_cancel被其他线程被动结束。</p>
<p>临界资源访问pthread_mutex_t</p>
<p>初始化<br>int pthread_mutex_init(phtread_mutex_t *mutex,<br>            const pthread_mutexattr_t *restrict attr);</p>
<p>互斥锁（阻塞）<br>int pthread_mutex_lock(pthread_mutex_t *mutex);<br>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<p>互斥锁加锁（非阻塞）<br> int pthread_mutex_trylock(pthread_mutex_t *mutex);<br>互斥锁销毁<br> int pthread_mutex_destory(pthread_mutex_t *mutex);</p>
<p>顺序控制</p>
<p>初始化信号量<br>int sem_init(sem_t *sem,int pshared,unsigned int value);<br>int sem_wait(sem_t *sem);<br>int sem_post(sem_t *sem);<br>int sem_trywait(sem_t *sem);<br>int sem_destory(sem_t *sem);</p>
<p> 举例<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #define _GNU_SOURCE </span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">sem_t sem1,sem2,sem3;</span><br><span class="line">void *fun1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_wait(&amp;sem1);</span><br><span class="line">	printf(&quot;%s:Pthread Come!\n&quot;,__FUNCTION__);</span><br><span class="line">	sem_post(&amp;sem2);</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *fun2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_wait(&amp;sem2);</span><br><span class="line">	printf(&quot;%s:Pthread Come!\n&quot;,__FUNCTION__);</span><br><span class="line">	sem_post(&amp;sem3);</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *fun3(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_wait(&amp;sem3);</span><br><span class="line">	printf(&quot;%s:Pthread Come!\n&quot;,__FUNCTION__);</span><br><span class="line">	sem_post(&amp;sem1);</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	pthread_t tid1,tid2,tid3;</span><br><span class="line">	ret &#x3D; sem_init(&amp;sem1,0,1);  &#x2F;&#x2F;初始化信号量1 并且赋予其资源 </span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		perror(&quot;sem_init&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret &#x3D; sem_init(&amp;sem2,0,0); &#x2F;&#x2F;初始化信号量2 让其阻塞  0</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		perror(&quot;sem_init&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret &#x3D; sem_init(&amp;sem3,0,0); &#x2F;&#x2F;初始化信号3 让其阻塞   0</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		perror(&quot;sem_init&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret &#x3D; pthread_create(&amp;tid1,NULL,fun1,NULL);&#x2F;&#x2F;创建线程1</span><br><span class="line">	if(ret !&#x3D; 0)&#123;</span><br><span class="line">		perror(&quot;pthread_create&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret &#x3D; pthread_create(&amp;tid2,NULL,fun2,NULL);&#x2F;&#x2F;创建线程2</span><br><span class="line">	if(ret !&#x3D; 0)&#123;</span><br><span class="line">		perror(&quot;pthread_create&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret &#x3D; pthread_create(&amp;tid3,NULL,fun3,NULL);&#x2F;&#x2F;创建线程3</span><br><span class="line">	if(ret !&#x3D; 0)&#123;</span><br><span class="line">		perror(&quot;pthread_create&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pthread_join(tid1,NULL);</span><br><span class="line">	pthread_join(tid2,NULL);</span><br><span class="line">	pthread_join(tid3,NULL);</span><br><span class="line"></span><br><span class="line">	sem_destroy(&amp;sem1);</span><br><span class="line">	sem_destroy(&amp;sem2);</span><br><span class="line">	sem_destroy(&amp;sem3);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程小记——IPC</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94IPC/</url>
    <content><![CDATA[<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建或打开共享内存</span><br><span class="line">2.映射共享内存</span><br><span class="line">3.读写共享内存</span><br><span class="line">4.撤销共享内存映射</span><br><span class="line">5.删除共享内存对象</span><br></pre></td></tr></table></figure>

<h5 id="调用ftok生成key值"><a href="#调用ftok生成key值" class="headerlink" title="调用ftok生成key值"></a>调用ftok生成key值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key &#x3D; ftok(&quot;.&#x2F;a.c&quot;,&#39;b&#39;);</span><br></pre></td></tr></table></figure>
<h5 id="调用shmat将共享内存映射到用户空间"><a href="#调用shmat将共享内存映射到用户空间" class="headerlink" title="调用shmat将共享内存映射到用户空间"></a>调用shmat将共享内存映射到用户空间</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; (char *)shmat(shmid, NULL, 0);</span><br><span class="line">    if (p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">       printf(&quot;shmat fail\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;shmat sucess\n&quot;);</span><br><span class="line">&#x2F;&#x2F;等待console输入，然后向共享内存写入数据</span><br><span class="line">fgets(p, 128, stdin);</span><br><span class="line">printf(&quot;share memory data:%s\n&quot;, p);</span><br></pre></td></tr></table></figure>


<h5 id="调用shmdt解除地址映射"><a href="#调用shmdt解除地址映射" class="headerlink" title="调用shmdt解除地址映射"></a>调用shmdt解除地址映射</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shmdt(p);</span><br><span class="line">&#x2F;&#x2F;段错误 (核心已转储)</span><br></pre></td></tr></table></figure>
<h5 id="调用shmctl函数删除内核中的共享内存"><a href="#调用shmctl函数删除内核中的共享内存" class="headerlink" title="调用shmctl函数删除内核中的共享内存"></a>调用shmctl函数删除内核中的共享内存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line">&#x2F;&#x2F; IPC_RMID (删除对象属性)</span><br></pre></td></tr></table></figure>

<h5 id="调用shmctl函数删除内核中的共享内存-1"><a href="#调用shmctl函数删除内核中的共享内存-1" class="headerlink" title="调用shmctl函数删除内核中的共享内存"></a>调用shmctl函数删除内核中的共享内存</h5><p> 共享内存局限性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、数量是有限制的，通过ipcs -l命令查看可以通过</span><br><span class="line">ubuntu$:cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmmax来查看 </span><br><span class="line">ubuntu$:18446744073692774399</span><br><span class="line">2、所有进程调用shmdt之后才会删除共享内存。</span><br></pre></td></tr></table></figure>

<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>ipcs -q<br>——— 消息队列 ———–<br>键        msqid      拥有者  权限     已用字节数 消息      </p>
<p>cat/proc/sys/kernel/msgmax查看最大<br>8192<br>链式队列,消息队列<br>(1)生命周期跟随内核<br>(2)可以实现双向通信<br>(3)克服了管道只能承载无格式字节流的缺点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建或者打开消息队列的函数</span><br><span class="line">int msgget(key_t key, int flag)</span><br><span class="line"></span><br><span class="line">消息队列控制函数</span><br><span class="line">int msgctl(int msgqid, int cmd, struct msqid_ds *buf)</span><br><span class="line"></span><br><span class="line">把一条消息添加到消息队列中</span><br><span class="line"> int msgsnd(int msgqid, const void *msgp, size_t size, int flag)</span><br><span class="line"> </span><br><span class="line">例子：   </span><br><span class="line">msgsnd(msgid，(void*)&amp;sendbuf,strlen(sendbuf.voltage),0);</span><br><span class="line"> </span><br><span class="line">从一个消息队列接受消息</span><br><span class="line"> int msgrcv(int msgqid, void *msgp, size_t size, long msgtype, int flag)</span><br><span class="line"> 例子：</span><br><span class="line">  msgrcv(msgid,(void *)&amp;readbuf, 124, 100, 0 ) ;</span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>semget函数 创建或者打开函数</p>
<p>semctl函数  信号量灯控制函数</p>
<p>semop函数   p/v操作函数</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式试题自测——20200711</title>
    <url>/C-C-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AF%95%E9%A2%98%E8%87%AA%E6%B5%8B%E2%80%94%E2%80%9420200711-1/</url>
    <content><![CDATA[<p>1、一棵二叉树有8个度为2的节点，5个度为1的节点，那么度为0的节点个数为?<br>结点总数=度数+1<br>k+1=2*n2+n1;<br>k=n2+n1+n0;<br>n0=n2+1</p>
<p>2、echo hello 1&gt;&amp;2 |grep aaa<br>echo hello 2&gt;&amp;1 |grep aaa<br>管道命令右边只处理左边的标准正确输出，也就是通道1<br>第一个输出hello， 第二个无输出</p>
<p>3、*p++ == *(p++)<br>!y–&amp;&amp;!x–  ==  先判断！，</p>
<p>4、虚拟存储的主要技术是部分对换。允许作业装入的时候只装入一部分，另一部分放在磁盘 上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业</p>
<p>5、操作系统的功能： 进程与处理机管理、作业管理、存储管理、设备管理、文件管理。对应即可 编译器是在操作系统之上的，由编译器完成程序的编译</p>
<p>6、最先适应算法：依次判定后找到第一个满足要求的<br>最佳适应算法：对空闲区按从小到大排序，第一个满足的就是<br>最差适应算法：对空闲区按从大到小排序，第一个满足的就是<br>固定式分区算法：是分区的</p>
<p>7、<br>单链表：尾插入O(n),尾删O(n)<br>仅有头的单循环链表：尾插入O(n),尾删O(n)<br>双向链表：尾插入O(n),尾删O(n)<br>仅有尾指针的单循环链表：尾插入O(1),尾删O(n)</p>
<p>8、字符串匹配，分主串和模式串<br>BF算法的缺点很明显，效率实在太低了，每一轮只能老老实实地把模式串右移一位。<br>BM算法解决了这一问题。它借助“坏字符规则”和“好后缀规则”，在每一轮比较时，让模式串尽可能多移动几位，减少无谓的比较。<br>KMP算法：next数组，前缀和后缀<br>左移，next[0]= -1 ,整体+1；</p>
<p>9、由权值为9,2,7,5的四个叶子节点构造一棵哈夫曼树，该树的带权路径长度为：</p>
<img src="/C-C-Lover/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AF%95%E9%A2%98%E8%87%AA%E6%B5%8B%E2%80%94%E2%80%9420200711-1/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" class="">


<p>10、已知如下代码，并在两个线程中同时执行f1和f2，待两个函数都返回后，a的所有可能值是哪些？<br>int a = 2, b = 0, c = 0<br>void f1()<br>{<br>    b = a * 2;<br>    a = b;<br>}<br>void f2()<br>{<br>    c = a + 11;<br>    a = c;<br>}</p>
<p>解决：1122、2211、1212、2121.</p>
<p>11、链表和数组说法正确的是（）<br>数组从栈中分配空间，链表从堆中分配空间<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n）</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概念小计</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h4><p>数据结构= 数据对象+数据关系<br>数据类型= 数据结构+数据操作<br>​</p>
<h4 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h4><p>顺序存储= 数组的使用<br>线性存储= 结构struct使用<br>​</p>
<h4 id="时间度量和空间度量"><a href="#时间度量和空间度量" class="headerlink" title="时间度量和空间度量"></a>时间度量和空间度量</h4><p>时间度量：看步数，当式子n趋于无穷大的，大O表示法O(1)O(n)O(n)  评估效率<br>空间度量：看存储字节的大小</p>
<p>（1）空间换时间：就是多占用内存，加但减少了遍历链表所用的时间，执行速度较快。<br>（2）时间换空间：反过来。<br>举例：来源网络<br>方法A：通常的办法<br>#define LEN 32<br>char string1 [LEN];<br>memset (string1,0,LEN);<br>strcpy (string1,”This is a example!!”);<br>方法B：<br>const char string2[LEN] =”This is a example!”;<br>char * cp;<br>cp = string2;</p>
<h4 id="入栈顺序，出栈顺序的可能？"><a href="#入栈顺序，出栈顺序的可能？" class="headerlink" title="入栈顺序，出栈顺序的可能？"></a>入栈顺序，出栈顺序的可能？</h4><p>入栈顺序：ABCDE<br>例如D先出栈，则D**** ,后面A、B、C的出栈顺序一定为C、B、A</p>
<h4 id="栈和队列的混合"><a href="#栈和队列的混合" class="headerlink" title="栈和队列的混合"></a>栈和队列的混合</h4><p>设栈S和队列Q的初始状态皆为空，字符序列A，B，C，D，E，F依次通过一个栈，元素出栈后立即进入队列Q，若6个元素出队列的顺序是C，E，D，F，B，A，则栈S应至少容纳（4）个元素</p>
<img src="/Data-Structure-and-Algorithms-Lover/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E5%B0%8F%E8%AE%A1/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.png" class="">


<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>树对应的二叉树<br>前序—前序<br>后序—中序</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻应变拉力传感器设计</title>
    <url>/Mechanic-Lover/%E5%BA%94%E5%8F%98%E6%8B%89%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<img src="/Mechanic-Lover/%E5%BA%94%E5%8F%98%E6%8B%89%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%BE%E8%AE%A1/%E7%94%B5%E9%98%BB%E5%BA%94%E5%8F%98%E6%8B%89%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%BE%E8%AE%A1.jpg" class="">

<img src="/Mechanic-Lover/%E5%BA%94%E5%8F%98%E6%8B%89%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%BE%E8%AE%A1/%E7%94%B5%E9%98%BB%E5%BA%94%E5%8F%98%E6%8B%89%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%BE%E8%AE%A12.jpg" class="">}]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull+Debian文件系统</title>
    <url>/Linux-Lover/imx6ull-Debian%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h6 id="Debian文件系统下载"><a href="#Debian文件系统下载" class="headerlink" title="Debian文件系统下载"></a>Debian文件系统下载</h6><p><a href="https://releases.linaro.org/debian/images/alip-armhf/" target="_blank" rel="noopener">https://releases.linaro.org/debian/images/alip-armhf/</a></p>
<h6 id="脚本固化系统"><a href="#脚本固化系统" class="headerlink" title="脚本固化系统"></a>脚本固化系统</h6><p>先烧写出厂的系统到一张 SD 卡上<br>sudo ./imx6mksdboot.sh -device /dev/sdb -flash emmc -ddrsize 512</p>
<p>SD卡中<br>/dev/sdb1         64511     6807    57704   11% /media/ming/boot<br>/dev/sdb2       3680336   487840  2985828   15% /media/ming/rootfs</p>
<h5 id="文件系统解压"><a href="#文件系统解压" class="headerlink" title="文件系统解压"></a>文件系统解压</h5><p>sudo tar zxf linaro-jessie-alip-20161117-32.tar.gz</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>先删除出厂的根文件系统<br>sudo rm -rf /media/ming/rootfs/*</p>
<p>把 binary 下面的所有内容移到<br>sudo mv * /media/ming/rootfs/<br>sync</p>
<h5 id="启动-Debian文件系统"><a href="#启动-Debian文件系统" class="headerlink" title="启动 Debian文件系统"></a>启动 Debian文件系统</h5><p>SD卡启动方式，无网络提醒忽略即可。<br>启动可能有点慢QAQ</p>
<h5 id="移植-Debian-之后"><a href="#移植-Debian-之后" class="headerlink" title="移植 Debian 之后"></a>移植 Debian 之后</h5><p>1、更新软件源<br>清华大学开源镜像站的 debian 镜像源<br>vi /etc/apt/sources.list<br>先删除原来的内容，再添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian jessie main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian jessie main contrib non-free</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian jessie-updates main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian jessie-updates main contrib non-free</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian-security jessie&#x2F;updates main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;debian-security jessie&#x2F;updates main contrib non-free</span><br></pre></td></tr></table></figure>
<p>插上网线，确保能上网！<br> apt-get update</p>
<p>2、 安装常用的软件</p>
<p>smplayer（视频播放器）<br>viewnior（图片浏览器）<br>audacious（音频播放器）</p>
<p>apt-get install smplayer viewnior audacious</p>
<p>3、配置音频<br>参考：正点原子<br>git clone <a href="https://github.com/dzm2018/audio-Settings.git">https://github.com/dzm2018/audio-Settings.git</a></p>
<p> asound.conf 和 asound.state 这 两个 文 件<br>cp asound.conf /etc/<br>cp asound.state /var/lib/alsa/<br>sync<br>reboot 重启</p>
<p>4、配置 mplayer</p>
<p>声音与画面不同步<br>mkdir /home/linaro/.mplayer/<br>vi /home/linaro/.mplayer/config<br>在/home/linaro/.mplayer/config 添加以下内容<br>framedrop=yes<br>5、测试 视频播放<br>性能的原因： 800*480 的分辨率，建议您转化成 480p</p>
<h5 id="ARM-远程FTP"><a href="#ARM-远程FTP" class="headerlink" title="ARM 远程FTP"></a>ARM 远程FTP</h5><p>ar -vxzf vsftpd-3.0.3.tar.gz  //解压缩<br>CC = arm-linux-gnueabihf-gcc  //CC 为交叉编译器<br>make  //编译 vsftpd</p>
<p>会得到两个文件：vsftpd 和 vsftpd.conf，我们需要这两个文件。<br>将 vsftpd 拷贝到开发板根文件系统下的/usr/sbin/ 目录下<br>sudo cp vsftpd /media/ming/rootfs/usr/sbin/</p>
<p>将 vsftpd.conf 拷贝到开发板根文件系统的/etc/ 目录下<br>sudo cp vsftpd.conf /media/ming/rootfs/etc/</p>
<p>拷贝完成以后给予 vsftpd 可执行权限，并且修改 vsfptd.conf 所属用户为 root，命令如下：<br>chmod +x /usr/sbin/vsftpd<br>sudo chown root:root /etc/vsftpd.conf</p>
<p>连接前启动<br>vsftpd &amp;</p>
<h6 id="踩坑QAQ"><a href="#踩坑QAQ" class="headerlink" title="踩坑QAQ"></a>踩坑QAQ</h6><p>smplayer 有画面没声音？<br>一开始以为打开pulseAudio volume Control设置就行。。。<br>第一次使用声卡之前一定要先使用 amixer 设置声卡，打开耳机和喇叭，并且设置喇叭和耳机音量，串口输入如下命令：<br>amixer sset Headphone 100,100<br>amixer sset Speaker 120,120<br>amixer sset ‘Right Output Mixer PCM’ on<br>amixer sset ‘Left Output Mixer PCM’ on<br>然后就有声音了。。QAQ</p>
<h5 id="测试视频"><a href="#测试视频" class="headerlink" title="测试视频"></a>测试视频</h5><iframe src="//player.bilibili.com/player.html?aid=243815826&bvid=BV1iv411i7HA&cid=210863550&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"
height = "600" width ="100%"
> </iframe>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-自定义类</title>
    <url>/Linux-Lover/QT-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB/</url>
    <content><![CDATA[<p>1、调用别人写好类，直接添加，提升为Qwidget即可。</p>
<p>例如：做过的调用扇形统计和条形统计图。</p>
<p>2、自己ui右键添加添加设计师界面，提升为Qwidget即可。</p>
<p>3、自己写过的项目想加到主界面里，直接添加，提升为Qwidget即可，但是！！！一定要注意头文件的路径，例如多文件目录下，否则会提示no such file </p>
<p>4、主界面ui调用另一个界面的ui?<br>一般用信号触发就行，不要去修改ui,以免增加代码复杂。QAQ</p>
<p>一、子类ui变为公共+信号传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;子界面</span><br><span class="line">#ifndef FORM_H</span><br><span class="line">#define FORM_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Form;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Form : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Form(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~Form();</span><br><span class="line">    Ui::Form *ui;</span><br><span class="line">  void clickset();</span><br><span class="line">private slots:</span><br><span class="line">    void on_comboBox_activated(const QString &amp;arg1);</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    void backclick(QString str);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; FORM_H</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">#include &quot;form.h&quot;</span><br><span class="line">#include &quot;ui_form.h&quot;</span><br><span class="line"></span><br><span class="line">Form::Form(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Form)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Form::~Form()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Form::on_comboBox_activated(const QString &amp;arg1)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;lineEdit-&gt;setText(&quot;子界面调用&quot;+arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Form::clickset()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ui-&gt;lineEdit-&gt;setText(&quot;主界面调用&quot;);</span><br><span class="line">    emit backclick(&quot;子界面返回信息&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主界面</span><br><span class="line">#ifndef ALLWIDGET_H</span><br><span class="line">#define ALLWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;form.h&quot;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class allWidget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class allWidget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit allWidget(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~allWidget();</span><br><span class="line">Form *form ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    void clicktoform();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_pushButton_clicked();</span><br><span class="line">    void senddata(QString str);</span><br><span class="line">private:</span><br><span class="line">    Ui::allWidget *ui;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; ALLWIDGET_H</span><br><span class="line">#include &quot;allwidget.h&quot;</span><br><span class="line">#include &quot;ui_allwidget.h&quot;</span><br><span class="line">#include &quot;form.h&quot;</span><br><span class="line">#include &quot;ui_form.h&quot;</span><br><span class="line">allWidget::allWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::allWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line">    form &#x3D; new Form(this);</span><br><span class="line">    form-&gt;show();</span><br><span class="line">    connect(this,&amp;allWidget::clicktoform,this-&gt;form,&amp;Form::clickset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    connect(form,SIGNAL(backclick(QString )),this,SLOT(senddata(QString)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allWidget::~allWidget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line">void allWidget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     emit clicktoform();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void allWidget::senddata(QString str)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;textBrowser-&gt;append(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;main.c  main.c也要添加子界面头文件</span><br><span class="line">#include &quot;allwidget.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &quot;form.h&quot;</span><br></pre></td></tr></table></figure>

<p>二、直接在ui界面widget容器 提升为QWidget+信号传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虽然方便更多的用于不用操作主界面和子界面的信息传递，否则操作ui中的控件有点复杂。</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/QT-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB.gif" class="" title="左边子界面ui右边主界面ui">




]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-启动画面QSplashScreen</title>
    <url>/Linux-Lover/QT-%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2QSplashScreen/</url>
    <content><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;welcomewidget.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QSplashScreen&gt;</span><br><span class="line">#include &lt;QRect&gt;</span><br><span class="line">#include &lt;QElapsedTimer&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    WelcomeWidget w;</span><br><span class="line"></span><br><span class="line">    QSplashScreen *splash &#x3D; new QSplashScreen;</span><br><span class="line"></span><br><span class="line">    QPixmap pix(&quot;:&#x2F;resources&#x2F;Welcome_MING.jpg&quot;);</span><br><span class="line"></span><br><span class="line">    splash-&gt;setPixmap(pix);</span><br><span class="line">    splash-&gt;show();</span><br><span class="line">    splash-&gt;setFont(QFont(&quot;microsoft yahei&quot;, 20, QFont::Bold));</span><br><span class="line">    splash-&gt;showMessage(&quot;Linux Lover \n QAQ&quot;, Qt::AlignBottom | Qt::AlignHCenter, Qt::white);</span><br><span class="line">  &#x2F;&#x2F;  splash-&gt;setGeometry(400,300,440,300);</span><br><span class="line">    int delay_time &#x3D; 10;</span><br><span class="line">    QElapsedTimer timer ;</span><br><span class="line">    timer.start();</span><br><span class="line">    while(timer.elapsed() &lt; (delay_time*1000))</span><br><span class="line">    &#123;</span><br><span class="line">        a.processEvents();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    splash-&gt;finish(&amp;w);</span><br><span class="line"></span><br><span class="line">    delete splash;</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><img src="/Linux-Lover/QT-%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2QSplashScreen/start.gif" class="">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT HTTP协议</title>
    <url>/QT-Lover/QT%20HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h5 id="定义了解"><a href="#定义了解" class="headerlink" title="定义了解"></a>定义了解</h5><p>超文本=======超链接（基础）</p>
<p>超文本传输协议（英文：HyperText Transfer Protocol，HTTP是万维网的数据通信的基础。HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p>
<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。<br>HTTP是客户端浏览器或其他程序与 Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator， 统一资源定位符)，浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<img src="/QT-Lover/QT%20HTTP%E5%8D%8F%E8%AE%AE/http.png" class="">

<img src="/QT-Lover/QT%20HTTP%E5%8D%8F%E8%AE%AE/http_1.png" class="">

<img src="/QT-Lover/QT%20HTTP%E5%8D%8F%E8%AE%AE/qt.png" class="">
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ullUDP测试</title>
    <url>/Linux-Lover/imx6ullUDP%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h6><p>  UDP通信没有明确的服务器端和客户端之分<br>　TCP通信像是打电话（必须要接通才能通信），UDP通信像是写信（不管能不能收到都发送出去）<br>　首先需要QUdpSOcket套接字，然后绑定bind()端口号和ip<br>　如果对方发送过来数据，套接字自动触发readyRead()方法<br>　套接字QUdpSOcket通过readDatagram()和writeDatagram()方法读取和写入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include&lt;QHostAddress&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配空间指定父对象</span><br><span class="line">    udpsocket&#x3D;new QUdpSocket (this);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;组播D类地址</span><br><span class="line"> &#x2F;&#x2F;udpsocket-&gt;joinMulticastGroup(QHostAddress(&quot;224.0.0.2&quot;))</span><br><span class="line">&#x2F;&#x2F;广播255.255.255.255</span><br><span class="line">&#x2F;&#x2F;udpsocket-&gt;bind(QHostAddress::AnyIPv4,8888);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">    udpsocket-&gt;bind(QHostAddress::Any,8888);</span><br><span class="line">    this-&gt;setWindowTitle(&quot;服务端8888&quot;);</span><br><span class="line"></span><br><span class="line">    connect(udpsocket,&amp;QUdpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        char buff[1024]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">        QHostAddress cliAddr;</span><br><span class="line">        quint16 port;</span><br><span class="line">        qint64 len&#x3D;udpsocket-&gt;readDatagram(buff,sizeof(buff),&amp;cliAddr,&amp;port);</span><br><span class="line">       &#x2F;&#x2F;接收不大于maxSize字节的数据报并将其存储在数据中。</span><br><span class="line">        &#x2F;&#x2F;发送方的主机地址和端口存储在address和“port”中(除非指针为0)。成功返回数据报的大小;</span><br><span class="line">        if (len&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            QString str&#x3D;QString (&quot;[%1 :%2] %3&quot;).arg(cliAddr.toString()).arg(port).arg(buff);</span><br><span class="line">             this-&gt;textEdit-&gt;setText(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_pushButtontsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString ip&#x3D;this-&gt;lineEditIP-&gt;text();</span><br><span class="line">    quint16 port&#x3D;this-&gt;lineEditPort-&gt;text().toInt();</span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容；</span><br><span class="line">    QString str&#x3D;this-&gt;textEdit-&gt;toPlainText();</span><br><span class="line">    udpsocket-&gt;writeDatagram(str.toUtf8().data(),QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<iframe src="//player.bilibili.com/player.html?aid=796168421&bvid=BV1yC4y187z5&cid=208936840&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%" > </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程小记——文件描述符</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>好记性不如烂笔头 QvQ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*******************************************************************&#x2F;</span><br><span class="line">O_RDONLY &#x2F;&#x2F;只读打开</span><br><span class="line">O_WRONLY &#x2F;&#x2F;只写打开</span><br><span class="line">O_RDWR &#x2F;&#x2F;读、写打开</span><br><span class="line">O_APPEND &#x2F;&#x2F;每次写时都追加到文件的尾端</span><br><span class="line">O_CREAT &#x2F;&#x2F;若此文件不存在，则创建它。使用时，需要第三个参数 mode</span><br><span class="line">O_EXCL &#x2F;&#x2F;如果同时指定了 O_CREAT,而文件已经存在，则会出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件。</span><br><span class="line">O_TRUNC &#x2F;&#x2F;如果此文件存在，而且为只写或读写成功打开，则将其长度截短为 0。</span><br><span class="line">O_NONBLOCK &#x2F;&#x2F;如果 pathname 指的是一个 FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文</span><br><span class="line">件的本次操作和后续的 I&#x2F;O 操作设置非阻塞模式。只用于设备文件，不能用于普通文件。</span><br><span class="line">O_SYNC &#x2F;&#x2F;使每次 write 都等到物理 I&#x2F;O 操作完成，包括由 write 操作引起的文件属性更新所需的</span><br><span class="line">I&#x2F;O。</span><br><span class="line">&#x2F;*******************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fd&#x3D;open(&quot;123.txt&quot;,O_RDWR|O_CREAT);&#x2F;&#x2F;写入一个新的 123.txt 文件</span><br><span class="line"></span><br><span class="line">使用四个数字指定创建文件的权限，与 linux 的权限设置相同，如 ，0755</span><br><span class="line">譬如一般创建一个可读可写不可执行的文件就用 ， 0666</span><br></pre></td></tr></table></figure>
<h5 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lseek(fd, offset, whence(参照物))&#x2F;&#x2F;fd:哪个文件，从 whence 开始，往后偏移 offset 个 </span><br><span class="line">其中，whence 就三个参数 </span><br><span class="line">SEEK_SET 开头 </span><br><span class="line">SEEK_CUR 当前 </span><br><span class="line">SEEK_END 结尾 </span><br><span class="line">(1) 、 将读写位置移到文件开头时</span><br><span class="line">lseek（int fd,0,SEEK_SET）；&#x2F;&#x2F;返回 0</span><br><span class="line">(2) 、 将读写位置移到文件尾时</span><br><span class="line">lseek（int fd，0,SEEK_END）；&#x2F;&#x2F;返回文件长度</span><br><span class="line">(3) 、 想要取得目前文件位置时</span><br><span class="line">lseek（int fd，0,SEEK_CUR）；&#x2F;&#x2F;返回当前文件指针相对于文件开头的偏移量</span><br><span class="line">(4)、用 lseek 测定文件大小的程序</span><br></pre></td></tr></table></figure>

<h5 id="打开文件问题"><a href="#打开文件问题" class="headerlink" title="打开文件问题"></a>打开文件问题</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个进程中 2 个打开同一个文件?</span><br><span class="line">文件会被第二个文件操作覆盖</span><br><span class="line"></span><br><span class="line">只想追加内容？</span><br><span class="line">加 O_APPEND 解决覆盖问题</span><br><span class="line"></span><br><span class="line">O_APPEND 的实现原理和其原子操作性说明</span><br><span class="line">关键的核心的东西是文件指针。分别写的内部原理就是 2 个 fd 拥有不同的文件指针，并且彼此只考虑自己的位移。但是 O_APPEND 标志可以让 write 和 read 函数内部多做一件事情，就是移动自己的文件指针的同时也去把别人的文件指针同时移动。（也就是说即使加了O_APPEND，fd1 和 fd2 还是各自拥有一个独立的文件指针，但是这两个文件指针关联起来了，一个动了会通知另一个跟着动）</span><br></pre></td></tr></table></figure>

<h5 id="文件共享的实现方式"><a href="#文件共享的实现方式" class="headerlink" title="文件共享的实现方式"></a>文件共享的实现方式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件共享的核心：是多个文件描述符指向同一个文件</span><br><span class="line">进程表  文件表  V节点</span><br><span class="line"></span><br><span class="line">因为 fd1 和 fd2 分别指向了两个不同的文件表，所以都拥有自己的文件位移量。开始各自的文件位移量都为 0。但是为什么拥有相同的 v 节点呢，毕竟它们对应的都是同一个文件 file。</span><br><span class="line"></span><br><span class="line">一种情况：同一进程内，多次 open 共享同一文件后</span><br><span class="line"></span><br><span class="line">初始文件位移量也为 0，这就是导致覆盖的原因了。</span><br><span class="line"></span><br><span class="line">第二种情况：两个进程共享同一个文件</span><br><span class="line"></span><br><span class="line">每个描述符都指向了各自独立的文件表，但毕竟共享的是同一个文件，所以他们拥有相同的 V 结点</span><br><span class="line"></span><br><span class="line">第三种情况：使用 dup 实现共享同一文件（只能实现接续写）</span><br><span class="line">dup  函数（文件描述符重定位函数），dup 后的多个文件描述符，直接共享同一个文件表</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.jpg" class="">


<h5 id="总结文件描述符"><a href="#总结文件描述符" class="headerlink" title="总结文件描述符"></a>总结文件描述符</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)文件描述符的本质是一个数字，这个数字本质上是进程表中文件描述符表的一个表项，进程</span><br><span class="line">通过文件描述符作为 index 去索引查表得到文件表指针，再间接访问得到这个文件对应的文件</span><br><span class="line">表。</span><br><span class="line">(2)文件描述符 fd 是系统自动分配的，很少见 fd 为 0、1、2，是因为 0&#x2F;1&#x2F;2 已经默认被系统占用</span><br><span class="line">了。所以 open 的最小的就是 3.</span><br><span class="line">(3)linux 内核占用了 0、1、2 这三个 fd 是有用的，当我们运行一个程序得到一个进程时，内部</span><br><span class="line">就默认已经打开了 3 个文件，这三个文件对应的 fd 就是 0、1、2。这三个文件分别叫 stdin、</span><br><span class="line">stdout、stderr。</span><br><span class="line"></span><br><span class="line">stdin 标准输入，一般对应的是键盘。&#x2F;&#x2F;0 对应的是键盘的设备文件 </span><br><span class="line">stdout 标准输出，printf 的默认输出&#x2F;&#x2F;1 对应的是 LCD 显示器设备文件 </span><br><span class="line">fprintf：可以指定 fd 输出到其他文件中</span><br></pre></td></tr></table></figure>

<h5 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a>文件描述符的复制</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、函数原型和头文件</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br><span class="line">作用：用来复制一个现存的文件描述符，其实就是让多个文件描述符指向同一个文件（不用多次open 实现）</span><br><span class="line">调用成功，返回新复制的文件描述符，失败，返回-1，并且 errno被 设置</span><br><span class="line"></span><br><span class="line">dup2 和 dup 的作用是一样的，都是复制一个新的文件描述符。但是 dup2 允许用户指定新的</span><br><span class="line">文件描述符的数字。</span><br><span class="line"></span><br><span class="line">dup2 函数的第二个参数，用于指定新的描述符，如果这个描述符已经打开了，那就先关闭它，然后再复制，只是这个关闭和复制两个动作是一个原子操作，所以 dup2 就避免了 dup 存在的问题。</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/dup.jpg" class="">





<p>参考：王维鋆的个人博客：<a href="https://blog.csdn.net/wangweijundeqqeqqqq" target="_blank" rel="noopener">https://blog.csdn.net/wangweijundeqqeqqqq</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidworks composer</title>
    <url>/Mechanic-Lover/Solidworks-composer/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toolbox零件更改后装配体中，容易丢失问题</span><br><span class="line">选项&gt;&gt;异型导向&#x2F;toolbox&gt;&gt;TOOLBOX预选地址不要打钩</span><br><span class="line"></span><br><span class="line">***软件应用</span><br><span class="line">技术部门</span><br><span class="line">车间部门</span><br><span class="line">客户服务</span><br><span class="line">市场营销</span><br><span class="line"></span><br><span class="line">.smg     通用3D格式</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">svg 网页 -----需提前下载   svgview</span><br><span class="line">一、基本界面知识</span><br><span class="line">打开文件快捷键    Ctrl+O</span><br><span class="line">*  合并到新文档，统一操作空间</span><br><span class="line">*  首选项设置</span><br><span class="line"></span><br><span class="line">*鼠标中   按住平移     滑动放大缩小</span><br><span class="line">鼠标右键     选择（可更改）</span><br><span class="line"></span><br><span class="line">装配模式      视图效果选择</span><br><span class="line"></span><br><span class="line">视图对齐</span><br><span class="line"></span><br><span class="line">发布（保存格式）     </span><br><span class="line">解冻  协同树画板取消</span><br><span class="line"></span><br><span class="line"> 结构树，协同树——————都在窗口选项  显示隐藏</span><br><span class="line"></span><br><span class="line">混合折线     鼠标左键，右键确定</span><br><span class="line"></span><br><span class="line">光源必须开着</span><br><span class="line"></span><br><span class="line">纹理图应用----工作空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正视于-----正视照相机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、动画操作</span><br><span class="line"></span><br><span class="line">***制作前枢轴坐标对齐</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOM 零件清单、表</span><br><span class="line"></span><br><span class="line">Diger   显示放大镜</span><br><span class="line"></span><br><span class="line">*****svg打不开问题   </span><br><span class="line">http:&#x2F;&#x2F;fans.solidworks.com.cn&#x2F;forum.php?mod&#x3D;viewthread&amp;tid&#x3D;63172</span><br><span class="line">问题解决方法：</span><br><span class="line">找到 “XXX:\Program Files\SOLIDWORKS Corp\SOLIDWORKS Composer\Html”目录下的“SOLIDWORKSSvg.html&quot;这个文件，使用记事本打开，</span><br><span class="line">查找到第7行：    “  &lt;img src&#x3D;&quot;tmp.svg&quot;     把这  &quot;tmp.svg&quot; 改为 &quot;tmp_seemage.svg&quot;，</span><br><span class="line">                    即终代码是      &lt;img src&#x3D;&quot;tmp_seemage.svg&quot;  type&#x3D;&quot;image&#x2F;svg+xml&quot;    ……………………………………</span><br><span class="line">然后保存文件并</span><br><span class="line">********不能另存为的问题</span><br><span class="line"></span><br><span class="line">观看视频造成的，把视频软件关了即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">伸缩-----世界坐标系的比例</span><br><span class="line"></span><br><span class="line">滚动-----花纹的运动</span><br><span class="line"></span><br><span class="line">重影问题--------首页透明度至0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">********一般装配</span><br><span class="line"></span><br><span class="line">拉出，淡出，视图，反转。配上步骤文字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***z中性属性</span><br><span class="line">父子级失败的原因，就是没有对零件进行中性属性</span><br><span class="line">****运动机构连接</span><br><span class="line">线性-------活塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****去水印</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****炫酷的变色人机交互</span><br><span class="line"></span><br><span class="line">变色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">视图更新，事件连接（1设置2直接ctrl  来出来  3 视图右键创建2D面板）</span><br><span class="line"></span><br><span class="line">取消设计模式</span><br><span class="line">如何让交互界面一直存在</span><br><span class="line">1协同打开面板</span><br><span class="line">2创建相机视图</span><br><span class="line">3选择更新所需视图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------2019&#x2F;1&#x2F;10  结束   Ming</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ullTCP测试</title>
    <url>/Linux-Lover/imx6ullTCP%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h6 id="client-客户端"><a href="#client-客户端" class="headerlink" title="client  客户端"></a>client  客户端</h6><p>连接服务器 connectToHost()、断开与服务器的连接disconnectFromHost()，等等。<br>提供各种信号（connected()、disconnected()、stateChanged()）与槽函数，方便应用开发者调用。</p>
<h6 id="server-服务端"><a href="#server-服务端" class="headerlink" title="server  服务端"></a>server  服务端</h6><p>（1）调用 socket 套接字函数，创建套接字的文件描述符（这个套接字是用来监听客户端连接请求的）。<br>（2）调用 bind()绑定函数，将创建成功的套接字与需要监听的 IP 地址和 Port 绑定。<br>（3）绑定成功后，就可以调用 listen()函数进行监听，等待客户端的连接请求。（服务端需要成功调用 listen()函数，客户端才可以发起连接请求，否则，客户端的连接会出错）<br>（4）调用 listen()函数成功后，若此时有客户端申请建立连接，服务端则调用 accept()函数，接收客户端的连接，并自动产生用于网络 I/O 通信的套接字，作为 accept()函数的返回值。（accept()函数自动产生的套接字是用来进行网络 I/O 数据收发的，与 socket()套接字不同）<br>（5）当客户端连接成功后，服务端就可以基于 accept()函数返回的套接字，使用系统调用的<br>读写函数 read()/write()进行数据收发了。<br>    使用嵌入式 QT 进行 TCP/IP 的网络通信应用程序开发，对于 TCP 服务端，QT 的 network<br>类库提供的 QTcpServer 类，这个类继提供了一系列的服务端网络操作接口函数，如：监听<br>函数 listen()，阻塞等待客户端连接 waitForNewConnection()，虚函数 incomingConnection()用<br>来处理客户端的连接请求</p>
<p>参考：微联智控</p>
<p>代码具体参考我的写过的博客&lt;<QT-TCP>&gt; : [<a href="https://hsm0409.github.io/QT-Lover/QT-TCP/]" target="_blank" rel="noopener">https://hsm0409.github.io/QT-Lover/QT-TCP/]</a></p>
<p>但是，以上是单用户，不适用于多用户，必须做下修改。</p>
<p>服务端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;serverwidget.h&quot;</span><br><span class="line">#include &quot;ui_serverwidget.h&quot;</span><br><span class="line"></span><br><span class="line">serverwidget::serverwidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::serverwidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    &#x2F;**********************背景设置***********************&#x2F;</span><br><span class="line"></span><br><span class="line">    this-&gt;setWindowTitle(&quot;TCP服务端 黄松明QQ：1260925116&quot;);</span><br><span class="line">    setAutoFillBackground(true);</span><br><span class="line">    QPalette pal &#x3D; this-&gt;palette();</span><br><span class="line">    pal.setBrush(backgroundRole(),QPixmap(&quot;:&#x2F;new&#x2F;prefix1&#x2F;resources&#x2F;MING.png&quot;));</span><br><span class="line">    setPalette(pal);</span><br><span class="line"></span><br><span class="line">     ui-&gt;pushButton_listen-&gt;setCheckable(false);</span><br><span class="line">    ui-&gt;pushButton_send-&gt;setEnabled(false);</span><br><span class="line">    &#x2F;******************本地地址****************************&#x2F;</span><br><span class="line"></span><br><span class="line">    ui-&gt;lineEdit_ip-&gt;setText(QNetworkInterface().allAddresses().at(2).toString());</span><br><span class="line"></span><br><span class="line">    &#x2F;******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    this-&gt;currentTcpSocket&#x3D;NULL;&#x2F;&#x2F;否则提示</span><br><span class="line">     this-&gt;tcpServer&#x3D;NULL;</span><br><span class="line">     tcpServer &#x3D; new QTcpServer(this);  &#x2F;&#x2F;放在主线</span><br><span class="line"></span><br><span class="line">     &#x2F;*********************多用户触发*************************&#x2F;</span><br><span class="line">      connect(tcpServer,&amp;QTcpServer::newConnection,this,&amp;serverwidget::NewConnectSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverwidget::~serverwidget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serverwidget::NewConnectSlot()</span><br><span class="line">&#123;</span><br><span class="line">    currentTcpSocket  &#x3D; tcpServer-&gt;nextPendingConnection();</span><br><span class="line"></span><br><span class="line">    clientlist.append(currentTcpSocket);&#x2F;&#x2F;往vector数组中插入（结构体类型）数据</span><br><span class="line"></span><br><span class="line">    QString ip &#x3D; currentTcpSocket-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1];</span><br><span class="line">    quint16 port &#x3D; currentTcpSocket-&gt;peerPort();</span><br><span class="line">    QString systime &#x3D;  QDateTime::currentDateTime().toString(&quot;hh:mm:ss&quot;);</span><br><span class="line">    QString temp &#x3D; QString(&quot; %1 [用户端%2  %3]:连接成功！QAQ&quot;).arg(systime).arg(ip).arg(port);</span><br><span class="line"></span><br><span class="line">    ui-&gt;textEdit_rx-&gt;append(temp);</span><br><span class="line"></span><br><span class="line">    &#x2F;*********************comboBox_ip 下拉框*****************************&#x2F;</span><br><span class="line">   ui-&gt;comboBox_ip-&gt;addItem(tr(&quot;%1:%2&quot;).arg(currentTcpSocket-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1])\</span><br><span class="line">                                            .arg(currentTcpSocket-&gt;peerPort()));</span><br><span class="line">    qDebug()&lt;&lt; 2 ;</span><br><span class="line">    &#x2F;******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    connect(currentTcpSocket,&amp;QTcpSocket::readyRead,this,&amp;serverwidget::ReadData);</span><br><span class="line">    connect(currentTcpSocket,&amp;QTcpSocket::disconnected,this,&amp;serverwidget::disconnectedSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serverwidget::ReadData()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i &#x3D; 0 ; i&lt; clientlist.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通信取出来</span><br><span class="line">        QByteArray array &#x3D;clientlist[i]-&gt;readAll();</span><br><span class="line"></span><br><span class="line">        if(array.isEmpty())    continue;</span><br><span class="line"></span><br><span class="line">        static QString IP_Port, IP_Port_Pre;</span><br><span class="line"></span><br><span class="line">        IP_Port &#x3D; tr(&quot;%1:%2&quot;).arg(currentTcpSocket-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1])\</span><br><span class="line">                                        .arg(currentTcpSocket-&gt;peerPort());</span><br><span class="line">     &#x2F;&#x2F; 若此次消息的地址与上次不同，则需显示此次消息的客户端地址</span><br><span class="line">    if(IP_Port !&#x3D; IP_Port_Pre)</span><br><span class="line">                    ui-&gt;textEdit_rx-&gt;append(IP_Port);</span><br><span class="line"></span><br><span class="line">        ui-&gt;textEdit_rx-&gt;append(array);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;更新ip_port</span><br><span class="line">       IP_Port_Pre &#x3D; IP_Port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void serverwidget::disconnectedSlot()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0 ; i&lt; clientlist.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;由于disconnected信号并未提供SocketDescriptor，所以需要遍历寻找</span><br><span class="line"></span><br><span class="line">        if(clientlist[i]-&gt;state() &#x3D;&#x3D; QAbstractSocket::UnconnectedState)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 删除存储在combox中的客户端信息</span><br><span class="line">            ui-&gt;comboBox_ip-&gt;removeItem(ui-&gt;comboBox_ip-&gt;findText(tr(&quot;%1:%2&quot;)\</span><br><span class="line">                    .arg(clientlist[i]-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1])\</span><br><span class="line">                    .arg(clientlist[i]-&gt;peerPort())));</span><br><span class="line">            clientlist[i]-&gt;destroyed();</span><br><span class="line">            clientlist.removeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void serverwidget::on_pushButton_listen_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    if(ui-&gt;pushButton_listen-&gt;isCheckable())</span><br><span class="line">    &#123;</span><br><span class="line">         for(int i &#x3D; 0; i &lt; clientlist.length();i++)</span><br><span class="line">         &#123;</span><br><span class="line">            QString str &#x3D; QString(&quot;服务端断开你的连接QAQ&quot;);</span><br><span class="line">            clientlist[i]-&gt;write(str.toUtf8().data());</span><br><span class="line"></span><br><span class="line">            clientlist[i]-&gt;disconnectFromHost();</span><br><span class="line"></span><br><span class="line">            QString str2 &#x3D; QString(&quot;用户端%1:%2 断开你的连接QAQ&quot;).arg(clientlist[i]-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1]).arg(clientlist[i]-&gt;peerPort());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            bool ok &#x3D; clientlist[i]-&gt;waitForDisconnected(1000);</span><br><span class="line">            if(!ok)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 处理异常</span><br><span class="line">            &#125;</span><br><span class="line">            clientlist.removeAt(i);  &#x2F;&#x2F;从保存的客户端列表中取去除</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">            tcpServer-&gt;close();     &#x2F;&#x2F;不再监听端口</span><br><span class="line">            ui-&gt;pushButton_listen-&gt;setText(&quot;开始监控&quot;);</span><br><span class="line">            ui-&gt;pushButton_listen-&gt;setCheckable(false);</span><br><span class="line">            ui-&gt;pushButton_listen-&gt;setCheckable(false);</span><br><span class="line">            ui-&gt;pushButton_send-&gt;setEnabled(false);</span><br><span class="line">        &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        bool ok ;</span><br><span class="line">        int port &#x3D; ui-&gt;lineEdit_port-&gt;text().toInt(&amp;ok,10);</span><br><span class="line">        tcpServer-&gt;listen(QHostAddress::Any,port);&#x2F;&#x2F;只能在接收成功  server  newConnection是接收信息</span><br><span class="line">        qDebug() &lt;&lt; &quot;监听中\n&quot; ;</span><br><span class="line">        ui-&gt;pushButton_send-&gt;setEnabled(true);</span><br><span class="line">        ui-&gt;pushButton_listen-&gt;setText(&quot;停止监控&quot;);</span><br><span class="line">        ui-&gt;pushButton_listen-&gt;setCheckable(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void serverwidget::on_pushButton_send_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容</span><br><span class="line">    QString str &#x3D; ui-&gt;textEdit_tx-&gt;toPlainText();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不指定，全部发送</span><br><span class="line">    if(ui-&gt;comboBox_ip-&gt;currentIndex() &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 0; i&lt; clientlist.length();i++)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;发送</span><br><span class="line">            clientlist[i]-&gt;write(str.toUtf8().data());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#x2F;&#x2F;指定ip</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        QString SelectIp &#x3D; ui-&gt;comboBox_ip-&gt;currentText().split(&quot;:&quot;)[0];</span><br><span class="line">        QString SelectPort &#x3D; ui-&gt;comboBox_ip-&gt;currentText().split(&quot;:&quot;)[1];</span><br><span class="line"></span><br><span class="line">        qDebug() &lt;&lt; SelectIp;</span><br><span class="line">        qDebug() &lt;&lt; SelectPort;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i&lt; clientlist.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">         if(clientlist[i]-&gt;peerAddress().toString().split(&quot;::ffff:&quot;)[1] &#x3D;&#x3D; SelectIp &amp;&amp; clientlist[i]-&gt;peerPort() &#x3D;&#x3D; SelectPort.toInt())</span><br><span class="line">         &#123;</span><br><span class="line">             clientlist[i]-&gt;write(str.toLatin1());</span><br><span class="line">             return ;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void serverwidget::on_pushButton_clear_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;textEdit_rx-&gt;clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<iframe src="//player.bilibili.com/player.html?aid=328735904&bvid=BV1EA411e7nJ&cid=208936456&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"height="600" width="100%"> </iframe>











]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-内存泄漏小记</title>
    <url>/Linux-Lover/QT-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>QT 内存泄漏的问题要不断学习QAQ 2020/6/28</p>
<p>Qt中使用了new却很少delete，因为QObject的类及其继承的类，设置了parent,故parent被delete时，这个parent的相关所有child都会自动delete，不用用户手动处理。</p>
<p> explicit Widget(QWidget *parent = 0);</p>
<p>但是问题：</p>
<p>1、可以释放掉任何的对象，而delete栈上对象就会导致内存出错，这需要了解Qt的半自动的内存管理。<br>Qt的半自动化的内存管理 </p>
<p>（1）QObject及其派生类的对象，如果其parent非0，那么其parent析构时会析构该对象。<br>（2）QWidget及其派生类的对象，可以设置 Qt::WA_DeleteOnClose 标志位(当close时会析构该对象)。<br>（3）QAbstractAnimation派生类的对象，可以设置 QAbstractAnimation::DeleteWhenStopped。<br>（4）QRunnable::setAutoDelete()、MediaSource::setAutoDelete()。 </p>
<p>2、child不知道它自己是否被delete掉了，故可能会出现野指针。那就要了解Qt的智能指针QPointer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置标志位，close()后会delete label。</span><br><span class="line"></span><br><span class="line">label-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QLabel label(&quot;Hello Qt!&quot;);  </span><br><span class="line">QWidget w;  </span><br><span class="line">label.setParent(&amp;w);  </span><br><span class="line">w.show(); </span><br><span class="line">原因：label先被析构，当w被析构时，会删除chilren列表中的对象label，但label是分配到栈上的，因delete栈上的对象而出错。</span><br><span class="line"></span><br><span class="line">  QWidget w;  </span><br><span class="line">   QLabel label(&quot;Hello Qt!&quot;);  </span><br><span class="line">   label.setParent(&amp;w);  </span><br><span class="line">   w.show();</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QLabel *label &#x3D; new QLabel(&quot;Hello Qt!&quot;);  </span><br><span class="line">label 既没有指定parent，也没有对其调用delete，所以会造成内存泄漏。</span><br><span class="line">改进方式：分配对象到栈上而不是堆上</span><br><span class="line">QLabel label(&quot;Hello Qt!&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将label分配到堆上</span><br><span class="line"></span><br><span class="line">QLabel *label &#x3D; new QLabel(&quot;Hello Qt!&quot;);</span><br><span class="line">label-&gt;setParent(&amp;w)</span><br><span class="line">或者QLabel *label &#x3D; new QLabel(“Hello Qt!”,this);</span><br><span class="line"></span><br><span class="line">没有指定父类的需要</span><br><span class="line">new后手动delete  !!!</span><br><span class="line"></span><br><span class="line">serialport &#x3D; new QSerialPort(this); &#x2F;&#x2F;new的时候指定了 mainwindow这个父对象 不用手动释放</span><br><span class="line">serialport &#x3D; new QSerialPort;&#x2F;&#x2F;不指定父对象 则需要自己使用完delete</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序崩溃，因为label被close时，delete &amp;label;但label对象是在栈上分配的内存空间，delete栈上的地址会出错。 </span><br><span class="line">可以测试QLabel label(“Hello Qt!”); label.show();delete &amp;label;第一次delete就会出错。</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">野指针 -----&gt;QPointer智能指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;QApplication&gt;  </span><br><span class="line">#include &lt;QLabel&gt;  </span><br><span class="line">#include &lt;QPointer&gt;  </span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">   QApplication app(argc, argv);  </span><br><span class="line">   QWidget *w &#x3D; new QWidget;  </span><br><span class="line">   QLabel *label &#x3D; new QLabel(&quot;Hello Qt!&quot;);  </span><br><span class="line">   label-&gt;setParent(w);  </span><br><span class="line">   QPointer&lt;QLabel&gt; p &#x3D; label;  </span><br><span class="line">   w-&gt;show();  </span><br><span class="line">   delete w;  </span><br><span class="line">   if (!p.isNull()) &#123;  </span><br><span class="line">     label-&gt;setText(&quot;go&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">   return app.exec();</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_33485434/article/details/79649647?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_33485434/article/details/79649647?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull滑动界面</title>
    <url>/uncategorized/imx6ull%E6%BB%91%E5%8A%A8%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>界面效果：</p>
<iframe src="//player.bilibili.com/player.html?aid=753737773&bvid=BV1Xk4y1q7tb&cid=206590500&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height ="600" width="100%"> </iframe>

]]></content>
  </entry>
  <entry>
    <title>QT-画面滑动切换</title>
    <url>/QT-Lover/QT-%E7%94%BB%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*widget.h*&#x2F;</span><br><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QMouseEvent&gt;</span><br><span class="line">#include &lt;QEvent&gt;</span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">     bool eventFilter(QObject *watched, QEvent *event);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*widget.c*&#x2F;</span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    this-&gt;installEventFilter(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line">bool Widget::eventFilter(QObject *watched, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">       static int press_x;</span><br><span class="line">       static int press_y;</span><br><span class="line">       static int release_x;</span><br><span class="line">       static int release_y;</span><br><span class="line">       </span><br><span class="line">QMouseEvent*  event_1 &#x3D; static_cast&lt;QMouseEvent *&gt; (event);</span><br><span class="line"></span><br><span class="line">    if(event_1-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress )</span><br><span class="line">    &#123;</span><br><span class="line">            press_x &#x3D; event_1-&gt;globalX();</span><br><span class="line">            press_y &#x3D; event_1-&gt;globalY();</span><br><span class="line">    &#125;</span><br><span class="line">    if(event_1-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonRelease)</span><br><span class="line">    &#123;</span><br><span class="line">            release_x &#x3D; event_1-&gt;globalX();</span><br><span class="line">            release_y &#x3D; event_1-&gt;globalY();</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*******判断左滑动*******&#x2F;</span><br><span class="line">	if(  ((release_x -press_x) &lt; 0)  &amp;&amp; ((release_y - press_y) &gt; 0)   &amp;&amp; (event_1-&gt;type()&#x3D;&#x3D; QEvent::MouseButtonRelease))</span><br><span class="line">    &#123;</span><br><span class="line">	int current_page &#x3D; ui-&gt;stackedWidget-&gt;currentIndex();</span><br><span class="line"></span><br><span class="line">        if(current_page &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">	ui-&gt;stackedWidget-&gt;setCurrentIndex(current_page - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current_page &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;stackedWidget-&gt;setCurrentIndex(4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;********判断右滑动********&#x2F;</span><br><span class="line">    if(  ((release_x -press_x) &gt; 0)  &amp;&amp; ((release_y - press_y) &lt; 0)   &amp;&amp; (event_1-&gt;type()&#x3D;&#x3D; QEvent::MouseButtonRelease))</span><br><span class="line">    &#123;</span><br><span class="line">	int current_page &#x3D; ui-&gt;stackedWidget-&gt;currentIndex();</span><br><span class="line">        if(current_page &lt; 4)</span><br><span class="line">        &#123;</span><br><span class="line">  ui-&gt;stackedWidget-&gt;setCurrentIndex(current_page + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current_page &#x3D;&#x3D; 4)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;stackedWidget-&gt;setCurrentIndex(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return QWidget::eventFilter(watched,event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="/QT-Lover/QT-%E7%94%BB%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2/cat.gif" class="">


<p>四点缩放的思路</p>
<img src="/QT-Lover/QT-%E7%94%BB%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2/%E5%9B%9B%E7%82%B9%E6%BB%91%E5%8A%A8.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-ui快捷背景小记</title>
    <url>/QT-Lover/QT-ui%E5%BF%AB%E6%8D%B7%E8%83%8C%E6%99%AF%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>控件背景</strong></p>
<p>右键改变样式<br>写法1<br>#pushButton{<br>background:url(“:/new/prefix1/数字1.png”)<br>}<br>写法2<br>background:url(:/new/prefix1/cat.png);<br>background-image: url(:/new/prefix1/cat.png);</p>
<p>注意：background是一个集合，它包括background-color,background-image,background-size</p>
<p>border-image: url(:/new/prefix1/数字1.png);//文件<br>image: url(:/new/prefix1/cat.png);//文件原大小，多余为空白</p>
<p>setStyleSheet(QWidget{“border-radius:6px;background-color:rgba(100,100,100,80%)}”);/<em>多用这个，类继承mainwidget</em>/<br>                                              pushButton-&gt;setStyleSheet(“QPushButton{border-image:url(:/icons/Resource/icons/close.png);”<br>“background-color:transparent}”<br>“QPushButton:hover{border-image:url(:/icons/Resource/icons/close_hover.png);}” );<br>/<em>hover 选中时候的状态 按钮悬停</em>/</p>




<p>background-color: rgb(6, 6, 6); 控件背景<br>border-radius: 3px; color: rgb(255, 255, 255); 控件字体</p>
<p><strong>函数背景</strong></p>
<p>写法1：<br>setAutoFillBackground(true);<br>QPalette pal = this-&gt;palette();  pal.setBrush(backgroundRole(),QPixmap(“:/new/prefix1/MING.png”));<br>setPalette(pal);</p>
<p>注：设置的项目基类为Widget的时候，不能用setstylesheet设置widget的背景图片。</p>
<p>this-&gt;setStyleSheet( iconStyleSheet );<br>ui-&gt;pushButton-&gt;setStyleSheet(“#pushButton{background-image: url(:/new/prefix1/数字5.png);}”);g);}”);</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-休眠函数</title>
    <url>/QT-Lover/QT-%E4%BC%91%E7%9C%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>方式一</strong></p>
<p>使用QElapsedTimer：会阻塞线程头文件：<br>#include <QElapsedTimer></p>
<p>QElapsedTimer t;<br>t.start();<br>while(t.elapsed()&lt;10000)</p>
<pre><code> QElapsedTimer timer;
    int count = 1;
    timer.start();
    do {
        count *= 2;
        slowOperation2(count);
    } while (timer.restart() &lt; 250);
return count;</code></pre><p> <strong>方式二</strong><br>自定义延时函数：不会阻塞当前线程使用QEventLoop<br>void Widget::Sleep(int msec)<br>{<br>    QTime dieTime = QTime::currentTime().addMSecs(msec);<br>    while( QTime::currentTime() &lt; dieTime )<br>        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);<br>}<br> 进入消息循环，不仅处理当前事件，而且处理其它事件<br>QCoreApplication::processEvents(QEventLoop::AllEvents, 100);</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull多线程测试（二）</title>
    <url>/Linux-Lover/imx6ull%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>用继承 QObject 的方法来创建多线程：<br>（1）写一个继承 QObject 的类，并把复杂耗时的操作声明为槽函数。<br>（2）在主线程（ui 线程）中 new 一个继承 Object 类的对象，不设置父类。<br>（3）声明并 new 一个 QThread 对象。（如果 QThread 对象没有 new 出来，则需要在 QObject类析构的时候使用 QThread::wait()等待线程完成。如果是通过堆分配（new 方式），则可以通过 deleteLater 来进行释放）<br>（4）使用 QObject::moveToThread(QThread*)方法，把 QObject 对象转移到新的线程中。<br>（5）把线程的finished()信号与QObject的deleteLater()类连接，这个是安全释放线程的关键，不连接的话，会导致内存泄漏。<br>（6）连接其他信号槽，如果是在连接信号槽之前调用 moveToThread，不需要处理 connect<br>函数的第五个参数，这个参数是表示信号槽的连接方式；否则，如果在连接所有信号槽之后再调用 moveToThread，则需要显式声明 Qt::QueuedConnection 来进行信号槽连接。</p>
<iframe src="//player.bilibili.com/player.html?aid=626236088&bvid=BV1Zt4y197gL&cid=206373278&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  height="600" width="100%"> </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull多线程测试（一）</title>
    <url>/Linux-Lover/imx6ull%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>参考来源：微联智控工作室 感谢QAQ</p>
<p>在 QT 开发过程中，使用多线程，有两种方法：<br>方法一：继承 QThread 的 run() 函数，把复杂的循环逻辑放在 run() 函数中执行。<br>方法二：把一个继承于 QObject 的类，使用 moveToThread() 方法，转移到一个 QThread 的类对象中。</p>
<p>方法一：继承 QThread  类，重载 run() 方法</p>
<p>继承 QThread  类，创建线程对象后，只有 run() 方法运行在新的线程里，类对象里面的其他方法都在创建 QThread  类的线程里运行。</p>
<p>1 、在ui 线程中，调用了继承 QThread 类里面的方法，会不会造成ui卡顿。<br>答：并不会造成 ui 卡顿。<br>2 、在ui 线程中,调用了 Thread::quit()/QThread::exit()/ QThread::terminate() 会不会停止线程。<br>答：只有QThread::terminate() 可以正真的停止线程</p>
<p>3 、 如何安全地退出一个线程？<br>答：m_thread-&gt;stopImmediately(); //调用这个函数，安全退出线程</p>
<p>线程结束，会发射 finish()信号，槽函数 onQThreadFinished()<br>即会被调用。</p>
<p>4 、 如何正确地启动一个线程？<br>（1）如何正确地启动一个全局线程？<br>（2） 如何正确地启动一个局部线程？</p>
<p>一个按钮出发两次子函数现象？<br>注：connect(ui&gt;pushButton_doSomthing,SIGNAL(clicked()),this,SLOT(on_pushButton_doSomthing_clicked()),Qt::UniqueConnection);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*在这里创建了一个全局线程*&#x2F;</span><br><span class="line">m_thread &#x3D; new ThreadfromQThread(this);</span><br><span class="line">    connect(m_thread,SIGNAL(message(QString)),this,SLOT(receiveMessage(QString)));  &#x2F;&#x2F;接收message信号，在窗口打印线程信息</span><br><span class="line">    connect(m_thread,SIGNAL(progress(int)),this,SLOT(progress(int)));&#x2F;&#x2F;接收progress信号，更新进度条</span><br><span class="line">    connect(m_thread,SIGNAL(finished()),this,SLOT(onQThreadFinished()));&#x2F;&#x2F;接收线程结束信号，打印线程结束的消息</span><br><span class="line"> m_heart.start();   &#x2F;&#x2F;启动定时器，不断更新heartbeat进度条</span><br><span class="line"></span><br><span class="line"> &#x2F;*局部线程*&#x2F;</span><br><span class="line">this-&gt;m_currentRunLoaclThre &#x3D; NULL;</span><br><span class="line">------------全局析构----------------</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;start destroy widget&quot;;</span><br><span class="line">    m_thread-&gt;stopImmediately();&#x2F;&#x2F;由于此线程的父对象是Widget，因此退出时需要进行判断</span><br><span class="line">    m_thread-&gt;wait();   &#x2F;&#x2F;在这里，会阻塞等待线程执行完</span><br><span class="line">    delete ui;</span><br><span class="line">    qDebug() &lt;&lt; &quot;end destroy widget&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------子函数---------------</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_qthreadRunLocal_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;判断这个局部线程是否已经存在，如果已经存在，则先退出</span><br><span class="line">    if(this-&gt;m_currentRunLoaclThre)</span><br><span class="line">    &#123;</span><br><span class="line">         this-&gt;m_currentRunLoaclThre-&gt;stopImmediately();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadfromQThread* thread &#x3D; new ThreadfromQThread(NULL);</span><br><span class="line">    &#x2F;&#x2F;这里父对象指定为NULL</span><br><span class="line">   connect(thread,SIGNAL(message(QString)),this,SLOT(receiveMessage(QString)));</span><br><span class="line">   &#x2F;&#x2F;接收message信号，在窗口打印线程信息</span><br><span class="line">  connect(thread,SIGNAL(progress(int)),this,SLOT(progress(int)));</span><br><span class="line">  &#x2F;&#x2F;接收progress信号，更新进度条</span><br><span class="line">  connect(thread,SIGNAL(finished()),this,SLOT(onQThreadFinished()));</span><br><span class="line">  &#x2F;&#x2F;接收线程结束信号，打印线程结束的消息</span><br><span class="line">    connect(thread,SIGNAL(finished()),thread,SLOT(deleteLater()));&#x2F;&#x2F;线程结束后调用deleteLater来销毁分配的内存</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;线程销毁时，会发送destroyed信号，然后把临时变量再次赋值为NULL</span><br><span class="line"> connect(thread,SIGNAL(destroyed(QObject*)),this,SLOT(onLocalThreadDestroy(QObject*)));</span><br><span class="line">    thread-&gt;setRunCount(5);</span><br><span class="line">    thread-&gt;start();</span><br><span class="line">    &#x2F;&#x2F;启动线程，执行run()函数</span><br><span class="line">    this-&gt;m_currentRunLoaclThre &#x3D; thread;  </span><br><span class="line">    &#x2F;&#x2F;保存当前正在运行的线程</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;局部线程销毁函数，</span><br><span class="line">void Widget::onLocalThreadDestroy(QObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">   if(qobject_cast&lt;QObject *&gt;(m_currentRunLoaclThre) &#x3D;&#x3D; obj)</span><br><span class="line">   &#123;</span><br><span class="line">        m_currentRunLoaclThre &#x3D; NULL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全局线程</strong></p>
<p>   会在创建时，把 ui 线程作为自己的父对象，当 ui 线程析构时，全局线程也会进行销毁。但此时，应该关注一个问题：当 ui 线程结束（窗体关闭）时，全局线程还没有结束，应当如何处理？如果没有处理好这种情况，在 ui 线程析构时，强行退出全局线程，会导致程序崩溃。往往这种线程的生命周期是伴随着 ui 线程一起开始与结束的。</p>
<p><strong>局部线程</strong></p>
<p>  也叫临时线程，这种线程一般是要进行一些耗时任务，为了防止 ui 线程卡死而存在的。同样地，我们更关注以下问题：在局部线程运行期间，如果因为某些因素要停止线程，该如何安全地退出局部线程？例如，在图片打开期间（还没有完全打开），要切换图片，该如何处理。在音乐播放期间，要切换下一首音乐，应如何处理。如果手动 delete 了线程指针，程序会很容易崩溃。正确的退出方法，可以使用 void QObject::deleteLater() [SLOT] 这个槽函数。</p>
<iframe src="//player.bilibili.com/player.html?aid=796213214&bvid=BV1oC4y187Ty&cid=205802849&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%"> </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull串口测试</title>
    <url>/Linux-Lover/imx6ull%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><strong>imx6ull串口测试</strong></p>
<iframe src="//player.bilibili.com/player.html?aid=883559512&bvid=BV17K4y147YL&cid=204200631&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%" > </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-键盘输入类</title>
    <url>/Linux-Lover/QT-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%B1%BB/</url>
    <content><![CDATA[<p>参考：<a href="https://justchen.com/2020/02/19/qt-virtualkeyboard-%E6%8F%92%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener">https://justchen.com/2020/02/19/qt-virtualkeyboard-%E6%8F%92%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8.html</a></p>
<p><a href="https://www.iemblog.com/?p=1389&amp;lang=zh" target="_blank" rel="noopener">https://www.iemblog.com/?p=1389&amp;lang=zh</a></p>
<p>下载<br><a href="https://github.com/qt/qtvirtualkeyboard/releases/tag/v5.12.8">https://github.com/qt/qtvirtualkeyboard/releases/tag/v5.12.8</a></p>
<p>压缩<br>sudo unzip qtvirtualkeyboard-everywhere-src-5.14.2.zip</p>
<p>编译<br>/opt/Qt5.5.1/5.5/gcc_64/bin/qmake myuart.pro -spec linux-g++ ‘CONFIG+=lang-all’</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>usb烧录系统启动内核失败</title>
    <url>/Linux-Lover/usb%E7%83%A7%E5%BD%95%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>出现“Starting kernel …”以后就再也没有任何信息输出了，说明Linux 内核启动失败了。</p>
<p>解决Linux 内核启动失败</p>
<p>mmc dev 1  //切换到 EMMC<br>ls mmc 1:1  //输出 EMMC1 分区 1 中的所有文件</p>
<p>setenv bootcmd ‘mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb;bootz 80800000 - 83000000’</p>
<p>setenv bootargs ‘console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw’</p>
<p>saveenv</p>
<p>2 、修改 uboot<br>uboot 源码。打开 uboot 源码中的文件include/configs/mx6ull_alientek_emmc.h<br>在宏 CONFIG_EXTRA_ENV_SETTINGS</p>
<p>“findfdt=”<br> “if test $fdt_file = undefined; then “ <br> “setenv fdt_file imx6ull-alientek-emmc.dtb; “ <br>“fi;\0” \</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>进一步了解qt项目文件</title>
    <url>/QT-Lover/%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3qt%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6-0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u011012932/article/details/51774724" target="_blank" rel="noopener">https://blog.csdn.net/u011012932/article/details/51774724</a></p>
<p>看到一个人ffmpeg调用中的项目写法很特别，记录下QvQ</p>
<p>项目.pro</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET     &#x3D; ffmpegdemo</span><br><span class="line">TEMPLATE    &#x3D; app</span><br><span class="line">MOC_DIR     &#x3D; temp&#x2F;moc      &#x2F;&#x2F;指定来自moc的所有中间文件放置的目录</span><br><span class="line">RCC_DIR     &#x3D; temp&#x2F;rcc     &#x2F;&#x2F;指定Qt资源编译器输出文件的目录</span><br><span class="line">UI_DIR      &#x3D; temp&#x2F;ui     &#x2F;&#x2F;指定所有中间文件.o（.obj）放置的目录。</span><br><span class="line">OBJECTS_DIR &#x3D; temp&#x2F;obj      &#x2F;&#x2F;指定来自uic的所有中间文件放置的目录</span><br><span class="line">message($$DESTDIR)</span><br><span class="line">DESTDIR     &#x3D; $$PWD&#x2F;..&#x2F;bin  			 &#x2F;&#x2F;指定在何处放置目标文件。</span><br><span class="line">message($$DESTDIR)</span><br><span class="line"></span><br><span class="line">#ffmpeg3表示用ffmpeg3版本 可以改成ffmpeg4表示用ffmpeg4版本</span><br><span class="line">#qt32表示采用32位的ffmpeg 可以改成qt64表示采用64位的ffmpeg</span><br><span class="line">DEFINES     +&#x3D; ffmpeg4 qt64    		 &#x2F;&#x2F;qmake添加这个变量的值作为编译器C预处理器宏</span><br><span class="line">SOURCES     +&#x3D; main.cpp widget.cpp</span><br><span class="line">HEADERS     +&#x3D; widget.h</span><br><span class="line">FORMS       +&#x3D; widget.ui   </span><br><span class="line">CONFIG      +&#x3D; warn_off</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;ffmpeg         &#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line">include ($$PWD&#x2F;ffmpeg&#x2F;ffmpeg.pri)     &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>子项目.pri</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEADERS     +&#x3D; $$PWD&#x2F;ffmpeghead.h</span><br><span class="line">HEADERS     +&#x3D; $$PWD&#x2F;ffmpeg.h</span><br><span class="line">SOURCES     +&#x3D; $$PWD&#x2F;ffmpeg.cpp</span><br><span class="line"></span><br><span class="line">#ffmpeg4则使用ffmpeg4的目录</span><br><span class="line">contains(DEFINES, ffmpeg4) &#123;</span><br><span class="line">strPath &#x3D; ffmpeg4</span><br><span class="line">&#125; else &#123;</span><br><span class="line">strPath &#x3D; ffmpeg3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#32位的库则使用32位的库的头文件和lib文件</span><br><span class="line">contains(DEFINES, qt32) &#123;</span><br><span class="line">strLib &#x3D; winlib</span><br><span class="line">strInclude &#x3D; include</span><br><span class="line">&#125; else &#123;</span><br><span class="line">strLib &#x3D; winlib64</span><br><span class="line">strInclude &#x3D; include64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;$$strPath&#x2F;$$strInclude   </span><br><span class="line">&#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;$$strPath&#x2F;$$strInclude&#x2F;plugins </span><br><span class="line">&#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定链接到项目中的库列表。</span><br><span class="line">win32 &#123; </span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;$$strPath&#x2F;$$strLib&#x2F; -lavcodec -lavfilter -lavformat -lswscale -lavutil -lswresample -lavdevice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#请自行替换</span><br><span class="line">unix &#123;</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;linuxlib&#x2F; -lavfilter -lavformat -lavdevice -lavcodec -lswscale -lavutil -lswresample -lavdevice -lpthread -lm -lz -lrt -ldl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器层面</title>
    <url>/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>Cache</strong></p>
<p>统一的cache：数据指令一起<br>哈佛Cache：数据指令分开</p>
<p>存储内容动态变化，必须保存存储数据以及主存储器的地址。</p>
<p>存储管理单元MMU—多个活动程序快速切换</p>
<p>存储器管理的两种基本方法：段式管理和页式管理。</p>
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/%E6%AE%B5.jpg" class="">
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/%E9%A1%B5.jpg" class="">

<p>高10位：页目录<br>次高10位：页表<br>12位：页结构（数据）</p>
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/64%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" class="">


<p>虚拟内存是操作系统物理内存和进程之间的中间层，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。<br>64位，每个进程的虚拟内存空间是完全独立的，所以它们都可以完整的使用 0x0000000000000000 到 0x00007FFFFFFFFFFF 的全部内存。<br>此内核虚拟地址范围总计为 256 TB，但实际在使用的是8TB<br>X64 CPU 已经限制了虚拟地址中可用的比特数为 48 位，Windows 做出了进一步的限制，将其削减为 44 位。</p>
<p>32位地址数 2^32 * 1024<em>1024</em>1024<em>8<br>32内存容量  2^32 * 1024</em>1024*1024 =4G<br>TiB    2的40   TB 10的12次</p>
<p>Linux默认页大小是4KB？0-11  2的12次<br>过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找速度和额外开销；<br>过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；</p>
<p>Linux 在 2.6.10 中引入了四层的页表辅助虚拟地址的转换，在 4.11 中引入了五层的页表结构，在未来还可能会引入更多层的页表结构以支持 64 位的虚拟地址。</p>
<p>32位中<br>10+10+12  4G</p>
<p>64，为什么每层的页表结构只能够负责 9位虚拟地址的寻址？<br>规定48位虚拟地址。9+9+9+9+12<br>64 位的虚拟内存在操作系统中需要多少层的页表结构才能寻址？<br>6</p>
<p><strong>ARM系统控制协处理器</strong></p>
<p>ARM系统控制协处理器是一个片上协处理器,使用逻辑协处理器号15,控制片上Cache或Cache,<br>存储器管理或保护单元、写缓冲器、预取缓冲器、转移目标Cache以及系统配置信号操作。</p>
<p><strong>CP15指令</strong></p>
<p>MRC MCR</p>
<p><strong>MMU存储器管理单元（Memory Management Unit）</strong></p>
<p>MMU完成两个基本功能:<br>1、将虚拟地址转换为物理地址。<br>2、控制存储器访问权限,中止非法访问</p>
<p>转化 ：虚拟地址-》物理地址</p>
<p>虚拟地址-》CP15寄存器2（转化表基地址）-》主存储器的物理地址</p>
<p>注意：小型嵌入式系统甚至可能连这种开销也不能承受,或者可能只有非常简单的调度”需求(例如在所有时间里只执行1个固定程序，根本不需要一个“操作系统”。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM流水线</title>
    <url>/ARM-Lover/ARM%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p><strong>3级流水线</strong></p>
<p>1.取指<br>从存储器中取出指令,放人指令流水线。<br>2.译码<br>指令被译码,并为下一周期准备数据通路的控制信号。在这一级,指令占有详码理辑,不占有数据通路。<br>3.执行<br>指令占有数据通路,寄存器堆被读取,操作数被移位, ALU（算数逻辑单元）产生结果并回写到目的寄存器。</p>
<p>（1）STR计算地址、数据传送。<br>（2）所有指令都占用数据通路一个或多个相邻周期。<br>（3）在指令占用数据通路的每一个周期,都在前面的相邻周期占有译码逻辑在第一个数据通路周期,每条指令为下下条指令发出取指信号。<br>（4）转移指令清空(flush)和重填指令流水线。</p>
<p>PC指向当前指令后的8个字节（两条指令）</p>
<p><strong>5级流水线</strong></p>
<p>所有的处理器都要满足对高性能的要求。直到ARM7为止,在ARM核中使用的”3级流水线的性价比是很高的。但是,为了得到更高的性能,需要重新考虑处理器的组织结构。</p>
<p>CPI：每条指令的平均周期数</p>
<p>冯·诺依曼瓶颈有关–指令和数据放在同一个存储器的任何存储程序计算机,其性能将受到现有存储器带宽的限制。</p>
<p>使用5级流水线的ARM处理器具有下流水线级:</p>
<p>1、取指<br>从存储器中取出指令,并将其放入指令流水线。<br>2、译码<br>指令披译码,从寄存器堆中读取寄存器操作数。在寄存器堆中有3个操作数读端口,因此,大多数ARM指令能在1个周期内读取其操作数。译码级已经开始从寄存器堆中读取寄存器操作数，这样的话,<br>读取到得就是PC+4，不是PC+8。<code>数据前推的方式</code></p>
<p>3、执行<br>把一个操作数移位,产生ALU的结果,如果指令是load或Store,则在ALU中i算存储器的地址。<br>4、缓冲/数据<br>如果需要,则访问数据存储器;否则AL.U的结果只是简单地缓冲1个时钟周期,以便使所有的指令具有同样的流水线流程。<br>5、回写<br>将指令产生的结果回写(writeback)到寄存器堆,包括任何从存储器中读取的数据。</p>
<p><strong>向下兼容的必要性</strong></p>
<p>PC+4，直接送到译码级的寄存器文件(file),穿过两级之间的流水线寄存器。下一条指令的PC+4等于当前指令的PC+8,因此,未使用额外的硬件便得到了正确的r15.</p>
<p><strong>ARM操作模式</strong></p>
<p>|CPSR[4:0]当前状态寄存器|模式|用途<br>|-|-|<br>|10000|用户|正常用户模式|<br>|10001|FIQ|处理快速中断|<br>|10010|IRQ处理标准中断处理||<br>|10011|SVC|软件中断|<br>|10100|中止|处理存储器故障|<br>|10111|未定义|处理未定义的指令陷阱|<br>|11111|系统|运行特权操作系统任务|</p>
<p>SPSR<br>每一种特权模式（除系统模式外）都有一个一直相关的程序状态保存寄存器SPSR。</p>
<p>进入特权监控自己SPRS用通用寄存器保存。</p>
<p>异常||向量地址<br>|-|-|<br>|复位  | svc |0x00000000<br>|未定义|  und |0x00000004<br>|软件中断 |svc |0x00000008<br>|取存储器故障| abort |0x0000000C<br>|访问数据故障| abort| 0x00000010<br>|IRQ |IRQ |0x00000018<br>|FRQ |FRQ |0x0000001C</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM体系架构</title>
    <url>/ARM-Lover/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>ARM处理器是精简指令集计算机（RISC）。</p>
<p>ARM由于各种因素的偶然组合而诞生,成为Aconn产品线的核心部分,后来,在明智地将缩写字ARM的意义修改为Advanced RISC Machine以后,它把它的名字借给新组成的公司去在Acorn的产品范围之外扩展市场。尽管名称变化了,体系结构仍保持同原Acorn的设计相近。</p>
<p><strong>采用的技术特征</strong></p>
<p>ARM体系结构采用了Berkcley RISC设计中的特征<br>（1）Load/Store体系结构；<br>      针对存储器状态的惟一操作是将存储器的值拷贝到寄存器(Load指令)或将寄存器中的值拷贝到存储器(Store指令).<br>（2）固定的32位指令；<br>    load/store指令：装载和存储指令<br>    ldr、sdr单寄存器<br>    ldm、stm多寄存器<br>（3）3地址指令格式；<br>    在这种指令中包括两个操作数地址码和一个结果地址码，可使得在操作结束后，原来的操作数不被改变。</p>
<p><strong>也放弃了其他特征</strong></p>
<p>（1）寄存器窗口：带来的主要问题是大量的寄存器占用很大的芯片面积。不采用<br>（2）延迟转移：在原来的ARM中延迟转移没有采用,因为它使异常处理更加复杂。从长远观点来看,这是一个好的决定,因为当采用不同流水线重新实现体系结构时,它能使任务简化。不采用<br>（3）所有指令单周期执行：ARM被设计为使用最少的时钟周期来访问存储器,而不是所有的指令都单周期,执行。当访问在储器需要超过1个周期时,就多用1个周期、有可能时,做一些有用的事,如支持自动变址寻址模式。这减少了完成任何操作序列所需要的ARM指令总数,提高效率和改进代码密度。</p>
<p><strong>ARM编程模型</strong></p>
<p>处理器指令集定义了操作。程序员可以用这些操作来改变集成了处理器的系统的态</p>
<p>当编写用户级程序时,仅有15个通用32位寄存器(ro~r14)、程序计数器PC(r15)和当前程序状态寄存器(CPSR. Current Program Status Register)需要考虑。其余寄存器仅用于系统级编程和异常处理（如中断）。</p>
<p><strong>ARM异常</strong></p>
<p>ARM体系结构支持-系列中断、陷阱和监控调用为异常。<br>在任何情况下处理异常的方法都是一-样的,即<br>1)通过将PC拷贝到r14-exc以及将CPSR拷贝到SPSR-exc(在此cxc表示异常类型)来保存当前状态<br>2)将处理器操作模式改变为适当的异常模式<br>3)将PC强制变为00(16)~1C(16)范围内某个与异常类型有关的特殊值。<br>这个特殊值位置(向量地址)的指令通常是指向异常处理程序的转移指令。通常将13-exc初始化,使其指向存储器中一个专用堆栈。异常处理程序将使用r13_exc来保存一些用户寄存器,使其能作为工作寄存器使用。</p>
<p><strong>arm中r0-r15作用？</strong></p>
<p>参考：<a href="http://blog.chinaunix.net/uid-28458801-id-3792828.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-28458801-id-3792828.html</a></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r0-r3</td>
<td>用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。</td>
</tr>
<tr>
<td>r4-r11</td>
<td>被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。</td>
</tr>
<tr>
<td>r12</td>
<td>是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。</td>
</tr>
<tr>
<td>r13</td>
<td>是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。</td>
</tr>
<tr>
<td>r14</td>
<td>是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复</td>
</tr>
<tr>
<td>r15</td>
<td>是程序计数器 PC。</td>
</tr>
</tbody></table>
<p>注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM处理器知识</title>
    <url>/ARM-Lover/Untitled/</url>
    <content><![CDATA[<p>需要是发明之母！！！</p>
<p>第一片ARM 由Acorn Computers Limited公司研发 1983-1985<br>高性能，低功耗和低价格，立足市场。</p>
<p><strong>什么是片上调试？</strong></p>
<p>通过一个片上的调试模块OCD，可以实现对MCU的运行过程进行单步调试、全速运行、设置硬件断点等调试操作，还可以dao随时查看或者修改MCU的片内/片外数据存储区域的内容，从而为调试者提供了访问MCU运行时的内部状态以及控制MCU运行过程的方法和途径。</p>
<p>缺点：调试过程只能有一个接口。</p>
<p><strong>SIMD指令</strong></p>
<p>SIMD全称Single Instruction Multiple Data，单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。</p>
<p>伴随着指令集结构的进展,微结构也出现一些变化以增强性能。<br>ARM7TDMI采用基子3级流水线的微结构,这与最初ARM核使用的结构是样的,但是对于像5级流水线ARM9TDMI这样更高速芯核的市场正在快速发展。<br>这种简单性是这些机器实或低功耗和小硅片面积的关键。</p>
<p>基于微处理器核的片上系统(SoC, System on-Chip)设计,也可用于微处理器核设计<br>Thumb新型压缩指令格式。</p>
<p>1980年，精简指令集计算机(RISC , Reduced Introduction Set Computer)的思想起源于1980年斯坦福大学的一项处理器研究项目,而其中一些核心思想可以追溯到更早的计算机。这些思想也影响了ARM处理器设计。</p>
<p><strong>计算机体系结构</strong></p>
<p>计算机体系结构描述从用户角度看到的计算机。指令集,可见寄存器、存储器管理表结构和异常处理模式都是体系结构的一部分。</p>
<p><strong>计算机组织</strong></p>
<p>计算机组织描述用户不能看到的体系结构的实现方式。流水线结构、透明的Cache(高速缓存)、步行表(table-walking)硬件以及转换后备缓冲(TLB, TranslationLook-aside Bufer)都是计算机组织的问题。</p>
<p><strong>处理器</strong></p>
<p>通用处理器是一个执行存储器中指令的有限状态机。</p>
<p><strong>存储程序计算机</strong></p>
<p>存储程序(stored-program)数字计算机把指令和数据存放在同一个存储器系统中,必要时可以将指令作为数据处理。</p>
<p><strong>简单的处理器</strong></p>
<p>MU0可以由一些基本的部件构成,即<br>程序计数器(PC)寄存器:用来保存当前指令的地址。<br>累加器(ACC)寄存器:用来保存正在处理的数据。<br>算术逻辑单元(ALU):可以对二进制操作数进行若干操作,如加、减、增值等。<br>指令寄存器(IR):保仔当前执行的指令。<br>指令译码器和控制逻辑:它根据指令控制上述部件产生所需的结果。</p>
<p>其中4位为操作码(opceode),12位为地址域(S),最简单的指令集只使用了16种可用操作码中的8种。<br>指令基本都是操作ACC,PC跳转，执行指令。<br>所有不改变PC的指令，占2个时钟周期。<br>1、访问存储器中的操作并执行操作<br>2、读取下一步要执行的指令</p>
<p>指令的演变-》隐含的方式不断发展。如地址指令ADD</p>
<p>1970年单片复杂指令集计算机(CISC, ComplexInstruction Set Computer),这是带有小型计算机指令集的微处理器。而这个指令集义是以有限的可用硅资源为代价的。<br>（1）一个指令多个周期</p>
<p>期间，处理器由比主存储器速度快的微码ROM(只读存储器)控制,因此,将经常使用的操作以微码序列实现,而不使用需要从主仔储器读取几条指令的方式</p>
<p>1980年RISC革命精简指令集计算机(RISC, Reduced Instruction Set Computer)诞生在指令集日益复杂的时候, RISC的概念对ARM处理器的设计有重大影响。<br>（1）一个指令一个周期<br>（2）固定的(32位)指令长度,指令类型很少。而CISC处理器指令集的长度一般可变,指令类型也很多。<br>切勿单以时钟频率来评价处理器。<br>缺点：<br>（1）RISC不能执行x86代码。<br>（2）与CISC相比,通常RISC的代码密度低。</p>
<p>代码密度：同样的一段代码，对于不同的单片机来说，编译之后多数情况下占用的空间是不相同的。占用的空间越大，则说明代码密度越低，反之异然。<br>代码密度低是指令集长度固定的结果,而且当应用领域较宽时,这个问题会更加严重。如果没有Cache,则代码密度低会导致在取指时使用更大的主存储器带宽,造成更高的存储器功耗。当处理器集成一定规模的片上Cache时,代码密度低会导致在任何时候都只有少部分正在工作的指令集能够装入Cache,会降低(ache的命中率,造成对主存储器带宽的需求以及功耗有更大的增长。</p>
<p>ARM处理器是根据RISC原理设计的,但是由于各种原因,在低代码密度问题上它比其他多数RISC要好一些,然而它的代码密度仍然不如某些CISC处理器的。</p>
<p>在代码密度特别重要的场合, ARM公司在某些版本的ARM处理器中,加入了一个称为Thumb结构的新型机构。Thumb指令集是原来32位ARM指令集的16位压缩形式,并在指令流水线中使用了动态解压缩硬件。Thumb代码密度优于多数CISC:处理器达到的代码密度</p>
<p>RISC实际上就是ARM的别名。<br>指令集的发展</p>
<p><strong>处理器做些什么</strong></p>
<p>实际上,它只用很少的时间进行这个意义上的“计算”。尽管它进行相当数量的,算术运算,但是,这些运算多数需要寻址,以便找到相关数据与程序的位置。找到用户的数据后,多数是把它们移来移去,而不是进行转换意义上的处理。(优化对象)</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>动态使用率 (/%)</th>
</tr>
</thead>
<tbody><tr>
<td>数据移动</td>
<td>43</td>
</tr>
<tr>
<td>控制流</td>
<td>23</td>
</tr>
<tr>
<td>算术操作</td>
<td>15</td>
</tr>
<tr>
<td>比较</td>
<td>13</td>
</tr>
<tr>
<td>逻辑操作</td>
<td>5</td>
</tr>
<tr>
<td>其他</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>流水线</strong></p>
<p>处理器按照一系列步骤来执行每一条指令。典型的步骤如下:<br>1)从存储器读取指令(fetch)<br>2)译码以鉴别它是哪一类指令(dec)<br>3)从寄存器堆取得所需的操作数(reg)<br>4)将操作数进行组合以得到结果或存储器地址(ALU)<br>5)如果需要,则访问存储器以存取数据(mem)<br>6)将结果回写到寄存器堆(res)</p>
<p>转移指令—-》流水线冒险–》“写后读”</p>
<p>流水线效率尽管有些技术可以减少这些流水线问题的影响,但是,不能完全消除这些困难。</p>
<p>（1）流水线越深(就是流水线的级数越多),问题就越严重。对于相对简单的处理器,使用3~5级流水线效果会更好。<br>（2）但是,超过了这个级数,收益递减的法则开始生效,增加的成本和复杂度将超过收益。<br>（3）显然,只有当所有指令都依相似的步骤执行时,流水线才能带来好处。如果处理器的指令非常复杂,每一条指令的行为都与下一条指令不同,那么就很难用流水线实现。<br>1980年,因为有限的硅资源、有限的设计资源,以及设计一个复杂指令集的流水线的高度复杂性,当时的复杂指令集微处理器没有采用流水线。<br>（4）流水线的高度复杂性,当时的复杂指令集微处理器没有采用流水线。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile嵌套</title>
    <url>/Makefile-Lover/Makefile%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<p>子嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">cd subdir $ (MAKE)</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">subsystem:</span><br><span class="line"> $ (MAKE)  -C subdir</span><br></pre></td></tr></table></figure>
<p>环境变量的传递与屏蔽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export variable</span><br><span class="line"></span><br><span class="line">unexport variable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表，双链表，循环链表</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>_单链表</strong></p>
<p>单链表的一个优点是结构简单，但是它也有一个缺点，即在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct  Node</span><br><span class="line">&#123;</span><br><span class="line">	Int data;</span><br><span class="line">	Struct Node * next;</span><br><span class="line"></span><br><span class="line">&#125;SList;</span><br><span class="line"></span><br><span class="line">创建: SLIST *SList_Create()  SLIST *pHead, *pM, *pCur</span><br><span class="line">遍历int SList_Print(SLIST *pHead) printf(&quot;%d &quot;, tmp-&gt;data);tmp &#x3D; tmp-&gt;next;</span><br><span class="line">插入	SLIST *pM, *pCur, *pPre; &#x2F;&#x2F;创建新的业务节点pM</span><br><span class="line">删除pPre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">销毁tmp &#x3D; pHead-&gt;next; free(pHead);pHead &#x3D; tmp;</span><br><span class="line">反序：	t &#x3D; q-&gt;next; &#x2F;&#x2F;缓冲后面的链表</span><br><span class="line">		q-&gt;next &#x3D; p;	&#x2F;&#x2F;逆置</span><br><span class="line">		p &#x3D; q; &#x2F;&#x2F;让p下移一个结点</span><br><span class="line">		q &#x3D; t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">#define  _CRT_SECURE_NO_WARNINGS </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;SLIST;</span><br><span class="line">SLIST *SList_Create(); &#x2F;&#x2F;创建链表</span><br><span class="line">int SList_Print(SLIST *pHead); &#x2F;&#x2F;遍历链表</span><br><span class="line">int SList_NodeInsert(SLIST *pHead, int x, int y); &#x2F;&#x2F;插入值  在x值之前 删除y</span><br><span class="line">int SList_NodeDel(SLIST *pHead, int y);</span><br><span class="line">int SList_Destory(SLIST *pHead);</span><br><span class="line">SLIST *SList_Create()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	SLIST *pHead, *pM, *pCur;</span><br><span class="line">	int		data;</span><br><span class="line">	&#x2F;&#x2F;创建头节点 并初始化</span><br><span class="line">	pHead &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	pHead-&gt;data &#x3D; 0;</span><br><span class="line">	pHead-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\nplease enter you data: &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line"></span><br><span class="line">	pCur &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">	while (data !&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;创建业务节点 并初始化 不断接受输入 malloc新结点</span><br><span class="line">		pM &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">		if (pM &#x3D;&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		pM-&gt;data &#x3D; data;</span><br><span class="line">		pM-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;2 新结点 入链表 </span><br><span class="line">		pCur-&gt;next &#x3D; pM;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;3 新结点变成当前节点</span><br><span class="line">		pCur &#x3D; pM;  &#x2F;&#x2F;链表结点的尾部追加 </span><br><span class="line"></span><br><span class="line">		printf(&quot;\nplease enter you data: &quot;);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br><span class="line">int SList_Print(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *tmp &#x3D; NULL;</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp &#x3D; pHead-&gt;next;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\nBegin\t&quot;);</span><br><span class="line">	while (tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, tmp-&gt;data);</span><br><span class="line">		tmp &#x3D; tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\tEnd&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_NodeInsert(SLIST *pHead, int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *pM, *pCur, *pPre;</span><br><span class="line">	&#x2F;&#x2F;创建新的业务节点pM</span><br><span class="line">	pM &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">	if (pM &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pM-&gt;next &#x3D; NULL;</span><br><span class="line">	pM-&gt;data &#x3D; y;</span><br><span class="line">	&#x2F;&#x2F;遍历链表</span><br><span class="line">	pPre &#x3D; pHead;</span><br><span class="line">	pCur &#x3D; pHead-&gt;next;</span><br><span class="line"></span><br><span class="line">	while (pCur)</span><br><span class="line">	&#123;</span><br><span class="line">		if (pCur-&gt;data &#x3D;&#x3D; x)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		pPre &#x3D; pCur;</span><br><span class="line">		pCur &#x3D; pCur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;让新结点 连接 后续链表</span><br><span class="line">	pM-&gt;next &#x3D; pPre-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;让前驱节点 连接 新结点</span><br><span class="line">	pPre-&gt;next &#x3D; pM;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_NodeDel(SLIST *pHead, int y)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST  *pCur, *pPre;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化状态</span><br><span class="line"></span><br><span class="line">	pPre &#x3D; pHead;</span><br><span class="line">	pCur &#x3D; pHead-&gt;next;</span><br><span class="line">	while(pCur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		if (pCur-&gt;data &#x3D;&#x3D; y)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		pPre &#x3D; pCur;</span><br><span class="line">		pCur &#x3D; pCur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除操作</span><br><span class="line">	if (pCur &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;没有找到结点值为:%d 的结点\n&quot;, y);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pPre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">	if (pCur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		free(pCur);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_Destory(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *tmp &#x3D; NULL;</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while (pHead !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp &#x3D; pHead-&gt;next;</span><br><span class="line">		free(pHead);</span><br><span class="line">		pHead &#x3D; tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_Reverse(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST	*p &#x3D; NULL; &#x2F;&#x2F;前驱指针</span><br><span class="line">	SLIST	*q &#x3D; NULL; &#x2F;&#x2F;当前指针</span><br><span class="line">	SLIST	*t &#x3D; NULL; &#x2F;&#x2F;缓存的一个结点</span><br><span class="line">	if (pHead&#x3D;&#x3D;NULL || pHead-&gt;next &#x3D;&#x3D; NULL ||pHead-&gt;next-&gt;next &#x3D;&#x3D;NULL )</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;初始化 	&#x2F;&#x2F;前驱结点</span><br><span class="line">	p &#x3D; pHead-&gt;next;</span><br><span class="line">	q &#x3D; pHead-&gt;next-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;p &#x3D; pHead;  &#x2F;&#x2F;代码能兼容</span><br><span class="line">	&#x2F;&#x2F;q &#x3D; pHead-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;一个结点 一个结点的逆置</span><br><span class="line">	while(q)</span><br><span class="line">	&#123;</span><br><span class="line">		t &#x3D; q-&gt;next; &#x2F;&#x2F;缓冲后面的链表</span><br><span class="line">		q-&gt;next &#x3D; p;	&#x2F;&#x2F;逆置</span><br><span class="line">		p &#x3D; q; &#x2F;&#x2F;让p下移一个结点</span><br><span class="line">		q &#x3D; t;</span><br><span class="line">	&#125; </span><br><span class="line">	&#x2F;&#x2F;头节点 变成 尾部结点 后  置null</span><br><span class="line">	pHead-&gt;next-&gt;next &#x3D; NULL;  &#x2F;&#x2F;尾部置为NULL</span><br><span class="line">	pHead-&gt;next &#x3D; p;  &#x2F;&#x2F;头部连接</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int  ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	SLIST *pHead &#x3D; NULL;</span><br><span class="line">	pHead &#x3D; SList_Create();</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; SList_NodeInsert(pHead, 20, 19);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; SList_NodeDel(pHead, 19);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D;  SList_Reverse(pHead);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	SList_Destory(pHead);</span><br><span class="line"></span><br><span class="line">	printf(&quot;hello...\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双链表</strong></p>
<p>其中一个是头结点，另一个是尾结点，它们都不存放数据元素，<br>头结点的pre 为空，而尾结点的 Next 为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DouLinkNode &#123;</span><br><span class="line">    int data ;               &#x2F;&#x2F;链表中存放的数据，可以自定义数据结构 </span><br><span class="line">    struct DouLinkNode *pre ,*next;</span><br><span class="line">&#125;;</span><br><span class="line">struct DouLinkNode *create(int n)</span><br><span class="line">&#123;   </span><br><span class="line">    int x;</span><br><span class="line">    struct DouLinkNode *head &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    struct DouLinkNode *p,*s;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    p-&gt;pre &#x3D; NULL;</span><br><span class="line">    while(n)</span><br><span class="line">	&#123;</span><br><span class="line">        s &#x3D; (struct DouLinkNode*)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">        printf(&quot;input data of the node:data&#x3D;&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        s-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; s;</span><br><span class="line">        s-&gt;pre &#x3D; p;</span><br><span class="line">        p &#x3D; s;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next &#x3D; NULL;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;* 双向链表打印 *&#x2F;</span><br><span class="line">void display(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p &#x3D; head-&gt;next;</span><br><span class="line">    while(p-&gt;next) &#123;</span><br><span class="line">        printf(&quot;%d &lt;---&gt; &quot;,p-&gt;data);</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d \n&quot;,p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 链表头插节点 *&#x2F;&#x2F;&#x2F;头插法  第二个</span><br><span class="line">void insertListHead(struct DouLinkNode *pList, int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    pNode-&gt;next &#x3D; pList-&gt;next;</span><br><span class="line">    pNode-&gt;pre &#x3D; pList;</span><br><span class="line">    if (NULL !&#x3D; pNode-&gt;next) &#123;</span><br><span class="line">        pNode-&gt;next-&gt;pre &#x3D; pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    pList-&gt;next &#x3D; pNode;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 链表尾插节点 *&#x2F; </span><br><span class="line">void insertListTail(struct DouLinkNode *pList, int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList; </span><br><span class="line">    while(NULL !&#x3D; pCur-&gt;next) &#123;</span><br><span class="line">        pCur &#x3D; pCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pCur-&gt;next &#x3D; pNode;</span><br><span class="line">    pNode-&gt;pre &#x3D; pCur;</span><br><span class="line">    pNode-&gt;next &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 在链表的指定位置插入节点: index &#x3D; 0 ---&gt; 头插； index &#x3D; length ---&gt; 尾插 *&#x2F;</span><br><span class="line">int insertList(struct DouLinkNode *pList, int data, int index)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList; </span><br><span class="line">    int len &#x3D;  get_List_Length(pCur);</span><br><span class="line">    if(index &gt; len) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        insertListHead(pList, data);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(index &#x3D;&#x3D; len) &#123;</span><br><span class="line">        insertListTail(pList, data);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    pCur &#x3D; pList;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while( index--) &#123;</span><br><span class="line">        pCur &#x3D; pCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">    pCur-&gt;next &#x3D; pNode;</span><br><span class="line">    pNode-&gt;pre &#x3D; pCur;</span><br><span class="line">    pNode-&gt;next-&gt;pre &#x3D; pNode;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除链表中的指定值 *&#x2F;</span><br><span class="line">int deleteListNode(struct DouLinkNode *pList, int key)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pPre &#x3D; pList;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList-&gt;next;</span><br><span class="line">    int count &#x3D; 0; &#x2F;&#x2F;记录删除节点个数 </span><br><span class="line">    while(NULL!&#x3D;pCur) &#123;</span><br><span class="line">        if(pCur-&gt;data &#x3D;&#x3D; key) &#123;</span><br><span class="line">            if(NULL !&#x3D; pCur-&gt;next) &#123;</span><br><span class="line">                pCur-&gt;next-&gt;pre &#x3D; pCur-&gt;pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pCur-&gt;pre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">            pPre &#x3D; pCur; </span><br><span class="line">            pCur &#x3D; pCur-&gt;next;</span><br><span class="line">            free(pPre);</span><br><span class="line">            count ++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pPre &#x3D; pCur;</span><br><span class="line">            pCur &#x3D; pCur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 链表求长 *&#x2F;</span><br><span class="line">int get_List_Length(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    for (p; p-&gt;next!&#x3D;NULL; p&#x3D;p-&gt;next) &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 双向链表排序 *&#x2F;</span><br><span class="line">struct DouLinkNode *sort(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p,*s,*min;</span><br><span class="line">    int tmp;</span><br><span class="line"></span><br><span class="line">    for(p &#x3D; head-&gt;next ;p-&gt;next!&#x3D;NULL ;p&#x3D;p-&gt;next) &#123;</span><br><span class="line">        min &#x3D; p ;</span><br><span class="line">        for(s&#x3D; p-&gt;next ; s!&#x3D;NULL ;s&#x3D;s-&gt;next) &#123;</span><br><span class="line">            if(s-&gt;data &lt;min-&gt;data)</span><br><span class="line">                min &#x3D; s;               &#x2F;&#x2F;找到每次排序中最小的节点，然后记住这个节点</span><br><span class="line">        &#125; if(min !&#x3D; p) &#123;               &#x2F;&#x2F;把这个节点与前面的节点的数据进行交换，把最小的数据放在前面的节点内。</span><br><span class="line">            tmp &#x3D; min-&gt;data;</span><br><span class="line">            min-&gt;data &#x3D; p-&gt;data;</span><br><span class="line">            p-&gt;data &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环链表</strong></p>
<p>特点：”无头无尾”。</p>
<p>单循环链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：网络</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;约瑟夫环问题   环状链</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef struct node </span><br><span class="line">&#123;	</span><br><span class="line">	int number;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;person ;</span><br><span class="line">person *initlink(int n)</span><br><span class="line">&#123;</span><br><span class="line">	person *head &#x3D;(person*)malloc(sizeof(person));</span><br><span class="line">	head-&gt;number &#x3D;1;</span><br><span class="line">	head-&gt;next &#x3D;NULL;</span><br><span class="line">	person *cyclic &#x3D;head;</span><br><span class="line">	int i;</span><br><span class="line">	for (i&#x3D;2 ; i &lt;&#x3D; n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		person* body &#x3D; (person*)malloc(sizeof(person));</span><br><span class="line">		body-&gt;number &#x3D; i ;</span><br><span class="line">		body-&gt;next &#x3D; NULL;</span><br><span class="line">		cyclic-&gt;next &#x3D; body;</span><br><span class="line">		cyclic &#x3D; cyclic-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cyclic-&gt;next &#x3D;head;&#x2F;&#x2F;呈环状</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">void findAndKillK(person * head,int k,int m)</span><br><span class="line">&#123; </span><br><span class="line">	person * tail&#x3D;head;   &#x2F;&#x2F;找到链表第一个结点的上一个结点</span><br><span class="line">	while(tail-&gt;next !&#x3D; head)&#123;tail&#x3D;tail-&lt;next;&#125;&#x2F;&#x2F;找到链表第一个结点的上一个结点，为删除操作做准备 </span><br><span class="line">	</span><br><span class="line">	person *p &#x3D; head ;</span><br><span class="line">	while(p-&gt;number!&#x3D; k) &#x2F;&#x2F;找到k编号</span><br><span class="line">	&#123;</span><br><span class="line">		tail&#x3D;p;</span><br><span class="line">		p&#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(p-&gt;next !&#x3D; p) &#x2F;&#x2F;剩最后一个</span><br><span class="line">	&#123;</span><br><span class="line">		int i ;</span><br><span class="line">		for(i &#x3D;1 ;i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tail &#x3D; p;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tail-&gt;next &#x3D; p-&gt;next;&#x2F;&#x2F;摘除</span><br><span class="line">		printf(&quot;出列：%d\n&quot;,p-&gt;number);</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; tail-&gt;next; &#x2F;&#x2F;下一个为第一个</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		printf(&quot;出列：%d\n&quot;,p-&gt;number); &#x2F;&#x2F;最后一个</span><br><span class="line">		free(p);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">int main() </span><br><span class="line">	&#123;</span><br><span class="line">    printf(&quot;输入圆桌上的人数n:&quot;);</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    person * head&#x3D;initLink(n);</span><br><span class="line">    printf(&quot;从第k人开始报数(k&gt;1且k&lt;%d)：&quot;,n);</span><br><span class="line">    int k;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">    printf(&quot;数到m的人出列：&quot;);</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    findAndKillK(head, k, m);</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链循环链表：略</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>炫酷的图片来源QAQ</title>
    <url>/QT-Lover/%E7%82%AB%E9%85%B7%E7%9A%84%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90QAQ/</url>
    <content><![CDATA[<p>JPG的图片格式是有损的，优点是有更丰富的色彩，非常适合来存储照片，用来表达更生动的图像效果，比如颜色渐变。<br>PNG格式的图片是无损的，而且PNG-8格式是GIF格式的非常好的替代者，在达到相同效果的情况下，PNG-8格式体积更小，而且支持透明度的调节。<br>SVG格式的图片是无损的矢量图。在放大的不会失真，适合绘制企业logo，icon等。</p>
<p>有损压缩是对图像本身的改变,在保存图像时保留了较多的亮度信息,而将色相和色纯度的信息和周围的像素进行合并,合并的比例不同,压缩的比例也不同,由于信息量减少了,所以压缩比可以很高,图像质量也会相应的下降。<br>无损压缩是对文件本身的压缩,和其它数据文件的压缩一样,是对文件的数据存储方式进行优化。</p>
<p>图标网站：Iconfont：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p>
<p>一位大佬的博客：<a href="https://cloud.tencent.com/developer/article/1631262" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1631262</a></p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT上执行shell</title>
    <url>/QT-Lover/T%E4%B8%8A%E6%89%A7%E8%A1%8Cshell/</url>
    <content><![CDATA[<p>1、脚本echo输出的内容得通过connect调用函数获取。<br>2、start/execute 调用的时候脚本就开始了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QProcess&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include&lt;QList&gt;</span><br><span class="line">#include&lt;QStringList&gt;</span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~Widget();</span><br><span class="line">   &#x2F;&#x2F; void executeShellQProcess(QString str);</span><br><span class="line"></span><br><span class="line">         QString shellOutput;</span><br><span class="line">private slots:</span><br><span class="line">         void executeShellQProcess();</span><br><span class="line">         void readProcess();</span><br><span class="line">         void finishedProcess();</span><br><span class="line">         void on_pushButton_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QProcess *runShellProcess;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include&lt;QProcess&gt;</span><br><span class="line">#include&lt;QDir&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line">    runShellProcess &#x3D; new QProcess(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        connect(runShellProcess, SIGNAL(readyRead()), this, SLOT(readProcess()));</span><br><span class="line">      &#x2F;&#x2F;  connect(runShellProcess, SIGNAL(finished(int)), this, SLOT(finishedProcess()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void Widget::executeShellQProcess()&#123;</span><br><span class="line">    shellOutput&#x3D;&quot;&quot;;</span><br><span class="line">    QString filename &#x3D; QCoreApplication::applicationDirPath();</span><br><span class="line">    qDebug()&lt;&lt;filename;</span><br><span class="line">    QDir::setCurrent(filename);</span><br><span class="line">    runShellProcess-&gt;start( &quot;.&#x2F;test.sh&quot;);</span><br><span class="line">    &#x2F;&#x2F; runShellProcess-&gt;execute( &quot;.&#x2F;test.sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::readProcess()&#123;</span><br><span class="line">    QString output&#x3D;runShellProcess-&gt;readAll();</span><br><span class="line">      shellOutput+&#x3D;output;</span><br><span class="line">      &#x2F;&#x2F;qDebug()&lt;&lt;&quot;shellOutput1&quot;&lt;&lt;endl;</span><br><span class="line">     &#x2F;&#x2F;do something</span><br><span class="line">       qDebug()&lt;&lt;shellOutput&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::finishedProcess()&#123;</span><br><span class="line">     qDebug()&lt;&lt;shellOutput&lt;&lt;endl;</span><br><span class="line">     &#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    executeShellQProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull亮度调节</title>
    <url>/Linux-Lover/imx6ull%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82/</url>
    <content><![CDATA[<p>设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为<br>0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%<br>actual_brightness：这个节点只读，可以通过读取这个节点，获取 LCD 实际的亮度值。<br>brightness：这个节点可读可写，向这个节点写入不同值（0-7），可调节 LCD 亮度。<br>max_brightness：这个节点只读，通过读取此节点</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title> imx6ull点灯测试</title>
    <url>/Linux-Lover/imx6ull%E7%82%B9%E7%81%AF%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>echo “out” &gt; /sys/class/gpio/gpio130/direction #控制为输出<br>echo “in” &gt; /sys/class/gpio/gpio130/direction #控制为输入<br>echo “1” &gt; /sys/class/gpio/gpio130/value #输出为高电平<br>echo “0” &gt; /sys/class/gpio/gpio130/value #输出为低电平</p>
<p>brightness 节点用来控制 LED 的亮灭，通过对 brightness 节点写入 0 或 1，可以控制 LED 的亮灭状态。<br>trigger 支持的状态值有：rc-feedback, nand-disk, mmc0, timer,oneshot, heartbeat, backlight, gpio.</p>
<p>测试中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LED1_BRIGHTNESS    &quot;&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;dtsleds&#x2F;leds&#x2F;red&#x2F;brightness&quot;</span><br><span class="line">#define LED1_TRIGGER       &quot;&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;dtsleds&#x2F;leds&#x2F;red&#x2F;trigger&quot;</span><br><span class="line">#define TRIGGER_NONE          &quot;none&quot;</span><br><span class="line">#define TRIGGER_HEARTBEAT     &quot;heartbeat&quot;</span><br></pre></td></tr></table></figure>

<p>视频</p>
<iframe src="//player.bilibili.com/player.html?aid=883253911&bvid=BV1jK4y1t7iz&cid=197202487&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"
height="600" width="100%" > </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>i.MX6UL芯片上电过程分析</title>
    <url>/Linux-Lover/i-MX6UL%E8%8A%AF%E7%89%87%E4%B8%8A%E7%94%B5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>参考来源：公众号【微联智控】<br>参考来源：正点原子<br><strong>误区</strong></p>
<p>芯片一上电的时候，首先执行的程序是类似 u-boot 之类的 BootLoader，或者是单片机程序里面类似于 xxxx_start_up.S 的启动文件，更有很多单片机工程师认为，芯片一上电就去执行 main()函数。</p>
<p><strong>事实</strong></p>
<p>大部分嵌入式处理器芯片一上电的时候，首先执行的既不是 BootLoader，也不是执行类似于 xxxx_start_up.S 的启动文件。而是执行一段开发者看不见摸不着的程序，通常把这段程序称为 BootROM。这段程序在嵌入式处理器芯片生产设计的时候就被芯片设计厂家固化在芯片里面，开发者作为使用芯片的角色，不需要获得 BootROM 的源码，也不需要对 BootROM 源码进行改写。</p>
<p>（1）Image Vector Table —— 镜像向量表，简称 IVT，位于固定地址的指针列表，ROM 检<br>查该列表以确定程序映像的其他组件所在的位置。<br>（2）Boot Data —— 表示程序镜像的位置，镜像大小，以及插件标志。<br>（3）Device Configuration Data —— 表示芯片 IC 的初始化数据。<br>（4）User Code and Data —— 用户代码和数据</p>
<p>以 SD/EMMC 为例，IVT 偏移为 1Kbyte，IVT+Boot data+DCD 的总大小为 4KByte-<br>1KByte=3KByte。<br>IVT+Boot data+DCD+.bin</p>
<p>参考：<a href="https://www.cnblogs.com/yuanqiangfei/p/10225138.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanqiangfei/p/10225138.html</a></p>
<p>Efuse类似于EEPROM，是一次性可编程存储器，在芯片出场之前会被写入信息，在一个芯片中，efuse的容量通常很小，一些芯片efuse只有128bit。<br>28bit的efuse包含芯片电压字段、芯片版本号、芯片生产日期以及其他信息。<br>芯片在初次上电过程中会读取efuse中的电压字段数值，送到芯片外部的电源管理器，电源管理器在芯片初始上电前会提供一个标准的电压（假设为1.0v），在接受到efuse中的电压字段数值后会调节电压大小。完成电源电压调整后，芯片会重新进行上电复位操作。</p>
<img src="/Linux-Lover/i-MX6UL%E8%8A%AF%E7%89%87%E4%B8%8A%E7%94%B5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/%E4%B8%8A%E7%94%B5%E5%90%AF%E5%8A%A8.jpg" class="">


<p>总的来说，i.MX6UL这款芯片的BootROM的主要功能是，根据内部eFUSES或者外部GPIO<br>的状态，来判断芯片从哪里（可以是 SD 卡，NandFlash，eMMC 等）加载启动镜像，然后再<br>从启动镜像获取芯片的初始化方式（启动镜像 u-boot.imx 就是 u-boot.bin + header 数据的集<br>合，这个 header 数据就是提供给芯片的 BootROM 使用的），最后通过绝对地址，跳转到启<br>动镜像那里，执行第一句用户程序指令（通常是 u-boot 里面的_start 函数，通过 u-boot.lds<br>链接脚本，可以看到 u-boot 的第一个函数入口，接下来才是 u-boot 的启动过程）。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>截屏工具gsnap移植</title>
    <url>/Linux-Lover/gsnap%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>参考：微联智控</p>
<p>截屏工具 gsnap 的移植，需要依赖以下库文件：libpng、libjpeg、zlib、libmath。<br>libmath 由于交叉编译器自带，因此 libmath 可以不用移植。</p>
<p>创建：/opt/work/tools/gsnap<br>基本配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CC&#x3D;arm-linux-gnueabihf-gcc   &#x2F;&#x2F;编译器</span><br><span class="line"># .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;work&#x2F;tools&#x2F;gsnap&#x2F;xxx_install   &#x2F;&#x2F;安装路径</span><br></pre></td></tr></table></figure>

<p>把生成的lib、iclude放到 gsnap_install/lib 目录下的动态库复制到开发板的/lib 目录</p>
<p>可以进行屏幕截图：gsnap fb.jpg /dev/fb0</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>shell进阶命令</title>
    <url>/shell-Lover/shell%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>find命令</p>
<p>常用<br>1、查找当前用户主目录下的所有文件：<br>$ find $HOME -print<br>$ find ~ -print</p>
<p>2、查找系统中最后N分钟被改变文件数据的文件</p>
<p>$find -mmin n<br>在系统根目录下查找更改时间在5日以内的文件，可以用：<br>$ find / -mtime -5 -print</p>
<p>find和Xargs<br>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>
<p>awk命令</p>
<p>awk ‘{print $NF}’ file.txt<br>print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段</p>
<p>awk ‘NR==10’ file.txt</p>
<p>awk两种特殊模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN (初始化)和 END(输出)</span><br><span class="line"># 转置</span><br><span class="line">awk &#39;</span><br><span class="line">  &#123;</span><br><span class="line"> for(i&#x3D;1;i&lt;&#x3D;NF;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if( NR &#x3D;&#x3D; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i] &#x3D; $i</span><br><span class="line">                &#125;   </span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i]&#x3D;res[i]&quot; &quot;$i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">END &#123;</span><br><span class="line">    for(j &#x3D; 1; j&lt;&#x3D; NF  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">       print res[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#39;     file.txt</span><br></pre></td></tr></table></figure>











<p>sed命令<br> 通过文件或管道读取文件内容。</p>
<ul>
<li>sed并不直接修改源文件，而是将读入的内容复制到缓冲区中，我们称之为模式空间（pattern space）。</li>
<li>根据sed的指令对模式空间中的内容进行处理并输出结果，默认输出至标准输出即屏幕上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 这里就简单介绍几个脚本指令操作作为sed程序的例子。</span><br><span class="line">    a,append        追加</span><br><span class="line">    i,insert        插入</span><br><span class="line">    d,delete        删除</span><br><span class="line">    s,substitution  替换</span><br><span class="line">    </span><br><span class="line">查找替换应用举例</span><br><span class="line">sed  &#39;2a TYPE&#x3D;Ethernet&#39;  test.txt    第二行后添加新行TYPE&#x3D;Ethernet</span><br><span class="line">sed  &#39;3i  TYPE&#x3D;Ethernet&#39;  test.txt   第三行前添加新行  TYPE&#x3D;Ethernet</span><br><span class="line">sed  &#39;s&#x2F;yes&#x2F;no&#x2F;g&#39;     test.txt       将样本文件中的所有yes替换为no</span><br><span class="line">sed  &#39;3,4d&#39;  test.txt                删除第3至4行的内容</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>shell流程语句小记</title>
    <url>/shell-Lover/shell%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>if then else语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种格式：</span><br><span class="line">if 条件</span><br><span class="line">then 命令</span><br><span class="line">fi</span><br><span class="line">例子：</span><br><span class="line">if [ &quot;13&quot; -lt &quot;12&quot; ]  # &quot;13&quot; 前一个空格，“13”后也有一个空格。</span><br><span class="line">then</span><br><span class="line">        echo &quot;yes 13 is less then 12&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;NO&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二种格式：</span><br><span class="line"></span><br><span class="line">if 条件1</span><br><span class="line">then </span><br><span class="line">     命令1</span><br><span class="line">elif 条件2</span><br><span class="line">then </span><br><span class="line">     命令2</span><br><span class="line">else</span><br><span class="line">     命令3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>case多选择语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式值)</span><br><span class="line">	命令1</span><br><span class="line">	;;</span><br><span class="line">模式值)</span><br><span class="line">	命令2</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>





<p>for循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for i in 1 2 3 4 5 </span><br><span class="line">do </span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>until循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until 条件</span><br><span class="line">do	</span><br><span class="line">	命令1</span><br><span class="line">	命令2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>while循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line">#while01</span><br><span class="line">echo &quot;ctrl+d quit&quot; </span><br><span class="line">while echo -n &quot;please enter you name:&quot;; read Name  </span><br><span class="line">do</span><br><span class="line">        echo &quot;Yeah, you name: $Name&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>break<br>退出循环,如果是在一个嵌入循环里，可以指定n来跳出循环个数<br>continue<br>跳出循环步</p>
]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>了解ESP8266</title>
    <url>/MCU-Lover/ESP8266/</url>
    <content><![CDATA[<p>参考连接;<a href="https://www.bilibili.com/video/BV1dJ411S723?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dJ411S723?p=1</a><br><a href="https://www.espressif.com/zh-hans" target="_blank" rel="noopener">https://www.espressif.com/zh-hans</a><br><strong>IOT物联网</strong></p>
<p>物联网（The Internet of Things，简称IOT）是指通过 各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。物联网是一个基于互联网、传统电信网等的信息承载体，它让所有能够被独立寻址的普通物理对象形成互联互通的网络 [1]  。</p>
<img src="/MCU-Lover/ESP8266/%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F.jpg" class="">

<p>阿里云、腾讯云</p>
<p>百度云：<a href="https://console.bce.baidu.com/#/index/overview" target="_blank" rel="noopener">https://console.bce.baidu.com/#/index/overview</a></p>
<img src="/MCU-Lover/ESP8266/MQTT.jpg" class="">


<p><strong>ESP8266</strong></p>
<p>IPv4, TCP/UDP/HTTP/FTP<br>用户配置<br>AT+ 指令集, 云端服务器, Android/iOS APP</p>
<p>AT指令<br>SDK编程</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/shell-Lover/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>正则表达式</strong></p>
<p>概念：一种用来描述文本模式的特殊语法<br>由普通字符（例如：字符a到z），以及特殊字符（元字符，如/ * ？等）组成匹配的字符串<br>文本过滤工具在某种模式之下，都支持正则表达式。</p>
<p>基本元字符集及其含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pattern\&#123;n\&#125;    n为pattern 前面出现次数</span><br><span class="line">pattern\&#123;n,\&#125;m       n为pattern 前面出现最少次数</span><br><span class="line"> pattern\&#123;n,m\&#125;        n为pattern 前面出现n-m</span><br><span class="line"> </span><br><span class="line">A\&#123;3\&#125;B   AAAB    </span><br><span class="line">A\&#123;3,\&#125;B AAAB AAAAB ...</span><br><span class="line">A\&#123;3,5\&#125;B AAAB AAAAB AAAAAB </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行首以^匹配字符串或字符序列</span><br><span class="line">行尾以$匹配字符串或字符</span><br><span class="line">用*$匹配单字符串或其重复序列</span><br><span class="line">使用\屏蔽一个特殊字符的含义:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
  </entry>
  <entry>
    <title>QT-数据库操作</title>
    <url>/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>sqlite数据库(本地数据库）</p>
<img src="/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/1.jpg" class="">

<img src="/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/2.jpg" class="">


<p>QT-Mysql数据库<br>QT+ = core gui sl</p>
<p>QT 32 位，数据库64 位经常连接不成功。</p>
<p>MySQL Product Archives</p>
<p><a href="https://downloads.mysql.com/archives/c-c/" target="_blank" rel="noopener">https://downloads.mysql.com/archives/c-c/</a>  下载 6.0 版本</p>
<p>把lib加入QT的bin目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QtSql&#x2F;QSqlDatabase&gt;</span><br><span class="line">#include &lt;QMessageBox&gt;</span><br><span class="line">#include &lt;QSqlError&gt;</span><br><span class="line">#include &lt;QSqlQuery&gt;</span><br><span class="line">#include &lt;QVariantList&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;打印支持数据库类型</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;qDebug()&lt;&lt;QSqlDatabase::drivers();</span><br><span class="line">   &#x2F;&#x2F;添加MYSQL数据库</span><br><span class="line">   QSqlDatabase db&#x3D;    QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</span><br><span class="line">   &#x2F;&#x2F;连接</span><br><span class="line">   db.setHostName(&quot;localhost&quot;);&#x2F;&#x2F;主机名</span><br><span class="line">   db.setUserName(&quot;root&quot;);   &#x2F;&#x2F; 用户名</span><br><span class="line">   db.setPassword(&quot;861459&quot;);  &#x2F;&#x2F;密码</span><br><span class="line">   db.setDatabaseName(&quot;world&quot;);  &#x2F;&#x2F;数据库表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;打开数据库</span><br><span class="line">   if (!db.open())</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       QMessageBox::warning(this,&quot;错误&quot;,db.lastError().text());</span><br><span class="line">       return ;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">  QMessageBox::warning(this,&quot;成功&quot;,db.lastError().text());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   QSqlQuery query(db);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age) values(1, &#39;mike&#39;, 18); &quot;);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age, score) values(2, &#39;lucy&#39;, 22, 90);&quot;);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age, score) values(3, &#39;Tom&#39;, 20, 78);&quot;);</span><br><span class="line">&#x2F;&#x2F;obdc风格处理  顺序执行</span><br><span class="line">   query.exec(&quot;create table student(id int primary key auto_increment, name varchar(255), age int, score int);&quot;);</span><br><span class="line"></span><br><span class="line">   query.prepare(&quot;insert into student( name, age, score) values( ?, ?, ?)&quot;);</span><br><span class="line"></span><br><span class="line">    QVariantList namelist;</span><br><span class="line">   namelist&lt;&lt;&quot;xiaoming&quot;&lt;&lt;&quot;xiaozhag&quot;&lt;&lt;&quot;xiaolin&quot;;</span><br><span class="line">   QVariantList agelist;</span><br><span class="line">   agelist&lt;&lt;11&lt;&lt;22&lt;&lt;33;</span><br><span class="line">   QVariantList scorelist;</span><br><span class="line">   scorelist&lt;&lt;59&lt;&lt;69&lt;&lt;79;</span><br><span class="line">   query.addBindValue(namelist);</span><br><span class="line">   query.addBindValue(agelist);</span><br><span class="line">   query.addBindValue(scorelist);</span><br><span class="line"></span><br><span class="line">   query.execBatch();&#x2F;&#x2F;执行预处理</span><br><span class="line">   query.exec(&quot; update student set score &#x3D; 90 where id &#x3D; 3;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   connect(this,&amp;Widget::destroyed,[&#x3D;]()&#123;</span><br><span class="line">QSqlQuery query(db);</span><br><span class="line">       query.exec(&quot;drop table student;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;多个库的调用注意事项</span><br><span class="line">&#x2F;&#x2F;   QSqlDatabase db1&#x3D;    QSqlDatabase::addDatabase(&quot;QMYSQL&quot;,&quot;a&quot;);&#x2F;&#x2F;a当做标识符号</span><br><span class="line">&#x2F;&#x2F;   &#x2F;&#x2F;连接</span><br><span class="line">&#x2F;&#x2F;   db1.setHostName(&quot;localhost&quot;);&#x2F;&#x2F;主机名</span><br><span class="line">&#x2F;&#x2F;   db1.setUserName(&quot;root&quot;);   &#x2F;&#x2F; 用户名</span><br><span class="line">&#x2F;&#x2F;   db1.setPassword(&quot;861459&quot;);  &#x2F;&#x2F;密码</span><br><span class="line">&#x2F;&#x2F;   db1.setDatabaseName(&quot;world&quot;);  &#x2F;&#x2F;数据库表</span><br><span class="line">&#x2F;&#x2F;   if (!db1.open())</span><br><span class="line">&#x2F;&#x2F;   &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;       QMessageBox::warning(this,&quot;错误&quot;,db1.lastError().text());</span><br><span class="line">&#x2F;&#x2F;       return ;</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F;   else</span><br><span class="line">&#x2F;&#x2F;   &#123;</span><br><span class="line">&#x2F;&#x2F;  QMessageBox::warning(this,&quot;成功&quot;,db1.lastError().text());</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F;   QSqlQuery query1(db1);&#x2F;&#x2F;进行关联</span><br><span class="line">&#x2F;&#x2F;   query1.exec(&quot;create table student(id int primary key auto_increment, name varchar(255), age int, score int); create table student(id int primary key, name varchar(255), age int, score int);&quot;);</span><br><span class="line"></span><br><span class="line">query.exec(&quot;select * from student;&quot;);</span><br><span class="line">while(query.next())&#x2F;&#x2F;一行一行 没有内容返回假的</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;取内容</span><br><span class="line">   qDebug()&lt;&lt; query.value(0).toInt()</span><br><span class="line">           &lt;&lt;query.value(1).toString()</span><br><span class="line">          &lt;&lt;query.value(&quot;age&quot;).toInt()</span><br><span class="line">         &lt;&lt;query.value(&quot;score&quot;).toInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取内容</span><br><span class="line">    QString name&#x3D;lineEdit-&gt;text();</span><br><span class="line"></span><br><span class="line">    QString str&#x3D;QString(&quot;delete from student where name &#x3D; &#39;%1&#39;;&quot;).arg(name);</span><br><span class="line">   &#x2F;&#x2F;开启事务</span><br><span class="line">    QSqlDatabase::database().transaction();</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.exec(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_2_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;确定删除</span><br><span class="line">    QSqlDatabase::database().commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_3_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;回滚</span><br><span class="line">     QSqlDatabase::database().rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-传输文件</title>
    <url>/QT-Lover/QT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<img src="/QT-Lover/QT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/1.jpg" class="">


<p>定时发送，防止粘包。。。</p>
<p>client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef CLIENTWIDGET_H</span><br><span class="line">#define CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_clientwidget.h&quot;</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include &lt;QTcpSocket&gt;</span><br><span class="line"></span><br><span class="line">class clientWidget : public QWidget, private Ui::clientWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit clientWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QTcpSocket *tcpSocket; &#x2F;&#x2F;通信套接字</span><br><span class="line">    QFile file; &#x2F;&#x2F;文件对象</span><br><span class="line">    QString fileName; &#x2F;&#x2F;文件名字</span><br><span class="line">    qint64 fileSize; &#x2F;&#x2F;文件大小</span><br><span class="line">    qint64 recvSize; &#x2F;&#x2F;已经发送文件的大小</span><br><span class="line"></span><br><span class="line">     bool    isStart;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonconect_clicked();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"></span><br><span class="line">#include &quot;clientwidget.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QMessageBox&gt;</span><br><span class="line">#include &lt;QHostAddress&gt;</span><br><span class="line">clientWidget::clientWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    tcpSocket&#x3D;new QTcpSocket (this);</span><br><span class="line">    setWindowTitle(&quot;客户端&quot;);</span><br><span class="line">        isStart&#x3D;true;</span><br><span class="line"></span><br><span class="line">        this-&gt;progressBar-&gt;setValue(0); &#x2F;&#x2F;当前值</span><br><span class="line"></span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        QByteArray  buf&#x3D;tcpSocket-&gt;readAll();</span><br><span class="line">        if(true&#x3D;&#x3D;isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            isStart&#x3D;false;</span><br><span class="line">            &#x2F;&#x2F;头部信息</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;初始化</span><br><span class="line">            fileName&#x3D;QString(buf).section(&quot;##&quot;,0,0);</span><br><span class="line">            fileSize&#x3D;QString(buf).section(&quot;##&quot;,1,1).toInt();</span><br><span class="line">            recvSize&#x3D;0;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;打开文件</span><br><span class="line">            file.setFileName(fileName);</span><br><span class="line">            bool isok&#x3D;file.open(QIODevice::WriteOnly);</span><br><span class="line">            if(false&#x3D;&#x3D;isok)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug()&lt;&lt;&quot;write error 40&quot;;</span><br><span class="line">                tcpSocket-&gt;disconnectFromHost(); &#x2F;&#x2F;断开连接</span><br><span class="line">                tcpSocket-&gt;close(); &#x2F;&#x2F;关闭套接字</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;   this-&gt;progressBar-&gt;setMinimum(0); &#x2F;&#x2F;最小值</span><br><span class="line">            this-&gt;progressBar-&gt;setMaximum(fileSize&#x2F;1024); &#x2F;&#x2F;最大值</span><br><span class="line">            this-&gt;progressBar-&gt;setValue(0); &#x2F;&#x2F;当前值</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">       else</span><br><span class="line">            &#123;</span><br><span class="line">                qint64 len&#x3D;file.write(buf);</span><br><span class="line"></span><br><span class="line">                if(len &gt;0) &#x2F;&#x2F;接收数据大于0</span><br><span class="line">                &#123;</span><br><span class="line">                    recvSize +&#x3D; len; &#x2F;&#x2F;累计接收大小</span><br><span class="line"></span><br><span class="line">                    qDebug() &lt;&lt; recvSize;</span><br><span class="line">                this-&gt;progressBar-&gt;setValue(recvSize&#x2F;1024);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if(recvSize&#x3D;&#x3D;fileSize)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    tcpSocket-&gt;write(&quot;file done&quot;);</span><br><span class="line">                    file.close();</span><br><span class="line">                    QMessageBox::information(this,&quot;完成&quot;,&quot;文件接收完成！&quot;);</span><br><span class="line">                    isStart&#x3D;true;</span><br><span class="line">                    tcpSocket-&gt;disconnectFromHost();&#x2F;&#x2F;断开连接</span><br><span class="line">                    tcpSocket-&gt;close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clientWidget::on_Buttonconect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取</span><br><span class="line">    QString ip&#x3D;this-&gt;Editip-&gt;text();</span><br><span class="line">    quint16 port&#x3D;Editport-&gt;text().toInt();&#x2F;&#x2F;quint</span><br><span class="line"></span><br><span class="line">    tcpSocket-&gt;connectToHost(QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QTcpServer&gt; &#x2F;&#x2F;监听套接字</span><br><span class="line">#include &lt;QTcpSocket&gt; &#x2F;&#x2F;通信套接字</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include &lt;QTimer&gt;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget, private Ui::Widget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">private slots:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void on_buttonFile_clicked();</span><br><span class="line"></span><br><span class="line">    void on_buttonSend_clicked();</span><br><span class="line">    void senddata();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    QTcpServer *tcpServer; &#x2F;&#x2F;监听套接字</span><br><span class="line">    QTcpSocket *tcpSocket; &#x2F;&#x2F;通信套接字</span><br><span class="line"></span><br><span class="line">    QFile file; &#x2F;&#x2F;文件对象</span><br><span class="line">    QString fileName; &#x2F;&#x2F;文件名字</span><br><span class="line">    qint64 fileSize; &#x2F;&#x2F;文件大小</span><br><span class="line">    qint64 sendSize; &#x2F;&#x2F;已经发送文件的大小</span><br><span class="line"></span><br><span class="line">    QTimer timer; &#x2F;&#x2F;定时器</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"></span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &lt;QFileDialog&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QFileInfo&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;监听套接字</span><br><span class="line">    tcpServer &#x3D; new QTcpServer(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;监听</span><br><span class="line">    tcpServer-&gt;listen(QHostAddress::Any, 8888);</span><br><span class="line">    setWindowTitle(&quot;服务器端口为：8888&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;两个按钮都不能按</span><br><span class="line">    this-&gt;buttonFile-&gt;setEnabled(false);</span><br><span class="line">    this-&gt;buttonSend-&gt;setEnabled(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果客户端成功和服务器连接</span><br><span class="line">    &#x2F;&#x2F;tcpServer会自动触发 newConnection()</span><br><span class="line"></span><br><span class="line">    connect(tcpServer, &amp;QTcpServer::newConnection,</span><br><span class="line">    [&#x3D;]()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;取出建立好连接的套接字</span><br><span class="line">        tcpSocket &#x3D; tcpServer-&gt;nextPendingConnection();</span><br><span class="line">        &#x2F;&#x2F;获取对方的ip和端口</span><br><span class="line">        QString ip &#x3D; tcpSocket-&gt;peerAddress().toString();</span><br><span class="line">        quint16 port &#x3D; tcpSocket-&gt;peerPort();</span><br><span class="line"></span><br><span class="line">        QString str &#x3D; QString(&quot;[%1:%2] 成功连接&quot;).arg(ip).arg(port);</span><br><span class="line">        this-&gt;textEdit-&gt;setText(str); &#x2F;&#x2F;显示到编辑区</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;成功连接后，才能按选择文件</span><br><span class="line">        this-&gt;buttonFile-&gt;setEnabled(true);</span><br><span class="line"></span><br><span class="line">        connect(tcpSocket, &amp;QTcpSocket::readyRead,</span><br><span class="line">                [&#x3D;]()</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;取客户端的信息</span><br><span class="line">                    QByteArray buf &#x3D; tcpSocket-&gt;readAll();</span><br><span class="line">                    if(QString(buf) &#x3D;&#x3D; &quot;file done&quot;)</span><br><span class="line">                    &#123;&#x2F;&#x2F;文件接收完毕</span><br><span class="line">                         this-&gt;textEdit-&gt;append(&quot;文件发送完毕&quot;);</span><br><span class="line">                         file.close();</span><br><span class="line">                         &#x2F;&#x2F;断开客户端端口</span><br><span class="line">                         tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">                         tcpSocket-&gt;close();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">    connect(&amp;timer,&amp;QTimer::timeout,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        timer.stop();</span><br><span class="line">        senddata();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_buttonFile_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;路径选择</span><br><span class="line">    QString filepath&#x3D;QFileDialog::getOpenFileName(this,&quot;open&quot;,&quot;..&#x2F;&quot;);</span><br><span class="line">   &#x2F;&#x2F;判断是否为空</span><br><span class="line">    if (filepath.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;failure&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        fileName.clear();</span><br><span class="line">        fileSize&#x3D;0;&#x2F;&#x2F;数据初始化</span><br><span class="line"></span><br><span class="line">        QFileInfo info(filepath);</span><br><span class="line">        fileName&#x3D;info.fileName();</span><br><span class="line">        fileSize&#x3D;info.size();</span><br><span class="line"></span><br><span class="line">        sendSize&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;指定文件名字  只读打开失败</span><br><span class="line">        file.setFileName(filepath);</span><br><span class="line">        bool isok&#x3D;file.open(QIODevice::ReadOnly);</span><br><span class="line">        if(false&#x3D;&#x3D;isok)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug()&lt;&lt;&quot;只读方式打开失败 77&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        this-&gt;textEdit-&gt;append(filepath);</span><br><span class="line">        this-&gt;buttonFile-&gt;setEnabled(false);</span><br><span class="line">        this-&gt;buttonSend-&gt;setEnabled(true);&#x2F;&#x2F;发送按钮显示</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送文件按钮</span><br><span class="line">void Widget::on_buttonSend_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;头部的信息</span><br><span class="line">    QString head&#x3D;QString (&quot;%1##%2&quot;).arg(fileName).arg(fileSize);</span><br><span class="line"></span><br><span class="line">    qint64 len &#x3D;tcpSocket-&gt;write(head.toUtf8());</span><br><span class="line"></span><br><span class="line">    if (len &gt;0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;真正的信息&#x2F;&#x2F;定时发送，防止黏包</span><br><span class="line">        timer.start(20);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;头部信息发送失败~&quot;;</span><br><span class="line">        file.close();</span><br><span class="line">       this-&gt;buttonFile-&gt;setEnabled(true);</span><br><span class="line">       this-&gt;buttonSend-&gt;setEnabled(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::senddata()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;textEdit-&gt;append(&quot;正在发送文件……&quot;);</span><br><span class="line">    qint64 len &#x3D;0;</span><br><span class="line">    do&#123;</span><br><span class="line">        char buf[4*1024]&#x3D;&#123;0&#125;;  &#x2F;&#x2F;每次发送4k</span><br><span class="line">        len&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;往文件都数据 存在buf   返回len 读了多少</span><br><span class="line">        len &#x3D;file.read(buf,sizeof(buf));</span><br><span class="line">        &#x2F;&#x2F;文件都数据 存在buf 发送   指定长度len   返回值发了len</span><br><span class="line">        len &#x3D; tcpSocket-&gt;write(buf,len);</span><br><span class="line">        sendSize+&#x3D;len;</span><br><span class="line">    &#125;</span><br><span class="line">    while(len&gt;0);</span><br><span class="line">        if(sendSize&#x3D;&#x3D;fileSize)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            this-&gt;textEdit-&gt;append(&quot;文件发送完毕&quot;);</span><br><span class="line">            file.close();</span><br><span class="line">            tcpSocket-&gt;disconnect();</span><br><span class="line">            tcpSocket-&gt;close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-UDP</title>
    <url>/QT-Lover/QT-UDP/</url>
    <content><![CDATA[<img src="/QT-Lover/QT-UDP/1.jpg" class="">


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include &lt;QUdpSocket&gt;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget, private Ui::Widget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QUdpSocket *udpsocket;&#x2F;&#x2F;udp套接字</span><br><span class="line">private slots:</span><br><span class="line">    void on_pushButtontsend_clicked();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include&lt;QHostAddress&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配空间指定父对象</span><br><span class="line">  &#x2F;&#x2F;  udpsocket&#x3D;new QUdpSocket (this);组播D类地址</span><br><span class="line"> &#x2F;&#x2F;udpsocket-&gt;joinMulticastGroup(QHostAddress(&quot;224.0.0.2&quot;))</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;广播255.255.255.255</span><br><span class="line">&#x2F;&#x2F;udpsocket-&gt;bind(QHostAddress::AnyIPv4,8888);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">    udpsocket-&gt;bind(QHostAddress::Any,8888);</span><br><span class="line">    this-&gt;setWindowTitle(&quot;服务端8888&quot;);</span><br><span class="line"></span><br><span class="line">    connect(udpsocket,&amp;QUdpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        char buff[1024]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">        QHostAddress cliAddr;</span><br><span class="line">        quint16 port;</span><br><span class="line">        qint64 len&#x3D;udpsocket-&gt;readDatagram(buff,sizeof(buff),&amp;cliAddr,&amp;port);</span><br><span class="line">       &#x2F;&#x2F;接收不大于maxSize字节的数据报并将其存储在数据中。</span><br><span class="line">        &#x2F;&#x2F;发送方的主机地址和端口存储在address和“port”中(除非指针为0)。成功返回数据报的大小;</span><br><span class="line">        if (len&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            QString str&#x3D;QString (&quot;[%1 :%2] %3&quot;).arg(cliAddr.toString()).arg(port).arg(buff);</span><br><span class="line">             this-&gt;textEdit-&gt;setText(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButtontsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    QString ip&#x3D;this-&gt;lineEditIP-&gt;text();</span><br><span class="line">    quint16 port&#x3D;this-&gt;lineEditPort-&gt;text().toInt();</span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容；</span><br><span class="line">    QString str&#x3D;this-&gt;textEdit-&gt;toPlainText();</span><br><span class="line">    udpsocket-&gt;writeDatagram(str.toUtf8().data(),QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-事件</title>
    <url>/QT-Lover/-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>事件</strong></p>
<p>事件（event）是由系统或者 Qt 本身在不同的时刻发出的。<br>一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p>Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于<code>QEvent</code>。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数<code>（event handler）</code>。</p>
<p>protected  virtual 类 子函数实现</p>
<p>keyPressEvent()<br>keyReleaseEvent()<br>mouseDoubleClickEvent()<br>mouseMoveEvent()          —-setMouseTracking()<br>mousePressEvent()<br>mouseReleaseEvent() 等。</p>
<p>event()函数主要用于事件的分发,分发给不同的事件处理器（event handler）。<br>e-&gt;type() == QEvent::KeyPress  事件类别<br>keyEvent-&gt;key() == Qt::Key_Tab  按键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CustomTextEdit::event(QEvent*e)</span><br><span class="line">&#123;</span><br><span class="line">   if (e-&gt;type() &#x3D;&#x3D; QEvent::KeyPress)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        QKeyEvent *keyEvent &#x3D;static_cast(e);</span><br><span class="line">       if (keyEvent-&gt;key() &#x3D;&#x3D; Qt::Key_Tab)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">            qDebug() &lt;&lt; &quot;You presstab.&quot;;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件过滤器</strong><br>virtual bool QObject::eventFilter ( QObject *watched, QEvent * event );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool MainWindow::eventFilter(QObject *obj, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">         if (obj &#x3D;&#x3D; textEdit) &#123;                                                    &#x2F;&#x2F;判断被监视的对象</span><br><span class="line">                 if (event-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) &#123;                   &#x2F;&#x2F;判断事件类型</span><br><span class="line">                         QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent*&gt;(event);</span><br><span class="line">                         qDebug() &lt;&lt; &quot;Ate key press&quot; &lt;&lt; keyEvent-&gt;key();</span><br><span class="line">                         return true;                                                    &#x2F;&#x2F;将键盘事件过滤</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                         return false;                                                &#x2F;&#x2F;继续处理其他事件</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">                 &#x2F;&#x2F; pass the event on to the parent class</span><br><span class="line">                 return QMainWindow::eventFilter(obj, event);           &#x2F;&#x2F;调用父类函数</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</p>
<p>1、重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</p>
<p>1、重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</p>
<p>1、在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</p>
<p>1、在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</p>
<p>1、重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApplication : public QApplication</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyApplication(int &amp; argc, char ** argv):QApplication(argc, argv)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual bool notify(QObject * obj, QEvent * event)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;qDebug()&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;obj&lt;&lt;event;</span><br><span class="line"></span><br><span class="line">        if(event-&gt;type() &#x3D;&#x3D; QMouseEvent::MouseButtonPress)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug()&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;obj&lt;&lt;event;</span><br><span class="line">        &#125;</span><br><span class="line">        return QApplication::notify(obj,event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>QT-焦点事件</strong></p>
<p>设置焦点作用:不需要先用鼠标点击编辑框就可以直接输入文字等信息到其中<br>setFocusPolicy ( Qt::NoFocus )</p>
<p>1、何判断一个才窗口有没有焦点事件,焦点事件或失去焦点事件<br>void QWidget::focusInEvent ( QFocusEvent * event )<br>void QWidget::focusOutEvent ( QFocusEvent * event )</p>
<p>判断当前窗口有没有焦点事件的，返回布尔值。<br>void QWidget::setFocus ( Qt::FocusReason reason )<br>void QWidget::clearFocus ()</p>
<p>–20200726 qt鼠标事件等于触摸屏事件吗？<br>一个滑动事件的问题，触摸事件QTouchEvent将被解释为鼠标左键单击。<br> 1、先校准ts_calibrate<br> 2、强制转换<br> QMouseEvent*  event1 = static_cast&lt;QMouseEvent *&gt; (event);<br>3、脚本校准<br><code><br>  if [! -f "etc/piontercal"];then<br>  ts_calibrate<br>  fi<br></code></p>
<img src="/QT-Lover/-%E4%BA%8B%E4%BB%B6/%E8%A7%A6%E6%91%B8%E6%BB%91%E5%8A%A8.gif" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-中英配置</title>
    <url>/QT-Lover/QT-%E4%B8%AD%E8%8B%B1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/kidults/article/details/87969380" target="_blank" rel="noopener">https://blog.csdn.net/kidults/article/details/87969380</a></p>
<p><a href="https://blog.csdn.net/qq_26787115/article/details/80226060" target="_blank" rel="noopener">https://blog.csdn.net/qq_26787115/article/details/80226060</a></p>
<p>1、创建语言文件</p>
<p>　　打开.pro文件，加入以下：</p>
<p>TRANSLATIONS+=cn.ts</p>
<p>　　工具-&gt;外部-&gt;Qt语言家-&gt;更新翻译,将生成翻译文件cn.ts  en.ts</p>
<p>2、Windows则在开始菜单中可以找到：</p>
<p>在打开的Liguist，把上一步生成的en.ts打开，选择Source text 进行逐个翻译</p>
<p>翻译完后，将 en.ts 进行保存</p>
<p>3、工具-&gt;外部-&gt;Qt语言家-&gt;发布翻译,将生成翻译文件**.qm</p>
<p>QTranslator translator;//系统中英翻译</p>
<img src="/QT-Lover/QT-%E4%B8%AD%E8%8B%B1%E9%85%8D%E7%BD%AE/1.JPG" class="">



<p>注意：翻译后，应该避免控件操作控件的操作</p>
<p>**</p>
<p>注：翻译文件加载的位置必须在界面实例化之前完成，否则是没有效果的</p>
<p>**</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-TCP</title>
    <url>/QT-Lover/QT-TCP/</url>
    <content><![CDATA[<p>因为IP地址是有来标识主机的，IP地址相同说明可能是同一台计算机。<br>端口是用来标识进程的，同一台计算机上两个进程绝对不能占用同一个端口，所以不可能是同一台计算机。<br>{协议，本地地址，本地端口，远程地址，远程端口}。 </p>
<p>项目文件<br>QT += network</p>


<p>client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef CLIENTWIDGET_H</span><br><span class="line">#define CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_clientwidget.h&quot;</span><br><span class="line">#include &lt;QTcpSocket&gt;</span><br><span class="line"></span><br><span class="line">class ClientWidget : public QWidget, private Ui::ClientWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit ClientWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonconnect_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonsend_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonclose_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTcpSocket *tcpSocket;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line">#include &quot;clientwidget.h&quot;</span><br><span class="line">#include&lt;QTextEdit&gt;</span><br><span class="line">#include&lt;QHostAddress&gt;</span><br><span class="line">ClientWidget::ClientWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配空间</span><br><span class="line">    this-&gt;setWindowTitle(&quot;客户端&quot;);</span><br><span class="line"></span><br><span class="line">    tcpSocket&#x3D;new QTcpSocket(this);</span><br><span class="line">&#x2F;&#x2F;请求连接成功标志触发 connected</span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::connected,[&#x3D;]()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this-&gt;Textrend-&gt;setText(&quot;成功连接！QAQ&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;读取接受服务端 readRead</span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        QByteArray array&#x3D;tcpSocket-&gt;readAll();</span><br><span class="line"></span><br><span class="line">        this-&gt;Textrend-&gt;append(array);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonconnect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取IP</span><br><span class="line"> QString ip&#x3D;this-&gt;lineEditIp-&gt;text();</span><br><span class="line"> quint16 port&#x3D;this-&gt;lineEditPort-&gt;text().toInt();&#x2F;&#x2F;字符串转化为int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主动连接</span><br><span class="line"> tcpSocket-&gt;abort();&#x2F;&#x2F;取消之前的连接</span><br><span class="line"></span><br><span class="line"> tcpSocket-&gt;connectToHost(QHostAddress(ip),port);&#x2F;&#x2F;建立连接函数！！</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString str&#x3D;this-&gt;Textwrite-&gt;toPlainText();</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());&#x2F;&#x2F;发送函数  含中文</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonclose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">      tcpSocket-&gt;disconnectFromHost();     &#x2F;&#x2F;断开连接disconnected</span><br><span class="line"></span><br><span class="line">      this-&gt;Textrend-&gt;setText(&quot;断开连接！QAQ&quot;);</span><br><span class="line">&#x2F;&#x2F;    tcpSocket-&gt;close();</span><br><span class="line">&#x2F;&#x2F;     tcpSocket&#x3D;NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef SERVERWIDGET_H</span><br><span class="line">#define SERVERWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_serverwidget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QTcpServer&gt;&#x2F;&#x2F; 监听套接字</span><br><span class="line">#include &lt;QTcpSocket&gt;&#x2F;&#x2F;通信套接字  服务器两个</span><br><span class="line">class ServerWidget : public QWidget, private Ui::ServerWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit ServerWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonsend_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonclose_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QTcpServer *tcpSerever;</span><br><span class="line">    QTcpSocket *tcpSocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; SERVERWIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line">#include &quot;serverwidget.h&quot;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">ServerWidget::ServerWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">     tcpSocket&#x3D;NULL;&#x2F;&#x2F;否则提示。。</span><br><span class="line">     tcpSerever&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">    this-&gt;setWindowTitle(&quot;服务端 8888&quot;);</span><br><span class="line"></span><br><span class="line">    tcpSerever&#x3D;new QTcpServer (this);&#x2F;&#x2F;监听</span><br><span class="line"></span><br><span class="line">    tcpSerever-&gt;listen(QHostAddress::Any,8888);&#x2F;&#x2F;只能在接收成功  server  newConnection是接收信息</span><br><span class="line"></span><br><span class="line">    connect(tcpSerever,&amp;QTcpServer::newConnection,[&#x3D;]()&#123;&#x2F;&#x2F;取出套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tcpSocket&#x3D;tcpSerever-&gt;nextPendingConnection();</span><br><span class="line"></span><br><span class="line">        QString ip&#x3D;tcpSocket-&gt;peerAddress().toString();</span><br><span class="line"></span><br><span class="line">        qint16 port&#x3D;tcpSocket-&gt;peerPort();</span><br><span class="line"></span><br><span class="line">       QString temp&#x3D;QString (&quot;[%1 : %2]:连接成功！QAQ&quot;).arg(ip).arg(port);</span><br><span class="line">     &#x2F;&#x2F;  qDebug()&lt;&lt;&quot;  d &quot;;</span><br><span class="line">       this-&gt;textEdit-&gt;setText(temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()</span><br><span class="line">       &#123;</span><br><span class="line">          &#x2F;&#x2F;通信取出来</span><br><span class="line">           QByteArray array &#x3D;tcpSocket-&gt;readAll();</span><br><span class="line"></span><br><span class="line">           textEdit-&gt;append(array);</span><br><span class="line"></span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServerWidget::on_Buttonsend_clicked()&#x2F;&#x2F;写传输</span><br><span class="line">&#123;</span><br><span class="line">    if(NULL &#x3D;&#x3D; tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容</span><br><span class="line">    QString str &#x3D;this-&gt;textEdit_2-&gt;toPlainText();</span><br><span class="line">    &#x2F;&#x2F;发送</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServerWidget::on_Buttonclose_clicked()&#x2F;&#x2F;关闭</span><br><span class="line">&#123;</span><br><span class="line">    if(NULL &#x3D;&#x3D; tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">    tcpSocket-&gt;close();</span><br><span class="line">     tcpSocket&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/QT-Lover/QT-TCP/1.JPG" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-线程</title>
    <url>/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>QT-线程池</p>
<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" class="">

<p>QT-线程QtConcurrent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：</span><br><span class="line">QT -&#x3D; gui concurrent</span><br><span class="line">CONFIG +&#x3D; c++11 console</span><br><span class="line">第二步：#include &lt;QtConcurrent&#x2F;QtConcurrent&gt;</span><br><span class="line">QString filePath&#x3D;&quot;D:&#x2F;test2.txt&quot;;</span><br><span class="line">    QByteArray data&#x3D;&quot;hello concurrentthread2&quot;;</span><br><span class="line">    QtConcurrent::run([&amp;filePath,&amp;data]()&#123;</span><br><span class="line">        qDebug()&lt;&lt;data;</span><br><span class="line">        QFile file(filePath);</span><br><span class="line">        file.open(QIODevice::WriteOnly);</span><br><span class="line">        file.write(data);</span><br><span class="line">        file.waitForBytesWritten(30*1000);&#x2F;&#x2F;等待写入</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>QT-线程QThread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef MYTHREAD_H</span><br><span class="line">#define MYTHREAD_H</span><br><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">&#x2F;&#x2F;继承获取接口</span><br><span class="line">class MyThread:public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    void run()&#x2F;&#x2F;斜体虚函数</span><br><span class="line">&#123;</span><br><span class="line">    qDebug()&lt;&lt;QThread::currentThread();&#x2F;&#x2F;指针 或者说显示当前的线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c中</span><br><span class="line">MyThread mythread；</span><br><span class="line">  mythread.start();  &#x2F;&#x2F;启动接口函数</span><br></pre></td></tr></table></figure>
<p>QT-线程制图</p>
<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE1.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE2.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE3.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE4.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE5.jpg" class="">


<p>QT-connect第五个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 队列连接：槽函数在接受者所在线程执行。QueuedConnection</span><br><span class="line">* 直接连接：槽函数在发送者所在线程执行。DirectConnection</span><br><span class="line">* 自动连接：二者不在同一线程时，等同于队列连接AutoConnection</span><br><span class="line"></span><br><span class="line">connect(thread,&amp;QThread::finished,thread,&amp;QObject::deleteLater);</span><br><span class="line">&#x2F;&#x2F;线程结束后调用deleteLater来销毁分配的内存</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-程序打包</title>
    <url>/QT-Lover/QT-%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>打开 MinGW 5.3.0 32bit</p>
<p>E:\QT\5.9.6\mingw53_32\bin\windeployqt.exe  环境变量</p>
<p>当前目录</p>
<p>  cd    / d   C:\Users\asus\Desktop\212</p>
<p>windeployqt  put.exe</p>
<p>windeployqt  Template.exe</p>
<p>//linux 系统同样有linuxdeployqt</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-常见坐标获取</title>
    <url>/QT-Lover/QT-%E5%B8%B8%E8%A7%81%E5%9D%90%E6%A0%87%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<p>当前光标相对于屏幕的绝对位置/ /对电脑屏幕来说，左上角也为（0，0）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QCursor::pos()</span><br></pre></td></tr></table></figure>
<p>当前光标相对于当前窗口的位置//相对转化函数mapfromglobal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this-&gt;mapFromGlobal(QCursor::pos())</span><br></pre></td></tr></table></figure>
<p>鼠标事件发生的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MainWindow::mouseReleaseEvent(QMouseEvent* event)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    QPoint pos &#x3D; event-&gt;pos();       &#x2F;&#x2F;相对于当前窗口的位置</span><br><span class="line"></span><br><span class="line">    QPoint globalPos &#x3D; event-&gt;globalPos();    &#x2F;&#x2F;相对于屏幕的全局绝对位置</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>窗体的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget *widget &#x3D; new QWidget();</span><br><span class="line"></span><br><span class="line">widget.pos();    &#x2F;&#x2F;窗体的左上角的位置</span><br></pre></td></tr></table></figure>
<p>判断鼠标光标是否悬浮在某个子控件上//xxx-&gt;geometry()-&gt;contains()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(ui-&gt;pushButtonTest-&gt;geometry().contains( this-&gt;mapFromGlobal(QCursor::pos())))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-制图</title>
    <url>/QT-Lover/QT-%E5%88%B6%E5%9B%BE/</url>
    <content><![CDATA[<p><strong>画笔</strong><br>QPainter</p>
<p><strong>Device设备</strong><br>QPixmap  QImage QPicture</p>
<p>QPixmap专门为图像在屏幕上的显示做了优化，其中QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。（白色变透明）</p>
<p>QImage专门为图像的像素级访问做了优化。<br>QPicture则可以记录和重现QPainter的各条命令。</p>
<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPixmap.jpg" class="">


<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPixmap2.jpg" class="">



<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QImage.jpg" class="">


<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPicture.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-写法小发现</title>
    <url>/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>QString::arg()用法</p>
<p>Qstring str=Qstring(“%1 %2 %3 “).arg(1).arg(2).arg(“egdhqdg “);</p>
<p>Qstring::sprintf()用法</p>
<p>QString str；</p>
<p>str.sprintf(“%d %s,10,”hello””);</p>
<p>oLatin1、toLocal8Bit都是QString转QByteArray的方法</p>
<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QByteArray qByteArray(&quot;&quot;) ; </span><br><span class="line">qByteArray.append(&quot;daniel&quot;);</span><br><span class="line">qByteArray.size();</span><br><span class="line">qByteArray.count(&#39;a&#39;);</span><br><span class="line">qByteArray.fill(&#39;a&#39;);</span><br><span class="line">qByteArray.data();</span><br></pre></td></tr></table></figure>



<p>#define TIMEMS      qPrintable(QTime::currentTime().toString(“HH:mm:ss zzz”))</p>
<h5 id="事件遇到的函数"><a href="#事件遇到的函数" class="headerlink" title="事件遇到的函数"></a>事件遇到的函数</h5><p>事件的ignore函数表示忽略事件，将其传到父组件进行处理<br>事件的accept函数表示接受事件，组件自己进行处理，不会将事件传递给父组件<br>调用accept()意味着 Qt 会停止事件的传播，窗口关闭；<br>调用ignore()则意味着事件继续传播，即阻止窗口关闭。</p>
<p>常用：不点x号快速退出程序</p>
<h5 id="如何判断某个对象是否属于qt类"><a href="#如何判断某个对象是否属于qt类" class="headerlink" title="如何判断某个对象是否属于qt类"></a>如何判断某个对象是否属于qt类</h5><p>inherits(“QLineEdit”)</p>
<h5 id="本机地址ipv4"><a href="#本机地址ipv4" class="headerlink" title="本机地址ipv4"></a>本机地址ipv4</h5><p> ui-&gt;lineEdit_ip-&gt;setText(QNetworkInterface().allAddresses().at(2).toString());</p>
<h5 id="QTimer-singleShot"><a href="#QTimer-singleShot" class="headerlink" title="QTimer::singleShot"></a>QTimer::singleShot</h5><p> QEventLoop eventloop;<br>QTimer::singleShot(3000, &amp;eventloop, SLOT(quit())); // 下拉返回框，延时3s后关闭<br> eventloop.exec();</p>
<h5 id="字体格式："><a href="#字体格式：" class="headerlink" title="字体格式："></a>字体格式：</h5><p>QFont font;<br>font.setFamily(“MicroSoft Yahei”);<br>font.setPixelSize(12);<br>a.setFont(font);</p>
<h5 id="编码格式："><a href="#编码格式：" class="headerlink" title="编码格式："></a>编码格式：</h5><p>QTextCodec *codec = QTextCodec::codecForName(“utf-8”);<br>QTextCodec::setCodecForLocale(codec);</p>
<h5 id="居中显示窗体：-相对于桌面"><a href="#居中显示窗体：-相对于桌面" class="headerlink" title="居中显示窗体：//相对于桌面"></a>居中显示窗体：//相对于桌面</h5><p>QDesktopWidget deskWidget;<br>int deskWidth = deskWidget.availableGeometry().width();<br>int deskHeight = deskWidget.availableGeometry().height();<br>QPoint movePoint(deskWidth / 2 - w.width() / 2, deskHeight / 2 - w.height() / 2);<br> w.move(movePoint);</p>
<h5 id="ObjectName"><a href="#ObjectName" class="headerlink" title="ObjectName()"></a>ObjectName()</h5><p> 主要是用于外界来访问内部的控件成员的，如果外界不需要访问这个成员，则理论上无需设置它的ObjectName。</p>
<p>开源控件链接：<a href="https://gitee.com/feiyangqingyun/QWidgetDemo" target="_blank" rel="noopener">https://gitee.com/feiyangqingyun/QWidgetDemo</a></p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-文件</title>
    <url>/QT-Lover/QT-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>文件系统分类:<br>1顺序访问设备:<br>2随机访问设备:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本文本</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include&lt;QFileInfo&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QDir&gt;</span><br><span class="line">    QFile file(&quot;D:&#x2F;in.txt&quot;);&#x2F;&#x2F;QFile创建了一个文件对象。</span><br><span class="line">    &#x2F;&#x2F;qDebug()&lt;&lt;QDir::currentPath();</span><br><span class="line">    if (!file.open(QIODevice::ReadOnly|QIODevice::Text))&#x2F;&#x2F;只读 文本</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;open file failure&quot;;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        while(!file.atEnd())&#123;</span><br><span class="line">            qDebug()&lt;&lt;file.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   QFileInfo info(file);</span><br><span class="line">    qDebug()&lt;&lt;info.isDir();&#x2F;&#x2F;检查该文件是否是目录；</span><br><span class="line">    qDebug()&lt;&lt;info.isExecutable();  &#x2F;&#x2F;检查该文件是否是可执行文件等。</span><br><span class="line">    qDebug()&lt;&lt;info.baseName();    &#x2F;&#x2F;可以直接获得文件名；</span><br><span class="line">    qDebug()&lt;&lt;info.completeBaseName();  &#x2F;&#x2F;获取完整的文件名</span><br><span class="line">    qDebug()&lt;&lt;info.suffix();     &#x2F;&#x2F;则直接获取文件后缀名。</span><br><span class="line">    qDebug()&lt;&lt;info.completeSuffix(); &#x2F;&#x2F; 获取完整的文件后缀</span><br></pre></td></tr></table></figure>
<p>二进制文本<br>QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU或者字节顺序（大端或小端）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QFile file(&quot;file.dat&quot;);</span><br><span class="line">file.open(QIODevice::WriteOnly);</span><br><span class="line">QDataStream out(&amp;file);</span><br><span class="line">out &lt;&lt; QString(&quot;the answer is&quot;);  &#x2F;&#x2F;写入</span><br><span class="line">out &lt;&lt; (qint32)42;</span><br><span class="line">QFile file(&quot;file.dat&quot;);</span><br><span class="line">file.open(QIODevice::ReadOnly);</span><br><span class="line">QDataStream in(&amp;file);</span><br><span class="line">QString str;</span><br><span class="line">qint32 a;</span><br><span class="line">in &gt;&gt; str &gt;&gt;a;</span><br></pre></td></tr></table></figure>
<p>QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file.open(QIODevice::ReadWrite);&#x2F;&#x2F;读写 </span><br><span class="line">    QDataStream stream(&amp;file);</span><br><span class="line">    QString str &#x3D; &quot;fff answer is 42&quot;;</span><br><span class="line">    stream &lt;&lt; str;</span><br><span class="line">    file.close();</span><br></pre></td></tr></table></figure>
<p>文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QCoreApplication a(argc, argv);</span><br><span class="line">    QFile data (&quot;D:&#x2F;file2.txt&quot;);</span><br><span class="line">    if (!data.open(QFile::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        QTextStream in(&amp;data);</span><br><span class="line">        in.readAll();</span><br><span class="line">        QString inter&#x3D;in.readAll();</span><br><span class="line">        qDebug()&lt;&lt;inter;</span><br><span class="line">    &#125;</span><br><span class="line">data.close();</span><br></pre></td></tr></table></figure>
<p>QBuffer 内存文件。</p>


<p>另外，QBuffer也支持常用的信号。比如，当有数据可读时，它会发出readyRead（）信号；每一次向QBuffer中写入新数据时都会发出bytesWritten()信号。</p>
<p>文件保存创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;打开操作</span><br><span class="line">&#x2F;&#x2F; QString filename  &#x3D; QFileDialog::getOpenFileName(this,tr(&quot;选择图像&quot;),&quot;&quot;,tr(&quot;Images (*.png *.bmp *.jpg)&quot;));</span><br><span class="line">&#x2F;&#x2F;    if(filename.isEmpty())</span><br><span class="line">&#x2F;&#x2F;        return;</span><br><span class="line">&#x2F;&#x2F;    else</span><br><span class="line">&#x2F;&#x2F;    &#123;</span><br><span class="line">&#x2F;&#x2F;        QImage img;</span><br><span class="line">&#x2F;&#x2F;        if(!(img.load(filename))) &#x2F;&#x2F;加载图像</span><br><span class="line">&#x2F;&#x2F;        &#123;</span><br><span class="line">&#x2F;&#x2F;            QMessageBox::information(this, tr(&quot;打开图像失败&quot;),tr(&quot;打开图像失败!&quot;));</span><br><span class="line">&#x2F;&#x2F;            return;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img.scaled(ui-&gt;label-&gt;size())));</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存操作</span><br><span class="line">    QString filename1 &#x3D; QFileDialog::getSaveFileName(this,tr(&quot;Save Image&quot;),&quot;&quot;,tr(&quot;Images (*.png *.bmp *.jpg)&quot;)); &#x2F;&#x2F;选择路径</span><br><span class="line">     QScreen *screen &#x3D; QGuiApplication::primaryScreen();</span><br><span class="line">     screen-&gt;grabWindow(ui-&gt;label-&gt;winId()).save(filename1);</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-dialog</title>
    <url>/QT-Lover/QT-dialog/</url>
    <content><![CDATA[<p>自定义对话框:</p>
<p>    使用QDialog::exec()实现应用程序级别的模态对话框</p>
<p>    使用QDialog::open()实现窗口级别的模态对话框</p>
<p>    使用QDialog::show()实现非模态对话框。</p>
<p>dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);//  属性 ： 让dialog关闭时自动销毁   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模态&#x2F;&#x2F;对话框需要关闭才能用</span><br><span class="line">void MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    	QDialog dialog;</span><br><span class="line">    	dialog.setWindowTitle(tr(&quot;Hello, dialog!&quot;));</span><br><span class="line">dialog.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">非模态&#x2F;&#x2F;对话框不需要关闭也能用，需要析构</span><br><span class="line">void MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog *dialog &#x3D; new QDialog;</span><br><span class="line">    dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);&#x2F;&#x2F;   属性 ： 让dialog关闭时自动销毁         释放内存   堆</span><br><span class="line">    dialog-&gt;setWindowTitle(tr(&quot;Hello, dialog!&quot;)); </span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> QDialog dialog(this);   &#x2F;&#x2F;栈上  子函数里</span><br><span class="line"> QDialog *dialog &#x3D; new QDialog;   &#x2F;&#x2F;堆上    考虑到内存泄漏</span><br></pre></td></tr></table></figure>


<p>消息对话框</p>
<img src="/QT-Lover/QT-dialog/%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg" class="">

<p>标准文件对话框</p>
<img src="/QT-Lover/QT-dialog/%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg" class="">








]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-窗体常用函数</title>
    <url>/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>窗体常用函数</p>
<img src="/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.jpg" class="">

<p>ui-&gt;stackedWidget-&gt;setCurrentIndex(5);</p>
<p>设计换页</p>
<img src="/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%AE%BE%E8%AE%A1%E6%8D%A2%E9%A1%B5.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-控件</title>
    <url>/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>继承图</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E7%BB%A7%E6%89%BF%E5%9B%BE.jpg" class="" title="来源网络">

<p>Qlabel</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/Qlabel.jpg" class="">

<p>QTextEdit</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTextEdit.jpg" class="">

<p>QListView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QListView.jpg" class="">

<p>QTreeView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTreeView.jpg" class="">

<p>QTableView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTableView.jpg" class="">

<p>//获取点击行索引int index = tableView-&gt;currentIndex().row();</p>
<p>QPushButton</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QPushButton.jpg" class="">

<p>QComboBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QComboBox.jpg" class="">

<p>QFontComboBox(字体)</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QFontComboBox.jpg" class="">

<p>QRadioButton(单选)</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QRadioButton.jpg" class="">

<p>QCheckBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QCheckBox.jpg" class="">

<p>QScrollBar</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QScrollBar.jpg" class="">

<p>QSpinBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QSpinBox.jpg" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QObject::connect(slider,&amp;QSlider::valueChanged,spinBox,&amp;QSpinBox::setValue);</span><br><span class="line">void (QSpinBox:: *spinBoxSignal)(int)&#x3D;&amp;QSpinBox::valueChanged;</span><br><span class="line">QObject::connect(spinBox,spinBoxSignal,slider,&amp;QSlider::setValue);</span><br></pre></td></tr></table></figure>

<p>QTimeEdit QDateTime</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTimeEdit_and_QDateTime.jpg" class="">


<p>QDateEdit QDateTime</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QDateEdit_and_QDateTime.jpg" class="">


<p>QLineEdit</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QLineEdit.jpg" class="">


<p>布局（水平、网格）</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E5%B8%83%E5%B1%80.jpg" class="">

<p>QGroupBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E5%B8%83%E5%B1%80.jpg" class="">

<p>QTabWidget</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTableView.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>其他芯片了解-------嵌入式群聊记录</title>
    <url>/Linux-Lover/%E4%BB%96%E8%8A%AF%E7%89%87%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>imx6ull性能有点差，视频传输拉流都一卡一卡的，有比imx6ull 芯片好的介绍不，玩这一款就懂这个感觉不行<br>imx6q吗？好的，谢谢<br>@广工-明 rk3288</p>
<p>通过uart 口AT命令就可以，但是受uart口速率限制，速度上不了，用4G模块太浪费，2G gprs差不多刚合适。要充分发挥4G的速度优势，还是得走USB高速接口，但这对stm32开发来说难度太大，不如上linux </p>
<p><a href="http://www.topeetboard.com/product/imx6.html" target="_blank" rel="noopener">http://www.topeetboard.com/product/imx6.html</a></p>
<p>@广工-明 LWIP UIP。绝对能打牢基础。</p>
<p>PS流，H265，RTSP，live555，感觉真正大神都不愿意讲解</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux音频驱动了解</title>
    <url>/Linux-Lover/linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>音频编解码芯片</strong></p>
<p>音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频CODEC 最重要的指标。比如常见音频采样率有 8K、44.1K、48K、192K 甚至 384K 和 768K，采样位数常见的有 8 位、16 位、24 位、32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的 HIFI。因此大家会看到高端的音频播放器都会有很高的采<br>样率和采样位数，同样的价格也会越高。当然了，实际的效果还与其他部分有关，采样率和采样位数只是其中重要的指标之一。</p>
<p><strong>WM8960</strong></p>
<p>WM8960 是一颗由 wolfson(欧胜)公司出品的音频编解码芯片。</p>
<p>此接口 5 根线的作用如下：<br>ADCDAT：ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给<br>主控制器。<br>ADCLRC：ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号<br>的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC<br>引脚作为帧时钟。<br>DACDAT：DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。<br>DACLRC ：DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左<br>右声道数据，此信号的频率等于采样率。<br>BCLK ：位时钟，用于同步。<br>MCLK ：主时钟，WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，<br>MCLK 频率等于采样率的 256 或 384 倍，因此大家在 WM8960 的数据手册里面常看到<br>MCLK=256fs 或 MCLK=384fs</p>
<p>I2S 接口需要 3 根信号线<br>SCK ：串行时钟信号，也叫做位时钟(BCLK)，音频数据的每一位数据都对应一个 SCK，立体声都是双声道的，因此 SCK=2×采样率×采样位数。比如采样率为 44.1KHz、16 位的立体声音频，那么 SCK=2×44100×16=1411200Hz=1.4112MHz。</p>
<p>WS ：字段(声道)选择信号，也叫做 (LRCK)，也叫做帧时钟，用于切换左右声道数据，WS 为“1”表示正在传输左声道的数据，WS 为“0”表示正在传输右声道的数据。WS 的频率等于采样率，比如采样率为 44.1KHz 的音频，WS=44.1KHz。</p>
<p>SD：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。<br>数据格式：Left Justified(左对齐)和 Right Justified(右对齐)</p>
<p>为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 (MCLK) 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。</p>
<p><strong>WM8960重要引脚</strong></p>
<p> AUD INT<br> SAI2_TX_SYN<br> SAI2_TX_BLCK<br> SAI2_RX_DATA<br> SAI2_TX_DATA</p>
<p> I2C SCL<br> I2C SDA</p>
<p>两个接口，SAI 和 I2C，我们依次来看一下这两个接口：<br>①、SAI 接口一共用到了 6 根数据线，这 6 根数据线用于 I.MX6ULL 与 WM8960 之间的音频数据收发。<br>②、WM8960 在使用的时候需要进行配置，配置接口为 I2C，连接到了 I.MX6ULL 的 I2C2上。</p>
<p>alsa-lib 和 和 alsa-utils  移植（buildroot）</p>
<p>amixer scontrols  //查看所有设置项</p>
<p>amixer scontents  //查看设置值</p>
<p>amixer sset 设置项目 设置值<br>或：<br>amixer cset 设置项目 设置值</p>
<p>amixer sget 设置项目<br>或：<br>amixer cget 设置项目</p>
<p>amixer sset Headphone 127,127<br>amixer sset Speaker 127,127<br>amixer sset ‘Right Output Mixer PCM’ on<br>amixer sset ‘Left Output Mixer PCM’ on</p>
<p>aplay test.wav //播放歌曲</p>
<p>录音</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #!&#x2F;bin&#x2F;sh</span><br><span class="line"> #正点原子@ALIENTEK</span><br><span class="line"> #设置捕获的音量</span><br><span class="line">amixer cset name&#x3D;&#39;Capture Volume&#39; 90,90</span><br><span class="line"></span><br><span class="line"> #PCM</span><br><span class="line"> amixer sset &#39;PCM Playback&#39; on</span><br><span class="line"> amixer sset &#39;Playback&#39; 256</span><br><span class="line"> amixer sset &#39;Right Output Mixer PCM&#39; on</span><br><span class="line"> amixer sset &#39;Left Output Mixer PCM&#39; on</span><br><span class="line"></span><br><span class="line"> #ADC PCM</span><br><span class="line"> amixer sset &#39;ADC PCM&#39; 200</span><br><span class="line"></span><br><span class="line"> #耳机&#x2F;喇叭（扬声器）设置播放音量，直流&#x2F;交流</span><br><span class="line"> #Turn on Headphone</span><br><span class="line"> amixer sset &#39;Headphone Playback ZC&#39; on</span><br><span class="line"> #Set the volume of your headphones(98% volume，127 is the MaxVolume)</span><br><span class="line"> amixer sset Headphone 125,125</span><br><span class="line"> #Turn on the speaker</span><br><span class="line"></span><br><span class="line"> amixer sset &#39;Speaker Playback ZC&#39; on</span><br><span class="line"> #Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span><br><span class="line"> amixer sset Speaker 125,125</span><br><span class="line"> #Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span><br><span class="line"> amixer sset &#39;Speaker AC&#39; 4</span><br><span class="line"> #Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span><br><span class="line"> amixer sset &#39;Speaker DC&#39; 4</span><br><span class="line"> #音频输入，左声道管理</span><br><span class="line"> #Turn on Left Input Mixer Boost</span><br><span class="line"> amixer sset &#39;Left Input Mixer Boost&#39; off</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT1&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT1&#39; 0</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT2&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT2&#39; 0</span><br><span class="line"> #Turn off Left Boost Mixer LINPUT3</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT3&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT3&#39; 0</span><br><span class="line"> #音频输入，右声道管理，全部关闭</span><br><span class="line"> #Turn on Right Input Mixer Boost</span><br><span class="line"> amixer sset &#39;Right Input Mixer Boost&#39; on</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT1&#39; off</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 0</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT2&#39; on</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 127</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT3&#39; off</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT3&#39; 0</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer cset name &#x3D;&#39;Capture Volume&#39; 100,100</span><br><span class="line"></span><br><span class="line">amixer sset &#39;PCM Playback&#39; on</span><br><span class="line">amixer sset &#39;Playback&#39; 256</span><br><span class="line">amixer sset &#39;Right Output Mixer PCM&#39; on</span><br><span class="line">amixer sset &#39;Left Output Mixer PCM&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset &#39;ADC PCM&#39; 200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Headphone Playback ZC&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset Headphone 125,125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker Playback ZC&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset Speaker 125,125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker AC&#39; 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker DC&#39; 4</span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Input Mixer Boost&#39; on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Boost Mixer LINPUT1&#39; off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT1&#39; 0</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT2&#39; on</span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT2&#39; 127</span><br><span class="line">amixer sset &#39;Left Boost Mixer LINPUT3&#39; off</span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT3&#39; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Right Input Mixer Boost&#39; on</span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT1&#39; off</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT1&#39; 0</span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT2&#39; off</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 0</span><br><span class="line"></span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT3&#39; on</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT3&#39; 127</span><br></pre></td></tr></table></figure>
<p>arecord -f cd -d 10 record.wav<br>aplay record.wav</p>
<p>保存声卡设置<br>alsactl -f /var/lib/alsa/asound.state store //保存声卡设置<br>alsactl -f /var/lib/alsa/asound.state restore //配置</p>
<p>打开/etc/init.d/rcS 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -f &quot;&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state&quot; ]; then</span><br><span class="line"> echo &quot;ALSA: Restoring mixer setting......&quot;</span><br><span class="line"> &#x2F;sbin&#x2F;alsactl -f &#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state restore &amp;</span><br><span class="line"> fi</span><br></pre></td></tr></table></figure>

<p><strong>mplayer</strong></p>
<p>1 、mplayer播放音频<br>mplayer test.flac</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 ：增加音量。</span><br><span class="line">0：减小音量。</span><br><span class="line">左键：倒退 10 秒</span><br><span class="line">右键：快进 10 秒</span><br><span class="line">上键：倒退 1 分钟</span><br><span class="line">下键：快进 1 分钟</span><br><span class="line">空格：暂停和播放</span><br></pre></td></tr></table></figure>

<p>2、视频播放测试</p>
<p>mplayer test.avi -fs //居中播放视频</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-信号传递</title>
    <url>/Linux-Lover/-%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送类</span><br><span class="line"></span><br><span class="line"> void send()   &#123; </span><br><span class="line"></span><br><span class="line">  mit newPaper(m_name);  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">    void newPaper(const QString &amp;name);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    QString m_name;</span><br><span class="line"></span><br><span class="line">接受类</span><br><span class="line"></span><br><span class="line"> Reader()  &#123;&#125;</span><br><span class="line"></span><br><span class="line">   void receiveNewspaper(const QString &amp;name)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        qDebug() &lt;&lt; &quot;ReceivesNewspaper: &quot; &lt;&lt; name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>摄像头和声卡驱动</title>
    <url>/Linux-Lover/%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>写一个摄像头驱动程序<br>-&gt; uvc驱动程序重点<br>描述符的分析<br>属性的控制：VideoControl Interface 设置<br>格式的选择：VideoStreaming Interface 设置<br>数据的获取：VideoStreaming Interface 的URB来获得</p>
<p>内核配置摄像头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device Drivers </span><br><span class="line">---&gt;&lt;*&gt; Multimedia support</span><br><span class="line">   ---&gt;  [*] Media USB Adapters </span><br><span class="line">        &lt;*&gt;USB Video Class (UVC)</span><br><span class="line">        [*]UVC input events device support</span><br></pre></td></tr></table></figure>



<p>声卡驱动</p>
<p>oss(交钱)<br>alsa（主流，可以模拟oss）</p>
<p>存储：数字信号。<br>播放：一定条件，采样频率越高失真率越少，容量越大。44k<br>转化精度:8bit,16bit。<br>通道：单/双</p>
<p>写一个声卡驱动程序<br>-&gt;alsa 驱动程序</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 232、485、GPS</title>
    <url>/Linux-Lover/Linux-232%E3%80%81485%E3%80%81GPS/</url>
    <content><![CDATA[<p>串口是很常用的一个外设，在 Linux 下通常通过串口和其他设备或传感器进行通信，根据<br>电平的不同，串口分为 TTL 和 RS232。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uart_driver  注册与注销</span><br><span class="line">int uart_register_driver(struct uart_driver *drv)</span><br><span class="line">void uart_unregister_driver(struct uart_driver *drv)</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">int uart_add_one_port(struct uart_driver *drv,</span><br><span class="line">struct uart_port *uport)</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux SPI</title>
    <url>/Linux-Lover/nux-SPI/</url>
    <content><![CDATA[<p>spi_master 结构<br>transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函<br>数。<br>transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，<br>SPI 的数据会打包成 spi_message，然后以队列方式发送出去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spi_master  申请与释放</span><br><span class="line">spi_alloc_master 函数用于申请 spi_master，函数原型如下：</span><br><span class="line">struct spi_master *spi_alloc_master(struct device *dev,</span><br><span class="line">unsigned size)</span><br><span class="line"></span><br><span class="line">spi_master 的释放通过 spi_master_put 函数来完成，当我们删除一个 SPI 主机驱动的时候就</span><br><span class="line">需要释放掉前面申请的 spi_master，spi_master_put 函数原型如下：</span><br><span class="line">void spi_master_put(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spi_master  的注册</span><br><span class="line">int spi_register_master(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"> spi_master 的注销</span><br><span class="line">void spi_unregister_master(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spi_message初始化</span><br><span class="line">void spi_message_init(struct spi_message *m)</span><br><span class="line"></span><br><span class="line">spi_transfer 添加到 spi_message 队列中</span><br><span class="line">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)</span><br><span class="line"></span><br><span class="line">同步传输函数为 spi_sync，函数原型如下：</span><br><span class="line">int spi_sync(struct spi_device *spi, struct spi_message *message)</span><br><span class="line"></span><br><span class="line">SPI 异步传</span><br><span class="line">输函数为 spi_async，函数原型如下：</span><br><span class="line">int spi_async(struct spi_device *spi, struct spi_message *message)</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>wifi驱动了解</title>
    <url>/Linux-Lover/ifi%E9%A9%B1%E5%8A%A8%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>支持 USB 和 SDIO 这两种接口的 WIFI。</p>
<p>SDIO 接口的 WIFI 使用芯片为 RTL8189FS<br>RTL8188 USB WIFI</p>
<p>在编译 RTL8188 和 RTL8189 驱动之前需要先配置 Linux 内核。参考正点原子</p>
<p>1 、配置 USB 设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; &lt;*&gt; USB support</span><br><span class="line">    -&gt; &lt;*&gt; Support for Host-side USB</span><br><span class="line">      -&gt; &lt;*&gt; EHCI HCD (USB 2.0) support</span><br><span class="line">      -&gt; &lt;*&gt; OHCI HCD (USB 1.1) support</span><br><span class="line">       -&gt; &lt;*&gt; ChipIdea Highspeed Dual Role Controller</span><br><span class="line">        -&gt; [*] ChipIdea device controller</span><br><span class="line">        -&gt; [*] ChipIdea host controller</span><br></pre></td></tr></table></figure>
<p>配置支持 WIFI 设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; [*] Network device support</span><br><span class="line">    -&gt; [*] Wireless LAN</span><br><span class="line">      -&gt; &lt;*&gt; IEEE 802.11 for Host AP (Prism2&#x2F;2.5&#x2F;3 and WEP&#x2F;TKIP&#x2F;CCMP)</span><br><span class="line">        -&gt; [*] Support downloading firmware images with Host AP driver</span><br><span class="line">        -&gt; [*] Support for non-volatile firmware download</span><br><span class="line"></span><br><span class="line">-&gt; Networking support</span><br><span class="line">  -&gt; -*- Wireless</span><br><span class="line">    -&gt; [*] cfg80211 wireless extensions compatibility</span><br><span class="line">    -&gt; &lt;*&gt; Generic IEEE 802.11 Networking Stack (mac80211)</span><br></pre></td></tr></table></figure>
<p>make编译后<br>驱动编译为模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; Network device support (NETDEVICES [&#x3D;y])</span><br><span class="line">    -&gt; Wireless LAN (WLAN [&#x3D;y])</span><br><span class="line">    -&gt; Realtek wifi (REALTEK_WIFI [&#x3D;m])</span><br><span class="line">      -&gt; rtl8189ftv sdio wifi</span><br><span class="line">      -&gt; rtl8188eus usb wifi</span><br><span class="line">      -&gt; Realtek 8192C USB WiFi</span><br></pre></td></tr></table></figure>

<p>make modules -j12 //编译驱动模块</p>
<p>8188eu.ko、8189fs.ko 和 8192cu.ko 就是我们需要的 RTL8188EUS、<br>RTL8189FS 和 RTL8188CUS/8192CU 的 驱 动 模 块 文 件 ，移rootfs/lib/modules/4.1.15 目录中。</p>
<p>RTL8188 USB WIFI 测试</p>
<p>depmod //第一次加载驱动的时候需要运行此命令<br>modprobe 8188eu.ko  //RTL8188EUS 模块加载 8188eu.ko 模块</p>
<p>ifconfig -a  //查看“wlan0”的网卡</p>
<p>但是WIFI 要想联网，需要移植一些其他第三方组件!!!!</p>
<p><strong>wireless tools  移植</strong></p>
<p>wireless tools 是操作 WIFI 的工具集合，包括一下工具：</p>
<p>①、iwconfig：设置无线网络相关参数。<br>②、iwlist：扫描当前无线网络信息，获取 WIFI 热点。<br>③、iwspy：获取每个节点链接的质量。<br>④、iwpriv：操作 WirelessExtensions 特定驱动。<br>⑤、ifrename：基于各种静态标准命名接口。<br>modprobe 8188eu.ko  //加载 RTL8188 驱动模块</p>
<p>ifconfig wlan0 up //打开 wlan0 网卡</p>
<p>wlan0 网卡打开以后就可以使用 iwlist 命令查找当前环境下的 WIFI 热点信息，也就是无线<br>路由器，输入如下命令：</p>
<p>iwlist wlan0 scan</p>
<p><strong>wpa_supplicant 移植</strong></p>
<p>1、wpa_supplicant 移植 依赖于 openssl<br>openssl-1.1.1d.tar.gz，新建openssl文件夹<br> ./Configure linux-armv4 shared no-asm –prefix=/home/ming/linux/tool/openssl CROSS_COMPILE=arm-linux-gnueabihf-</p>
<p>将 lib 目录下的 libcrypto 和 libssl 库拷贝到开发<br>板根文件系统中的/usr/lib 目录</p>
<p>cp libcrypto.so* /home/ming/linux/nfs/rootfs/usr/lib/ -af<br>cp libssl.so* /home/ming/linux/nfs/rootfs/usr/lib/ -af</p>
<p>2、wpa_supplicant 移植 依赖 libnl  库移植</p>
<p>sudo apt-get install bison<br>sudo apt-get install flex</p>
<p>./configure –host=arm-linux-gnueabihf –prefix=/home/ming/linux/tool/libnl/</p>
<p>3、<br>CC = arm-linux-gnueabihf-gcc</p>
<p>#openssl 库和头文件路径</p>
<p>CFLAGS += -I/home/ming/linux/tool/openssl/include<br>LIBS += -L/home/ming/linux/tool/openssl/lib -lssl<br>    -lcrypto</p>
<p>#libnl 库和头文件路径<br>CFLAGS += -I/home/ming/linux/tool/libnl/include/libnl3<br>LIBS += -L/home/ming/linux/tool/libnl/lib</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核自带HOST与USBOTG</title>
    <url>/Linux-Lover/inux%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6HOST/</url>
    <content><![CDATA[<p>USB<br>Generic HID driver  //使能通用 HID 驱动<br>USB HID transport layer //USB 键盘鼠标等 HID 设备驱动</p>
<p>鼠标<br>等价使用“USB HIDBP Keyboard (simple Boot) support”和“USB HIDBP Mouse<br>(simple Boot) support”这两个配置项<br>hexdump  /dev/input/event3</p>
<p>键盘<br>vi /etc/inittab<br>tty1::askfirst:-/bin/sh</p>
<p>U盘 FAT32 格式的<br>SCSI 协议<br>SCSI disk support //选中此选项<br>USB Mass Storage support //USB 大容量存储设备</p>
<p>mkdir /mnt/usb_disk -p //创建目录<br>mount /dev/sda1 /mnt/usb_disk/ -t vfat -o iocharset=utf8  //挂载</p>
<p>操作完成后拔出前<br>sync //同步<br>umount /mnt/usb_disk //卸载</p>
<p> USB OTG</p>
<p> OTG  从机U盘实验<br> 内核<br>drivers/usb/gadget/libcomposite.ko<br>drivers/usb/gadget/function/usb_f_mass_storage.ko<br>drivers/usb/gadget/legacy/g_mass_storage.ko<br>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：<br>cd drivers/usb/gadget/  //进入 gadget 目录下<br>sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp function/usb_f_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp legacy/g_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/</p>
<p>USB 声卡实验</p>
<p>ALPHA 开发板板载了音频解码芯片，因此可以将 ALPHA 开发板作为一个外置USB 声卡<br> drivers/usb/gadget/libcomposite.ko<br>drivers/usb/gadget/function/usb_f_uac1.ko<br>drivers/usb/gadget/legacy/g_audio.ko</p>
<p>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：</p>
<p>cd drivers/usb/gadget/<br>sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp function/usb_f_uac1.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp legacy/g_audio.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>USB</title>
    <url>/Linux-Lover/SB/</url>
    <content><![CDATA[<p><strong>USB</strong></p>
<p>注意：USB 和 CAN 共用一个专用的 存储器用于数据的发送和接收。（不能同时使用）。<br>USB模块对同步传输和高吞吐量的批量传输提供了特殊的双缓冲区机制，在微控制器使用一个<br>缓冲区的时候，该机制保证了USB外设总是可以使用另一个缓冲区。</p>
<p>在任何不需要使用USB模块的时候，通过写控制寄存器总可以使USB模块置于低功耗模式<br>(SUSPEND模式)。可以在低功耗模式下唤醒USB模块。也可以将一特定的中断<br>输入源直接连接到唤醒引脚上。<br>高功耗设备 ： 总耗电不超过 总耗电不超过 2.5mA。 。<br>低功耗设备 ： 总耗电不超过 总耗电不超过 500uA</p>
<p>:Full-Speed 和 High-Speed，也就是全速(FS)和高速(HS)。U<br>Mbps是一种传输速率单位，指每秒传输的位（比特）数量，USB2.0中<br>FS 的速度为 12Mbps，USB2.0<br>HS 速度为 480Mbps。<br>USB1.0，理论速度为 1.5Mbps<br>最大的有效数据长度:<br>  低速设备: 8 字节 字节<br>  全速设备: 8, 16, 32, 64 字节 字节<br>  高速设备: 64 字节</p>
<p> PHY指物理层，OSI的最底层。 一般指与外部信号接口的芯片。</p>
<p>USB Host是指驱动过后，板子就可以连接USB接口连接的器件，读取和装载数据了。<br>USB Device是指驱动过后，板子可以当做一个USB移动设备，通过USB连接到电脑上，类似U盘<br>OTG是增加了host、device协商机制的usb口。<br>USB接口<br>A类扁平接口<br>B类　方形的梯形接口<br>MINI USB<br>( Mini USB 插头相比 USB A 插头多了一个 ID 线，这个 ID 线用于实现 OTG 功能，通过 ID 线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。)<br>Mirco USB<br>USB  拓扑结构（USB 集线器也叫做 USB HUB）</p>
<p> USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB<br>设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、<br>配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个<br>特定的端点。</p>
<p> <strong>USB OTG</strong></p>
<p>USB技术的发展，使得PC和周边设备能够通过简单方式、适度的制造成本将各种设备连接在一起，上述我们提到应用，都可以通过USB总线，作为PC的周边，在PC的控制下进行数据交换。但这种方便的交换方式，一旦离开了PC，各设备间无法利用USB口进行操作，因为没有一个设备能够充当PC一样的Host。<br>On-The-Go，即OTG技术就是实现在没有Host的情况下，实现设备间的数据传送。<br> 第五根线ID<br>ID=1 ：OTG 设备工作在从机模式。<br>ID=0：OTG 设备工作在主机模式。</p>
<p> HUB 芯片，支持一拖四扩展,使用 GL850G 扩展出来的 4 路 USB 接口只能用作 HOST！</p>
<p> <strong>USB 设备常用描述符</strong></p>
<p>Device Descriptor  设备描述符  1<br>Configuration Descriptor  配置描述符  2<br>String Descriptor  字符串描述符  3<br>Interface Descriptor  接口字符串  4<br>Endpoint Descriptor  端点描述符  5</p>
<p><strong>设备描述符用于描述 USB</strong></p>
<img src="/Linux-Lover/SB/1.JPG" class="">

<img src="/Linux-Lover/SB/2.JPG" class="">

<img src="/Linux-Lover/SB/3.JPG" class="">

<img src="/Linux-Lover/SB/4.JPG" class="">

<img src="/Linux-Lover/SB/5.JPG" class="">



<p> <strong>USB数据包</strong></p>
<p>USB 是串行通信，需要一位一位的去传输数据， USB 传输的时候先将原始数据进行打包，USB 中传输的基本单元就是数据包。<br>这四种包通过包标识<br>符 PID 来区分，PID 共有 8 位，USB 协议使用低 4 位 PID3<del>PID0。令牌包的 PID1</del>0 为 01，数<br>据包的 PID1<del>0 为 11，握手包的 PID1</del>0 为 10，特殊包的 PID1~0 为 00。</p>
 <img src="/Linux-Lover/SB/6.JPG" class="">

<p> <strong>USB传输</strong></p>
<p> 1、控制传输<br> 2、同步传输<br> 3、批量传输<br> 4 、中断传输</p>
<p><strong>USB枚举</strong></p>
<p>当 USB 设备与 USB 主机连接以后主机就会对 USB 设备进行枚举，通过枚举来获取设备的<br>描述符信息。<br>①、第一回合，当 USB 主机检测到 USB 设备插入以后机会发出总线复位信号来复位设备。<br>USB 设备复位完成以后地址为 0，主机向地址 0 的端点 0 发送数据，请求设备的描述符。设备<br>得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描<br>述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。<br>//复位</p>
<p>②、第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0 的端点 0 发送设置<br>地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过<br>程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0 字节状态数据包，表明设备<br>已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到<br>主机发送的 ACK 包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。<br>//设地址</p>
<p>③、第三回合，主机向新的设备地址端点 0 发送请求设备描述符数据包，这一次主机要获<br>取整个设备描述符，一共是 18 个字节。<br>//发数据</p>
<p>④、和第③步类似，接下来依次获取配置描述符、配置集合、字符串描述符等等。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Linux消息队列</title>
    <url>/Linux-Lover/%E4%BA%86%E8%A7%A3Linux%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>不同进程通过同一个key值得到同一个IPC对象id，来访问同一个IPC对象。</p>
<p><strong>消息队列</strong></p>
<p>    消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法<br>    每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值<br>    消息队列也有管道一样的不足，就是每个消息的最大长度是有上限的（MSGMAX），每个消息队列的总的字节数是有上限的（MSGMNB），系统上消息队列的总数也有一个上限（MSGMNI）</p>
<pre><code>cat /proc/sys/kernel/msgmax 最大消息长度 限制
cat /proc/sys/kernel/msgmnb 消息队列总的字节数
cat /proc/sys/kernel/msgmni 消息条目数</code></pre><p>IPC Inter-Process Communication，进程间通信</p>
<img src="/Linux-Lover/%E4%BA%86%E8%A7%A3Linux%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1.JPG" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列函数 </span><br><span class="line">	#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">	int msgget(key_t key, int msgflg);&#x2F;&#x2F;用来创建和访问一个消息队列</span><br><span class="line">	int msgctl(int msqid, int cmd, struct msqid_ds *buf);&#x2F;&#x2F;消息队列的控制函数</span><br><span class="line">	int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);&#x2F;&#x2F;发送</span><br><span class="line">	ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);&#x2F;&#x2F;接受</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程间通讯</title>
    <url>/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p><strong>进程互斥</strong></p>
<p>由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥<br>系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源。<br>在进程中涉及到互斥资源的程序段叫临界区</p>
<p><strong>进程同步</strong></p>
<p>进程同步指的是多个进程需要相互配合共同完成一项任务。</p>
<p><strong>进程间通信目的</strong></p>
<p>不同进程之间无法互相访问对方的地址空间。</p>
<p>1、数据传输：一个进程需要将它的数据发送给另一个进程<br>2、资源共享：多个进程之间共享同样的资源。<br>3、通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。<br>4、进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<p>进程间通信分类<br>    文件<br>    文件锁<br>    管道（pipe）和有名管道（FIFO）<br>    信号（signal）<br>    消息队列<br>    共享内存<br>    信号量<br>    互斥量<br>    条件变量<br>    读写锁<br>    套接字（socket）</p>
<img src="/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/1.JPG" class="">


<p><strong>共享内存</strong></p>
<p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。</p>
<p>ipcs -m</p>
<p>共享内存还是处于内核空间</p>
<img src="/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/2.jpg" class="">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Linux管道</title>
    <url>/Linux-Lover/%E8%A7%A3Linux%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p>从一个进程连接到另一个进程的一个数据流称为一个“管道”。<br>管道的本质====》固定大小的内核缓冲区。</p>
<p>管道限制：<br>1、半双工，需要两个管道<br>2、只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信。<br> ls | wc -w // 统计当前目录下文件个数</p>
<p><strong>匿名管道</strong></p>
<p>int pipe(int pipefd[2]);<br>fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端。</p>
<img src="/Linux-Lover/%E8%A7%A3Linux%E7%AE%A1%E9%81%93/1.JPG" class="">


<p><strong>管道一些常见规则</strong></p>
<p>当没有数据可读时<br>read调用阻塞，即进程暂停执行，一直等到有数据来到为止。<br>当管道满的时候<br>调用返回-1，errno值为EAGAIN<br> cat /usr/include/linux/limits.h<br>#define PIPE_BUF        4096<br>如果所有管道写端对应的文件描述符被关闭，则read返回0<br>如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE<br>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。<br>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。</p>
<p><strong>有名管道（FIFO管道）</strong></p>
<p>匿名管道应用的一个限制就是只能在具有共同祖先（具有亲缘关系）的进程间通信。<br>如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为命名管道。命名管道是一种特殊类型的文件。</p>
<p>匿名管道与命名管道PK<br>匿名管道由pipe函数创建并打开。<br>命名管道由mkfifo函数创建，打开用open<br>FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的方式<br>同，一但这些工作完成之后，它们具有相同的语义。</p>
<p>扩展：<br>以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（除非有一个进程以写方式打开同一个FIFO，否则它不会返回；<br>解决：O_RDONLY | O_NONBLOCK</p>
<p>只写方式（O_WRONLY）打开的FIFO文件，如果open调用是阻塞的，open调用将被阻塞，直到有一个进程以只读方式打开同一个FIFO文件为止；<br>O_WRONLY | O_NONBLOCK_NONBLOCK</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/Linux-Lover/%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p><strong>内网</strong></p>
<p>NAT的最典型应用是：在一个局域网内，只需要一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。<br>内网是可以上网的，内网需要一台服务器或路由器做网关,通过它来上网。</p>
<p><strong>内网穿透</strong></p>
<p>即NAT穿透，采用端口映射，让外网的电脑找到处于内网的电脑，同时也可基于 HTTP/2实现web内网穿透。<br>方法：在局域网内部的任一PC或服务器上运行到花生壳内网穿透客户端，此时域名解析到的IP地址是局域网网关出口处的公网IP地址，再在网关处做端口映射指向监控设备即可。</p>
<p>源IP + 源端口–&gt;路由器-&gt;目的IP + 目的端口</p>
<p>有NAT转化映射表,这样做目的。<br>1、保护局域网<br>2、节省IP</p>
<p>内网穿透方法：<br>1、设置路由器</p>
<p>2、借用软件：花生壳<br><a href="https://www.oray.com/" target="_blank" rel="noopener">https://www.oray.com/</a><br>添加映射，自动生成域名。<br>6元买1年送98年，实惠QAQ!!!</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>了解摄像头和声卡</title>
    <url>/Linux-Lover/%E4%BA%86%E8%A7%A3%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1/</url>
    <content><![CDATA[<p><strong>摄像头</strong></p>
<p>常见接口：usb、cmos</p>
<p>主要参数：分辨率（像素点数）、格式、帧率(1s拍几张图)</p>
<p>API接口：V4l2</p>
<img src="/Linux-Lover/%E4%BA%86%E8%A7%A3%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1/1.JPG" class="">


<p><strong>声卡</strong></p>
<p>采样频率、采样位宽。<br>声道个数（ADC采集个数）</p>
<p>API接口：ALSA (复杂)<br>—-&gt;alsa-lib编写APP<br>参考：<a href="http://www.equalarea.com/paul/alsa-audio.html" target="_blank" rel="noopener">代码</a></p>
<p>buildroot 配置 alsa-utils </p>
<p>Target packages<br>-&gt; Audio and video applications<br>-&gt; alsa-utils  此目录下的软件全部选中</p>
<p>只录制声音<br>开发板：ffmpeg -f alsa -ac 1 -i hw:0,0 my.wav<br>//第0个声卡第0个模块，通道一，保存格式.wav<br>播放：  aplay my.wav</p>
<p>只推送声音：</p>
<p>ffmpeg -f alsa -ac 1 11025 -i hw:0,0 -acodec aac -f flv rtmp://127.0.0.1/live/ming</p>
<p>推送视频和声音：<br>ffmpeg -f alsa -ac 1 -ar 11025 -i hw:0,0 -acodec aac -f v4l2 -framerate 10 -i /dev/video1 -q 10 -f flv rtmp://127.0.0.1/live/ming</p>
<p>拉流http flv协议<br><a href="http://192.168.0.50/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://192.168.0.50/test?app=live&amp;stream=ming</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习方案二</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/</url>
    <content><![CDATA[<p><strong>数据的认识</strong></p>
<p>mp4指的是音频视频封装格式。</p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/1.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/2.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/3.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/4.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/5.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/6.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/ffmeg%E5%8F%82%E6%95%B0.JPG" class="">

<p><strong>ffmpeg</strong></p>
<p>buildroot 下载 ffmpeg</p>
<p>根文件文件目录输入命令<br>摄像头读取数据转化为MP4格式。<br>ffmpeg -f v412 -framerate 10 -i /dev/video -q 10 my.mp4</p>
<p>注：有windows版的ffmpeg可以用来实验学习。</p>
<p><strong>ngnix</strong></p>
<p>新建目录/dl/nginx，加载模块</p>
<p>git clone <a href="https://github.com/winshining/nginx-http-flv-module.git">https://github.com/winshining/nginx-http-flv-module.git</a></p>
<p>buildroot 配置nginx,添加第三模块路径。</p>
 

<p> 注意：流媒体服务器一个就够了，lighthttp要关掉。</p>
 

<p> $(TOPDIR)/dl/nginx/nginx-http-flv-module</p>
<p> nginx version: nginx/1.16.1<br> vi /etc/nginx/ngixn.conf<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #user  nobody;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp&#123;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">  application live&#123;</span><br><span class="line">        allow publish 127.0.0.1;</span><br><span class="line">        allow play all;</span><br><span class="line">        live on ;</span><br><span class="line">        record off;</span><br><span class="line">        meta copy;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">       location  &#x2F;test&#123;</span><br><span class="line">           flv_live on;</span><br><span class="line">           chunked_transfer_encoding on; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">     #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">  #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">  #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 修改后重启<br> /etc/init.d/S50nginx  restart</p>
<p> 在线摄像头推流</p>
<p>ffmpeg -f v4l2 -framerate 10 -i /dev/video1 -q 10 -f flv rtmp://127.0.0.1/live/ming<br>//1 秒10帧，质量10</p>
<p> 下载播放器<br> <a href="https://www.videolan.org/" target="_blank" rel="noopener">https://www.videolan.org/</a></p>
<p> 播放器在线拉流：</p>
<p> 1、rtmp协议 (延时太大)—imx6ull性能差<br> rtmp://192.168.0.50/live/ming</p>
<p> 2、http flv协议<br> <a href="http://192.168.0.50/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://192.168.0.50/test?app=live&amp;stream=ming</a></p>
<p> <a href="http://31z6571r71.zicp.vip/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://31z6571r71.zicp.vip/test?app=live&amp;stream=ming</a></p>
<p>推送mp4文件（绝对路径）<br>ffmpeg -re -i ./test.mp4 -vcodec copy -acodec copy -f flv rtmp://127.0.0.1/live/ming</p>
<p>安装插件 flv.js<br>在线： <a href="http://player.pingos.io/flv/" target="_blank" rel="noopener">http://player.pingos.io/flv/</a></p>
<p>自定义<br>参考：<a href="https://www.cnblogs.com/saysmy/p/7851911.html" target="_blank" rel="noopener">https://www.cnblogs.com/saysmy/p/7851911.html</a><br>参考：<a href="https://blog.csdn.net/string_kai/article/details/100598268" target="_blank" rel="noopener">https://blog.csdn.net/string_kai/article/details/100598268</a></p>
<p>原理：<br>ngnix把flv流传给flv.js插件，转换为html语言，我们就可以用浏览器访问。<br>妙！QAQ</p>
<p>my.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; http-equiv&#x3D;&quot;Content-Type&quot;&gt;</span><br><span class="line">    &lt;title&gt;flv.js demo&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .mainContainer &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 1024px;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .urlInput &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-top: 8px;</span><br><span class="line">            margin-bottom: 8px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .centeredVideo &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 576px;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-bottom: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .controls &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            text-align: left;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-top: 8px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .logcatBox &#123;</span><br><span class="line">            border-color: #CCCCCC;</span><br><span class="line">            font-size: 11px;</span><br><span class="line">            font-family: Menlo, Consolas, monospace;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            text-align: left;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class&#x3D;&quot;mainContainer&quot;&gt;</span><br><span class="line">        &lt;video name&#x3D;&quot;videoElement&quot; class&#x3D;&quot;centeredVideo&quot; id&#x3D;&quot;videoElement&quot; controls width&#x3D;&quot;1024&quot; height&#x3D;&quot;576&quot; autoplay&gt;</span><br><span class="line">            Your browser is too old which doesn&#39;t support HTML5 video.</span><br><span class="line">        &lt;&#x2F;video&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;flv.js&#x2F;1.5.0&#x2F;flv.js&quot;&gt;&lt;&#x2F;script&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         if (flvjs.isSupported()) &#123;</span><br><span class="line">            startVideo()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function startVideo()&#123;</span><br><span class="line">            var videoElement &#x3D; document.getElementById(&#39;videoElement&#39;);</span><br><span class="line">            var flvPlayer &#x3D; flvjs.createPlayer(&#123;</span><br><span class="line">                type: &#39;flv&#39;,</span><br><span class="line">                isLive: true,</span><br><span class="line">                hasAudio: true,</span><br><span class="line">                hasVideo: true,</span><br><span class="line">                enableStashBuffer: true,</span><br><span class="line">                url: &#39; http:&#x2F;&#x2F;192.168.0.50&#x2F;test?app&#x3D;live&amp;stream&#x3D;ming&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">            flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">            flvPlayer.load();</span><br><span class="line">            flvPlayer.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        videoElement.addEventListener(&#39;click&#39;, function()&#123;</span><br><span class="line">            alert( &#39;是否支持点播视频：&#39; + flvjs.getFeatureList().mseFlvPlayback + &#39; 是否支持httpflv直播流：&#39; + flvjs.getFeatureList().mseLiveFlvPlayback )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        function destoryVideo()&#123;</span><br><span class="line">            flvPlayer.pause();</span><br><span class="line">            flvPlayer.unload();</span><br><span class="line">            flvPlayer.detachMediaElement();</span><br><span class="line">            flvPlayer.destroy();</span><br><span class="line">            flvPlayer &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function reloadVideo()&#123;</span><br><span class="line">            destoryVideo()</span><br><span class="line">            startVideo()</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/9.JPG" class="">

<p>放在ARM板子上，nginx 192.168.0.50访问<br>cd /usr/html</p>
<blockquote>
<p>index.html //清空</p>
</blockquote>
<p>index.html -&gt;my.html</p>
<p>成功了！（没推送不能看哦O v O）</p>
<iframe src="//player.bilibili.com/player.html?aid=456609119&bvid=BV1k5411a7RK&cid=217933031&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%"> </iframe>

<p>👉👉<a href="http://31z6571r71.zicp.vip/test?app=live&stream=ming" target="_blank" rel="noopener">点击此处链接观看视频链接</a></p>
<p>👉👉<a href="/my.html">点击此处博客观看视频链接</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习方案一</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%B8%80/</url>
    <content><![CDATA[<p>JPEG(简称JPG，小，静态图片)</p>
<p>MJPG(动态的视频编码格式，大，近似多个JPEG的组合)<br>传递完整的两个帧格式，所以处理器性能要求不高。</p>
<p>buildroot 安装mjpg-streamer</p>
<p>根目录运行命令</p>
<p>在线传输<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_uvc.so -d /dev/video0 -f 30 -q 90 -n” -o “/usr/lib/mjpg-streamer/output_http.so -w /usr/share/mjpg-streamer/www”</p>
<p>存储在tmp文件<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_uvc.so -d /dev/video0 -f 30 -q 90 -n” -o “/usr/lib/mjpg-streamer/output_file.so -f /tmp”</p>
<p>推送tmp文件里的<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_file.so -e -f /tmp” -o “/usr/lib/mjpg-streamer/output_http.so -w /usr/share/mjpg-streamer/www”</p>
<p><a href="http://192.168.0.50:8080/" target="_blank" rel="noopener">http://192.168.0.50:8080/</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>不错的网站：<a href="https://www.te.com.cn/" target="_blank" rel="noopener">https://www.te.com.cn/</a><br>达尔闻<a href="https://course.darwinlearns.com/detail/v_5e9e57c0c81f5_w4Ey3mm9/3" target="_blank" rel="noopener">https://course.darwinlearns.com/detail/v_5e9e57c0c81f5_w4Ey3mm9/3</a></p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/1.JPG" class="">

<p><strong>方案一：</strong></p>
<p>mjpg-streamer 运行在开发板，手机浏览器直接看。ARM性能要求不高。<br>缺点：<br>1、要实现内网穿透。<br>2、一款免费基于IP地址的视频流服务,声音不能传，不维护，只做学习。</p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/2.JPG" class="">

<p><strong>方案二:</strong><br>流媒体方案（一边下载一边观看）<br>互联网 -服务器-推送拉取— 》涉及流媒体协议</p>


<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/4.JPG" class="" title="特点区别">


<p>选择开源软件方案：</p>
<p>推流段：ffmpeg<br>（rtmp协议）<br>流媒体服务器：nginx<br>(http flv协议)<br>拉流端：浏览器/播放器</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux CAN</title>
    <url>/Linux-Lover/Linux-CAN/</url>
    <content><![CDATA[<p><strong>CAN总线</strong></p>
<p>CAN 的全称为 Controller Area Network，也就是控制局域网络，简称为 CAN。</p>
<p>CAN 的特点主要有一下几点：<br>①、多主控制<br>在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元同时开始发送消<br>息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而<br>是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个<br>位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的<br>单元则立刻停止发送而进行接收工作。</p>
<p>③、通信速度快，距离远<br>最高 1Mbps（距离小于 40M），最远可达 10KM（速率低于 5Kbps）。<br>④、具有错误检测、错误通知和错误恢复功能</p>
<p>⑥、连接节点多</p>
<p>CAN 总线使用两根线来连接各个单元：CAN_H 和 CAN_L.</p>
<p>显性电平表示逻<br>辑“0”，此时 CAN_H 电平比 CAN_L 高，分别为 3.5V 和 1.5V，电位差为 2V。隐形电平表示<br>逻辑“1”，此时 CAN_H 和 CAN_L 电压都为 2.5V 左右，电位差为 0V。</p>
<p><strong>CAN协议</strong></p>
<p>CAN 协议提供了 5 种帧格式来传输<br>数据：数据帧、遥控帧、错误帧、过载帧和帧间隔。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-IIC</title>
    <url>/Linux-Lover/nux-IIC/</url>
    <content><![CDATA[<p><strong>IIC 总线</strong></p>
<p>内核也将 I2C 驱动分为两部分：<br>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c_adapter&#x2F;* I2C 适配器(控制器)抽象*&#x2F;</span><br><span class="line">  -&gt;i2c_algorithm&#x2F;*  总线访问算法 *&#x2F;</span><br><span class="line">		-&gt;master_xfer&#x2F;* I2C 适配器的传输函数*&#x2F;</span><br><span class="line"></span><br><span class="line">两个函数向系统注册设置好</span><br><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">int i2c_add_numbered_adapter(struct i2c_adapter *adap)</span><br><span class="line"></span><br><span class="line">删除 I2C 适配器的话使用 i2c_del_adapter 函数即可，函数原型如下：</span><br><span class="line">void i2c_del_adapter(struct i2c_adapter * adap)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用 i2c_imx_start 函数开启 I2C 通信。</span><br><span class="line">如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数。</span><br><span class="line">向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来</span><br><span class="line">完成写数据。</span><br><span class="line">如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。</span><br><span class="line">I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap,</span><br><span class="line">struct i2c_msg *msgs,</span><br><span class="line">int num</span><br></pre></td></tr></table></figure>


<p>ls /sys/bus/i2c/devices</p>
<p>cd /sys/bus/i2c/devices</p>
<p>cat 0-001e/name //查看设备名字</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>RGB4.3寸触摸屏800*400</title>
    <url>/Linux-Lover/3%E5%AF%B8%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
    <content><![CDATA[<p>掌握 linux 下的触摸屏上报时序，大多数都是 Type B 类型</p>
<p>input_mt_init_slots  函数<br>input_mt_init_slots(gt9147.input, MAX_SUPPORT_POINTS, 0); //多少点数</p>
<p>input_mt_slot  函数<br>input_mt_slot(dev-&gt;input, id);</p>
<p>input_mt_report_slot_state 函数</p>
<p>函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE<br>事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，<br>ABS_MT_TOOL_TYPE 事件指定触摸类型（是笔还是手指等）。</p>
<p> input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、<br>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。</p>
<p>input_report_abs 函数<br> input_report_abs(dev-&gt;input, ABS_MT_POSITION_X, input_x);<br> input_report_abs(dev-&gt;input, ABS_MT_POSITION_Y, input_y);</p>
<p>input_mt_report_pointer_emulation 函数</p>
<p>input_mt_report_pointer_emulation(dev-&gt;input, true);</p>
<p>1、驱动文件<br>2、修改设备树</p>
<p>ls /dev/input</p>
<p>cat /dev/interrput  看中断触发次数</p>
<p>配置 tslib<br>打开/etc/ts.conf 文件，找到下面这一行：<br>module_raw input<br>如果上面这句前面有“#”的话就删除掉“#”。<br>打开/etc/profile 文件，在里面加入如下内容：<br>示例代码 64.5.1.1 /etc/profile 文件添加的内容<br>export TSLIB_TSDEVICE=/dev/input/event1 (不同设备可能不同)<br>export TSLIB_CALIBFILE=/etc/pointercal<br>export TSLIB_CONFFILE=/etc/ts.conf<br>export TSLIB_PLUGINDIR=/lib/ts<br>export TSLIB_CONSOLEDEVICE=none<br>export TSLIB_FBDEVICE=/dev/fb0</p>
<p>source /etc/profile<br>ts_calibrate<br>根文件目录输出：<br>input: gt9147 as /devices/platform/soc/2100000.aips-bus/21a4000.i2c/i2c-1/1-0014/input/input3</p>
<p>这是单点触摸的上报函数：<br>input_report_abs(ts-&gt;input_dev, ABS_X, x);<br>input_report_abs(ts-&gt;input_dev, ABS_Y, y);<br>input_report_abs(ts-&gt;input_dev, ABS_PRESSURE, 1);<br>input_sync(ts-&gt;input_dev);<br>这是多点触摸的上报函数：<br>input_report_abs(ts-&gt;input_dev, ABS_MT_POSITION_X, x);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_POSITION_Y, y);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_TOUCH_MAJOR, w);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_WIDTH_MAJOR, w);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_TRACKING_ID, id);<br>input_mt_sync(ts-&gt;input_dev);</p>
<p><strong>血的教训</strong></p>
<p>在本实验中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而不是前面编译<br>为模块对应的 event2，这一点一定要注意！</p>
<p>qt环境变量设置：</p>
<p>arm-stlib环境变量设置：</p>
<p>hexdump触摸小计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x2f，为 ABS_MT_SLOT，value&#x3D;0，上报的是第一个触摸点坐标。</span><br><span class="line"> type 为 0x3 ，  一 个 EV_ABS 事 件 ， code 为 0x39 ，是ABS_MT_TRACKING_ID ，value&#x3D;5 说明给 SLOT0 分配的 ID 为 5</span><br><span class="line"></span><br><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x35，为 ABS_MT_POSITION_X，value&#x3D;0x03ec&#x3D;1004，说明触摸点 X 轴坐标为 1004，属于屏幕右上角区域。</span><br><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x36，为 ABS_MT_POSITION_Y，是触摸点的 Y 轴坐标。value&#x3D;0x17&#x3D;23，说明 Y 轴坐标为 23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</span><br><span class="line"></span><br><span class="line">type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x1 表</span><br><span class="line">示触摸屏被按下。</span><br><span class="line">type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。type为0x3，是一个EV_ABS事件，code为0x39，也就是ABS_MT_TRACKING_ID，</span><br><span class="line">value&#x3D;0xffffffff&#x3D;-1，说明触摸点离开了屏幕。</span><br><span class="line">第 10 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x0</span><br><span class="line">表示手指离开触摸屏，也就是触摸屏没有被按下了</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC驱动了解🏃</title>
    <url>/Linux-Lover/RTC%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>RTC 设备驱动是一个标准的字符设备驱动</p>
<p> rtc_device 结构体</p>
<p> rtc_class_ops 结构体</p>
<p>rtc_dev_ioctl() 函数就会执行，操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。</p>
<p>snvs_rtc_ops 操作集</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct rtc_device *rtc_device_register(const char *name,</span><br><span class="line">                  struct device *dev,</span><br><span class="line">                  const struct rtc_class_ops *ops,</span><br><span class="line">                  struct module *owner)</span><br><span class="line">                  </span><br><span class="line">struct rtc_device *rtc_device_register(const char *name,</span><br><span class="line">                      struct device *dev,</span><br><span class="line">                      const struct rtc_class_ops *ops,</span><br><span class="line">                      struct module *owner)</span><br></pre></td></tr></table></figure>
<p> platform_get_resource 函数从设备树中获取到 RTC 外设寄存器基地址</p>
<p> 函数 devm_ioremap_resource 完成内存映射，得到 RTC 外设寄存器物理基<br>地址对应的虚拟地址。</p>
<p>snvs-rtc.c 文件会采用 regmap 机制来读写RTC 底层硬件寄存器。<br>这里使用 devm_regmap_init_mmio 函数将 RTC 的硬件寄存器转化为regmap 形式，这样 regmap 机制的 regmap_write、regmap_read 等 API 函数才能操作寄存器。<br>devm_rtc_device_register 函数向系统注册 rtc_devcie</p>
<p>调用 rtc_read_lp_counter 获取 RTC 计数值，这个时间值是秒数</p>
<p>调用 rtc_time_to_tm 函数将获取到的秒数转换为时间值</p>
<p> rtc_read_lp_counter 函数，此函数用于读取 RTC 计数值</p>
<p>测试</p>
<p>设置当前时间为 2019 年 8 月 31 日 18:13:00<br>date -s “2019-08-31 18:13:00”</p>
<p>此时间还没有写入到I.MX6U 内部 RTC 里面或其他的 RTC 芯片里面<br>hwclock -w  //将当前系统时间写入到 RTC 里面</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Framebuffer驱动</title>
    <url>/Linux-Lover/ramebuffer-%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Framebuffer 抽象为一个叫做 fb_info 的结构体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info</p>
<p>内核内存分配函数<br>函数devm_kzalloc（）和kzalloc（）一样都是内核内存分配函数，但是devm_kzalloc（）是跟设备有关的，自动释放。当内存不在使用时，可以使用函数devm_kfree（）释放。<br>而kzalloc（）则需要手动释放使用kfree（），实现了kmalloc()+memset()的功能</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile报错记录</title>
    <url>/Makefile-Lover/Makefile%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错：</span><br><span class="line">Your display is too small to run Menuconfig!</span><br><span class="line">It must be at least 19 lines by 80 columns.</span><br><span class="line">Makefile:950: recipe for target &#39;menuconfig&#39; failed</span><br><span class="line">make[1]: *** [menuconfig] Error 1</span><br><span class="line">Makefile:84: recipe for target &#39;_all&#39; failed</span><br><span class="line">make: *** [_all] Error 2</span><br><span class="line"></span><br><span class="line">make menuconfig配置内核时出错</span><br><span class="line">Makefile:</span><br><span class="line">解决：</span><br><span class="line">窗口太小的原因，把terminal变大就可以显示。QaQ</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Wall表示显示编译的时候所有警告nostdib表示不链接系统标准启动文件和文件,否则编译可能会出错.-O2表示优等级,和MDK上的设置含义一样</span><br><span class="line"></span><br><span class="line">通过printf： @echo 调试变量值。</span><br></pre></td></tr></table></figure>

<img src="/Makefile-Lover/Makefile%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/1.jpg" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gcc编译时遇到&quot;inline function &#39;*** declared butnever defined&quot;问题</span><br><span class="line"></span><br><span class="line">解决：-fgnu89-inline</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-march&#x3D;armv7-a -mfpu&#x3D;neon-vfpv4 -mfloat-abi&#x3D;hard   浮点数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;浮点数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>#pragma pack</title>
    <url>/C-C-Lover/ragma-pack/</url>
    <content><![CDATA[<p>#pragma pack(push)保存对齐状态</p>
<p>#pram pack(4)设定4字节</p>
<p>voif func();</p>
<p>#pragma pack(pop)//恢复对齐</p>
<p>注意：from dalao  ！！！</p>
<p>c51 默认按照1字节对其，没有存在字节对齐问题.<br>keil工程编译不报错，语句无效。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断(正旭)</title>
    <url>/Linux-Lover/Linux%E4%B8%AD%E6%96%AD-%E6%AD%A3%E6%97%AD/</url>
    <content><![CDATA[<p>中断</p>
<p>Linux不用FIQ，只用到了IRQ</p>
<p>中断服务有没有参数主要是看中断发生在裸机上还是实时系统中</p>
<p>linux中断流程</p>
<p>Linux不用FIQ，只用到了IRQ</p>
<p>linux的中断处理都是在SVC模式下处理的。</p>
<p>当发生中断的时候，代码运行在内核空间</p>
<p>IRQ执行的时候很快</p>
<p>在IRQ回到SVC模式时候 R0存着irqnumber</p>
<p>在SVC模式的内核栈上保存中断时候正在执行任务的寄存器状态 R1-R12 。 R0保存在IRQ那边的内核栈。</p>
<p>随后会再搬到SVC的内核栈上</p>
<p>总结分为7点：</p>
<p>Linux对中断的扩展：硬件中断，软件中断</p>
<p>中断处理原则1：不能嵌套</p>
<p>中断处理原则2：越快越好</p>
<p>要处理的事情实在太多：拆分为：上半部，下半部</p>
<p>下半部的事情耗时不是太长：tasklet</p>
<p>下半部要做的事情太多并且很复杂：工作队列</p>
<p>新技术：threaded irq</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>交换两个变量的值，不使用第三个变量</title>
    <url>/C-C-Lover/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;</p>
<p>答案：有两种解法, 一种用算术算法, 一种用^(异或) </p>
<p>a = a + b; </p>
<p>b = a - b;</p>
<p> a = a - b;    //溢出问题</p>
<p>or</p>
<p> a = a^b;// 只能对int,char..</p>
<p> b = a^b; </p>
<p>a = a^b;</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt编译报错</title>
    <url>/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>报错make: Nothing to be done for ‘first’</p>
<p>可执行程序已经存在。<br>/usr/bin/ld: main.o：普通ELF重定位（M: 40）<br>make cc 修改</p>
<img src="/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/1.JPG" class="">

<img src="/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/2.JPG" class="">


<p>非root用户运行无问题，切换到root用户或者以sudo方式运行出现问题。<br>QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to ‘/tmp/runtime-root’这个好像不影响页面显示</p>
<p>版本兼容问题<br>CONFIG += c++11  //添加标准</p>
<p>linux qt 不支持中文输入<br>/opt/Qt5.5.1/Tools/QtCreator/bin/plugins/platforminputcontexts/libcomposeplatforminputcontextplugin.so </p>
<p>cast from ‘void*’ to ‘int’ loses precision<br>数据类型变小如int long</p>
<p>图标报错<br>RC_ICONS += ming.ico<br><a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a><br>要用专业软件转化格式</p>
<p>字体不显示<br>usr文件夹-&gt;share文件夹-&gt;fronts文件夹-&gt;字体.otf</p>
<p>空指针引起报错，crash down </p>




]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>buildroot根文件 移植qt库</title>
    <url>/Linux-Lover/ildroots/</url>
    <content><![CDATA[<p>buildroot下配置 busybox </p>
<p>sudo make busybox-menuconfig<br>sudo make busybox<br>sudo make<br>两者关系：buildroot用busybox的命令</p>
<p>设置命令路径格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改&#x2F;etc&#x2F;profile 文件</span><br><span class="line">PS1&#x3D;&#39;[\u@\h]:\w$:&#39;</span><br><span class="line">export PS1</span><br><span class="line">设置 PS1 环境变量，格式就是：</span><br><span class="line">[user@hostname]:currentpath$:</span><br></pre></td></tr></table></figure>


<p>运行：<br> ./mytest -platform linuxfb<br> 静态编译全部</p>
<p>两个终端</p>
<p>打开开发板根文件系统中的/etc/inittab 文件，在里面加入下面这一行：<br>tty1::askfirst:-/bin/sh</p>
<p>echo hello ming &gt;/dev/tty1</p>
<p> LCD  自动关闭解决方法</p>
<p>1按键盘唤醒<br>2关闭10分钟熄屏功能<br>drivers/tty/vt/vt.c 这个文件<br>static int blankinterval = 10*60;  //0 则关闭<br>3 编写一个 APP 关闭10分钟熄屏功能</p>
<p>调节亮度<br>cd /sys/devices/platform/backlight/backlight/backligh<br>echo 5 &gt; brightness</p>
<p>eth0：link down？<br>vi /etc/init.d/rcs<br>ifconfig eth0 192.168.0.50<br>ifconfig eth0 up</p>
<p>注意三个文件：<br><code><br>/etc/passwd                存储用户的关键信息<br>/etc/group                存储用户组的关键信息<br>/etc/shadow                存储用户的密码信息<br></code></p>
<p>环境变量配置<br>vim /ect/profile<br>正点原子中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而驱动编译为模块对应的 event2，这一点一定要注意!!!!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin&quot;</span><br><span class="line"></span><br><span class="line">PS1&#x3D;&#39;[\u@\h]:\w$:&#39;</span><br><span class="line">export PS1</span><br><span class="line"></span><br><span class="line">#if [ &quot;$PS1&quot; ]; then</span><br><span class="line">#       if [ &quot;&#96;id -u&#96;&quot; -eq 0 ]; then</span><br><span class="line">#               export PS1&#x3D;&#39;# &#39;</span><br><span class="line">#       else</span><br><span class="line">#               export PS1&#x3D;&#39;$ &#39;</span><br><span class="line">#       fi</span><br><span class="line">#fi</span><br><span class="line"></span><br><span class="line">export PAGER&#x3D;&#39;&#x2F;bin&#x2F;more&#39;</span><br><span class="line">export EDITOR&#x3D;&#39;&#x2F;bin&#x2F;vi&#39;</span><br><span class="line"></span><br><span class="line">export TSLIB_ROOT&#x3D;&#x2F;arm-tslib</span><br><span class="line">export TSLIB_CONSOLEDEVICE&#x3D;none</span><br><span class="line">export TSLIB_FBDEVICE&#x3D;&#x2F;dev&#x2F;fb0</span><br><span class="line">export TSLIB_TSDEVICE&#x3D;&#x2F;dev&#x2F;input&#x2F;event2</span><br><span class="line">export TSLIB_CONFFILE&#x3D;$TSLIB_ROOT&#x2F;etc&#x2F;ts.conf</span><br><span class="line">export TSLIB_PLUGINDIR&#x3D;$TSLIB_ROOT&#x2F;lib&#x2F;ts</span><br><span class="line">export TSLIB_CALIBFILE&#x3D;&#x2F;etc&#x2F;pointercal</span><br><span class="line">export LD_PRELOAD&#x3D;$TSLIB_ROOT&#x2F;lib&#x2F;libts.so</span><br><span class="line">export QT_QPA_FB_TSLIB&#x3D;1QT_QPA_FB_TSLIB&#x3D;1</span><br><span class="line"></span><br><span class="line">echo &quot;tslib init success !!!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export QT_ROOT&#x3D;&#x2F;usr&#x2F;lib&#x2F;qt</span><br><span class="line">export QT_QPA_GENERIC_PLUGINS&#x3D;tslib:&#x2F;dev&#x2F;input&#x2F;event2</span><br><span class="line">export QT_QPA_FONTDIR&#x3D;&#x2F;arm-qt&#x2F;lib&#x2F;fonts</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH&#x3D;$QT_ROOT&#x2F;plugins</span><br><span class="line">export QT_QPA_PLATFORM&#x3D;linuxfb:tty&#x3D;&#x2F;dev&#x2F;fb0</span><br><span class="line">export QT_PLUGIN_PATH&#x3D;$QT_ROOT&#x2F;plugins</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$QT_ROOT&#x2F;lib:$QT_ROOT&#x2F;plugins&#x2F;platforms</span><br><span class="line">export QTWEBENGINE_DISABLE_SANDBOX&#x3D;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;qt env init success !!!&quot;</span><br><span class="line"></span><br><span class="line"># Source configuration files from &#x2F;etc&#x2F;profile.d</span><br><span class="line">for i in &#x2F;etc&#x2F;profile.d&#x2F;*.sh ; do</span><br><span class="line">        if [ -r &quot;$i&quot; ]; then</span><br><span class="line">                . $i</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">unset i</span><br></pre></td></tr></table></figure>
























<p>移植qt库：<a href="https://blog.csdn.net/jkl_wyl/article/details/103437465" target="_blank" rel="noopener">https://blog.csdn.net/jkl_wyl/article/details/103437465</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和栈</title>
    <url>/C-C-Lover/%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    <content><![CDATA[<p>堆和栈的分别，优缺点，堆的大小是多少，栈的大小是多少？__</p>
<p><strong>栈区（stack）</strong></p>
<p>（1）由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈<br>（2）栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>（3）栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M或者1M，总之是一个编译时就确定的常数 )<br>（4）如果申请的空间超过栈的剩余空间时，异常提示.空间较小。</p>
<p>扩展：当本次函数调用节束后,局部变量先出栈,然后是参数,最后栈顶指针指向最开始存的也址,也就是主函数中的下一条指令,程序由该点继续运行</p>
<p>优点：<br>1.高速，在栈上分配内存是非常快的。<br>2.简单，栈对象有自己的生命周期，你永远不可能发生内存泄露。因为他总是在超出他的作用域时被自动销毁了。<br>3、系统自动申请效率快，但无法控制。</p>
<p>缺点：栈对象严格的定义了生命周期也是其主要的缺点</p>
<p><strong>堆区（heap）</strong></p>
<p>（1）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>（2）一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br>（3）堆是向高地址扩展的数据结构，是不连续的内存区域。<br>这是由于系统是用链表来存储的空闲内存地址的，<br>自然是不连续的，而链表的遍历方向是由低地址向高地址。<br>（4）堆的大小受限于计算机系统中有效的虚拟内存。堆获得的空间比较灵活，也比较大。<br>（5）申请效率慢，产生内存碎片</p>
<p>优点：可以自己控制对象的生命周期。<br>缺点：需要程序员手动释放，容易造成内存泄漏。</p>
<p>//main.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 0; &#x2F;&#x2F;全局区初始化</span><br><span class="line">char *p1 ;&#x2F;&#x2F;全局区域未初始化</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">int b ; ?&#x2F;&#x2F;栈</span><br><span class="line">char s[] &#x3D; &quot;abc&quot;;&#x2F;&#x2F;栈</span><br><span class="line">char *p2;&#x2F;&#x2F;栈</span><br><span class="line">char *p3 &#x3D; &quot;123456&quot;;&#x2F;&#x2F;p3栈  &quot;123456&quot; 在全局区的常量区</span><br><span class="line">static int c &#x3D; 0; &#x2F;&#x2F;全局静态常量</span><br><span class="line">p1&#x3D; (char*) malloc(10); ?&#x2F;&#x2F;堆 10字节区域 ?p1仍在栈</span><br><span class="line">p2 &#x3D; (char*)malloc(20);  &#x2F;&#x2F;堆  20字节区域  p2仍在栈</span><br><span class="line"></span><br><span class="line">strcpy(p1,&quot;123456&quot;);&#x2F;&#x2F;p1 &#x3D;&#x3D; p3 编译器优化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/C-C-Lover/%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h5 id="字符串长度题"><a href="#字符串长度题" class="headerlink" title="字符串长度题"></a>字符串长度题</h5><p>字符串”\\”A100\”\”的长度是多少？</p>
<p> \ 要用 \ 表示,” 要用 &quot; 表示,共8个长度</p>
<h5 id="字符转化之’0’的妙用"><a href="#字符转化之’0’的妙用" class="headerlink" title="字符转化之’0’的妙用"></a>字符转化之’0’的妙用</h5><p>整数转化为字符思路</p>
<p>例如整数 12345</p>
<p>1、存储到char 数组+‘0’<br>2、倒序<br>3、输出</p>
<p>函数：itoa();</p>
<p>字符串转化整数<br>char temp[7] = {‘1’,’2’,’3’,’4’,’5’,’6’,’\0’};</p>
<p>while(temp[i])<br>{<br>    sum = sum*10+(sum[i]-‘0’);<br>    i++;<br>}<br>因为减去‘0’，就隐式转化成int整数</p>
<h5 id="字符函数自写"><a href="#字符函数自写" class="headerlink" title="字符函数自写"></a>字符函数自写</h5><p>char * strcpy1(char <em>strdest,const char *strSrc)<br>{<br>assert(strdest!=NULL &amp;&amp; strSrc!=NULL);<br>char * addr = strdest;<br>while(  (</em>strdest ++ =*strSrc)!= ‘\0’ )<br>{<br>        NULL;<br>}<br>return addr;<br>}</p>
<p>int length = strlen(strcpy(strdest,”hello word”));</p>
<h5 id="字符之库函数应用"><a href="#字符之库函数应用" class="headerlink" title="字符之库函数应用"></a>字符之库函数应用</h5><p>strcpy和memcpy都是标准C库函数<br>即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。<br>char* strcpy(char* dest, const char* src);</p>
<p>memcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。<br>void *memcpy( void *dest, const void *src, size_t count );</p>
<h5 id="字符串问题�"><a href="#字符串问题�" class="headerlink" title="字符串问题�"></a>字符串问题�</h5>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>参考约束</title>
    <url>/MySql-Lover/%E8%80%83%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>6、假设有下面两个关系模式:<br>职工(职工号,姓名,年龄,职务,工资,部门号),其中职工号为主码;<br>部门(部门号,名称,经理名,电话),其中部门号为主码。<br>用SQL语言定义这两个关系模式,要求在模式中完成以下完整性约束条件的定义:<br>(1)定义每个模式的主码;<br>(2)定义参照完整性;<br>(3)定义职工年龄不得超过60岁；</p>
<p>CREATE TABLE 职工<br>(<br>职工号 CHAR(5) PRIMARY KEY,<br>姓名 CHAR(8) NOT NULL,<br>年龄 SMALLINT,<br>职务 CHAR(10),<br>工资 DECIMAL (7,2 ),<br>部门号 CHAR(5)<br>);</p>
<p>CREATE TABLE 部门<br>(<br>部门号 CHAR(5)PRIMARY KEY,<br>名称 CHAR(20),<br>经理名 CHAR(8)NOT NULL,<br>电话 CHAR(8)<br>);</p>
<p>ALTER TABLE 职工<br>ADD CONSTRAINT C1 CHECK(年龄 &lt; 60);</p>
<p>ALTER TABLE 职工<br>ADD CONSTRAINT C2 FOREIGN KEY (部门号) REFERENCES 部门(部门号);/<em>参考完整性约束</em>/</p>
<p>select * from 职工;<br>select * from 部门;</p>
<p>表级约束与列级约束？表级用于联合约束。</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>INPUT子系统</title>
    <url>/Linux-Lover/NPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>INPUT子系统</strong></p>
<p>   管理输入的子系统<br>   input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点.</p>
<p>   input 子系统的所有设备主设备号都为 13，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个<code>input_device</code> 即可</p>
<p>   input_dev 结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line"> const char *name;</span><br><span class="line"> const char *phys;</span><br><span class="line"> const char *uniq;</span><br><span class="line"> struct input_id id;</span><br><span class="line"></span><br><span class="line"> unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line"> unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; /* 事件类型的位图 */</span><br><span class="line"> unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; /* 按键值的位图 */</span><br><span class="line"> unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; /* 相对坐标的位图 */</span><br><span class="line"> unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; /* 绝对坐标的位图 */</span><br><span class="line"> unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; /* 杂项事件的位图 */</span><br><span class="line"> unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; /*LED 相关的位图 */</span><br><span class="line"> unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];/* sound 有关的位图 */</span><br><span class="line"> unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; /* 压力反馈的位图 */</span><br><span class="line"> unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; /*开关状态的位图 */</span><br><span class="line">......</span><br><span class="line"> bool devres_managed;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其中，evbit()输入事件类型</p>
<p>#define EV_SYN 0x00 /* 同步事件 <em>/<br>#define EV_KEY 0x01 /</em> 按键事件 <em>/<br>#define EV_REL 0x02 /</em> 相对坐标事件 <em>/<br>#define EV_ABS 0x03 /</em> 绝对坐标事件 <em>/<br>#define EV_MSC 0x04 /</em> 杂项(其他)事件 <em>/<br>#define EV_SW 0x05 /</em> 开关事件 <em>/<br>#define EV_LED 0x11 /</em> LED <em>/<br>#define EV_SND 0x12 /</em> sound(声音) <em>/<br>#define EV_REP 0x14 /</em> 重复事件 <em>/<br>#define EV_FF 0x15 /</em> 压力事件 <em>/<br>#define EV_PWR 0x16 /</em> 电源事件 <em>/<br>#define EV_FF_STATUS 0x17 /</em> 压力状态事件 */</p>
<p>按键连按：EV_KEY 、EV_REP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、申请一个 input_dev 结构体</span><br><span class="line">struct input_dev *input_allocate_device(void)</span><br><span class="line">注销</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*********第一种设置事件和事件值的方法***********&#x2F;</span><br><span class="line"> __set_bit(EV_KEY, inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F;</span><br><span class="line"> __set_bit(EV_REP, inputdev-&gt;evbit); &#x2F;* 重复事件 *&#x2F;</span><br><span class="line"> __set_bit(KEY_0, inputdev-&gt;keybit); &#x2F;*设置产生哪些按键值 *&#x2F;</span><br><span class="line"> &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*********第二种设置事件和事件值的方法***********&#x2F;</span><br><span class="line"> keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |</span><br><span class="line">BIT_MASK(EV_REP);</span><br><span class="line"> keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D;</span><br><span class="line">BIT_MASK(KEY_0);</span><br><span class="line"> &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*********第三种设置事件和事件值的方法***********&#x2F; keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |</span><br><span class="line">BIT_MASK(EV_REP);</span><br><span class="line">input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">&#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、上报输入事件</span><br><span class="line">但是具体是什么样的输入值 Linux 内核是不知道的.,我们需要获取到具体</span><br><span class="line">的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核</span><br><span class="line"></span><br><span class="line">void input_event(struct input_dev *dev,</span><br><span class="line">            unsigned int type,</span><br><span class="line">            unsigned int code,</span><br><span class="line">            int value)</span><br><span class="line">其他函数都是基于上面的函数而来。</span><br><span class="line"></span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_switch(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_mt_sync(struct input_dev *dev) </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">input_sync 函数来告诉 Linux 内核 input 子系统上报结束</span><br><span class="line"></span><br><span class="line">void input_sync(struct input_dev *dev)&#x2F;* 同步事件 *&#x2F;</span><br><span class="line"></span><br><span class="line">3、input_event  结构体</span><br><span class="line"></span><br><span class="line">struct input_event &#123;</span><br><span class="line"> struct timeval time;   &#x2F;*事件发生的时间*&#x2F;</span><br><span class="line"> __u16 type;          &#x2F;*事件类型*&#x2F;</span><br><span class="line"> __u16 code;			&#x2F;*事件码*&#x2F;</span><br><span class="line"> __s32 value;			&#x2F;*值*&#x2F;</span><br><span class="line"> &#125;;</span><br><span class="line">所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">驱动层</span><br><span class="line">#if  0</span><br><span class="line">    &#x2F;*  初始化 input_dev ，设 置产生哪些事件 *&#x2F;</span><br><span class="line">        __set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit); &#x2F;* 按键事件 *&#x2F;</span><br><span class="line">        __set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit); &#x2F;*  重复事件 *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;*  初始化 input_dev ，设置产生哪些按键 *&#x2F;</span><br><span class="line">        __set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);</span><br><span class="line">        ret &#x3D; input_register_device(keyinputdev.inputdev);</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">    #if  0</span><br><span class="line">        keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY)|BIT_MASK(EV_REP);</span><br><span class="line"></span><br><span class="line">        keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D;BIT_MASK(KEY_0);</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |BIT_MASK(EV_REP);</span><br><span class="line"></span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    应用层</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 定义一个 input_event 变量，存放输入事件信息 *&#x2F;</span><br><span class="line"> static struct input_event inputevent;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MISC驱动实验</title>
    <url>/Linux-Lover/SC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>MISC 驱动也叫做杂项驱动，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。<br>所有的 MISC 设备驱动的主设备号都为<code>10</code>，不同的设备使用不同的从设备号。</p>
<p>miscdevice 结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct miscdevice &#123;</span><br><span class="line">     int minor; /* 子设备号 */</span><br><span class="line">     const char *name; /* 设备名字 */</span><br><span class="line">     const struct file_operations *fops; /* 设备操作集 */</span><br><span class="line">     struct list_head list;</span><br><span class="line">     struct device *parent;</span><br><span class="line">     struct device *this_device;</span><br><span class="line">     const struct attribute_group **groups;</span><br><span class="line">     const char *nodename;</span><br><span class="line">     umode_t mode;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义。</p>
<p>int misc_register(struct miscdevice * misc);<br>int misc_deregister(struct miscdevice *misc);</p>
<p>ls /dev/miscbeep -l    查看主次设备号</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树自带driver</title>
    <url>/Linux-Lover/%E5%A4%87%E6%A0%91%E8%87%AA%E5%B8%A6driver/</url>
    <content><![CDATA[<p>打开 RED 这个 LED<br>echo 1 &gt; /sys/class/leds/red/brightness //打开 LED0<br>关闭 RED 这个 LED<br>echo 0 &gt; /sys/class/leds/red/brightness //关闭 LED0</p>
<p>linux,default-trigger = “heartbeat”; //系统闪烁</p>
<p>//开机自闪烁<br>linux,default-trigger = “heartbeat”;<br>default-state = “on”;</p>
<p>函数了解：</p>
<p>count = device_get_child_node_count(dev);函数统计子节点数量</p>
<p>device_for_each_child_node(dev, child) //遍历</p>
<p>led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);</p>
<p>fwnode_property_read_string（）；</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb与gdbserver</title>
    <url>/Linux-Lover/gdb%E4%B8%8Egdbserver/</url>
    <content><![CDATA[<p><strong>GDB移植</strong></p>
<p>arm-linux-gnueabihf-gcc 就自带了主机使用的 arm-linux-gnueabihf-gdb 和开发板所使用的 gdbserver。</p>
<p>arm-linux-gnueabihf-gcc gdbtest.c -o gdbtest -g //编译测试程序，注意-g 选项<br>arm-linux-gnueabihf-gdb gdbtest<br>target remote 192.168.0.50:2001 //连接到开发板上</p>
<p>gdbserver 192.168.0.128：2001 gdbtest //开发板连接主机</p>
<p>命令：</p>
<p>l 命令(list)用于列出所有程序源码<br>b 命令(break)用于设置断点<br>c 命令用于运行到断点出，输入 c 命令程序就会运行<br>s 命令(step)是单步运行执行，此函数会进入到函数里面。<br>n 命令(next)也是单步运行，但是 n 命令不会进入到函数里面。<br>p 命令(print)用于打印某个变量值。<br>q 命令(quit)用于退出调试，开发板上的 gdbserver 也会停止。</p>
<p>查看断点：</p>
<p>info break ;</p>
<p> VSCode+gdbserver  图形化调试</p>
<p> .vscode文件launch.json 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"gdbtest"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"<span class="variable">$&#123;workspaceFolder&#125;</span>/gdbtest"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"<span class="variable">$&#123;workspaceFolder&#125;</span>"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gdb"</span>,</span><br><span class="line">            <span class="string">"miDebuggerServerAddress"</span>: <span class="string">"192.168.0.50:2001"</span></span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>platform框架</title>
    <url>/Linux-Lover/platform-%E4%BB%A3%E7%A0%81%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<p>无设备树platform</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//device.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CCM_CCGR1_BASE (0X020C406C)</span></span><br><span class="line"><span class="comment">#define SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span></span><br><span class="line"><span class="comment">#define SW_PAD_GPIO1_IO03_BASE (0X020E02F4)</span></span><br><span class="line"><span class="comment">#define GPIO1_DR_BASE (0X0209C000)</span></span><br><span class="line"><span class="comment">#define GPIO1_GDIR_BASE (0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define REGISTER_LENGTH 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void led_release(struct device *dev)</span><br><span class="line"> &#123;</span><br><span class="line">    printk(<span class="string">"led device released!\r\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct resource led_resources[] = </span><br><span class="line">&#123;</span><br><span class="line">    [0] = &#123;</span><br><span class="line">    .start = CCM_CCGR1_BASE,</span><br><span class="line">    .end = (CCM_CCGR1_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] = &#123;</span><br><span class="line">    .start = SW_MUX_GPIO1_IO03_BASE,</span><br><span class="line">    .end = (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [2] = &#123;</span><br><span class="line">    .start = SW_PAD_GPIO1_IO03_BASE,</span><br><span class="line">    .end = (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [3] = &#123;</span><br><span class="line">    .start = GPIO1_DR_BASE,</span><br><span class="line">    .end = (GPIO1_DR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [4] = &#123;</span><br><span class="line">    .start = GPIO1_GDIR_BASE,</span><br><span class="line">    .end = (GPIO1_GDIR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    static struct platform_device leddevice = &#123;</span><br><span class="line">            .name = <span class="string">"imx6ul-led"</span>,</span><br><span class="line">            .id = -1,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">            .release = &amp;led_release,</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        .num_resources = ARRAY_SIZE(led_resources),</span><br><span class="line">        .resource = led_resources,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddevice_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_device_register(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> static void __exit leddevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddevice_init);</span><br><span class="line">module_exit(leddevice_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//driver.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEDDEV_CNT 1 /* 设备号长度 */</span></span><br><span class="line"><span class="comment">#define LEDDEV_NAME "platled" /* 设备名字 */</span></span><br><span class="line"><span class="comment">#define LEDOFF 0</span></span><br><span class="line"><span class="comment">#define LEDON 1</span></span><br><span class="line"></span><br><span class="line">static void __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line">static void __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line">static void __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line">static void __iomem *GPIO1_DR;</span><br><span class="line">static void __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct leddev_dev&#123;</span><br><span class="line">    dev_t devid;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    int  major;</span><br><span class="line">    int minor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct leddev_dev leddev ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*LED 打开关闭*/</span><br><span class="line">static void led_switch(u8 sta)</span><br><span class="line">&#123;</span><br><span class="line">    u32 val = 0;</span><br><span class="line">    <span class="keyword">if</span>(sta == LEDOFF)</span><br><span class="line">    &#123;</span><br><span class="line">            val = readl(GPIO1_DR);  /*打开灯*/</span><br><span class="line">            val &amp;= ~(1 &lt;&lt; 3 ) ;</span><br><span class="line">            writel(val,GPIO1_DR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDON)</span><br><span class="line">    &#123; </span><br><span class="line">            val = readl(GPIO1_DR);  /*打开灯*/</span><br><span class="line">            val |= (1 &lt;&lt; 3 ) ;</span><br><span class="line">            writel(val,GPIO1_DR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode,</span><br><span class="line">                     struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    filp-&gt;private_data = &amp;leddev ;</span><br><span class="line">    //printk(<span class="string">"chrdevbase open!\r\n"</span>);</span><br><span class="line">     <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">size_t cnt, loff_t *offt)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> int retvalue;</span><br><span class="line"> unsigned char databuf[1];</span><br><span class="line"> unsigned char ledstat;</span><br><span class="line"></span><br><span class="line"> retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; 0) &#123;</span><br><span class="line"> <span class="built_in">return</span> -EFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ledstat = databuf[0]; /* 获取状态值 */</span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line"> led_switch(LEDON); /* 打开 LED 灯 */</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line"> led_switch(LEDOFF); /* 关闭 LED 灯 */</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations led_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = led_open,</span><br><span class="line">            .write = led_write,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int ressize[5];</span><br><span class="line">    u32 val = 0;</span><br><span class="line">    struct resource *ledsource[5];</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"led driver and device has matched!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    /*获取资源*/</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; 5 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ledsource[i] =  platform_get_resource(dev,IORESOURCE_MEM,i);</span><br><span class="line">        <span class="keyword">if</span> (!ledsource[i]) &#123;</span><br><span class="line">                dev_err(&amp;dev-&gt;dev, <span class="string">"No MEM resource for always on\r\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ressize[i] = resource_size(ledsource[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        IMX6U_CCM_CCGR1  = ioremap(ledsource[0]-&gt;start, ressize[0]);</span><br><span class="line">        SW_MUX_GPIO1_IO03 = ioremap(ledsource[1]-&gt;start, ressize[1]);</span><br><span class="line">        SW_PAD_GPIO1_IO03 = ioremap(ledsource[2]-&gt;start, ressize[2]);</span><br><span class="line">        GPIO1_DR = ioremap(ledsource[3]-&gt;start, ressize[3]);</span><br><span class="line">        GPIO1_GDIR = ioremap(ledsource[4]-&gt;start, ressize[4]);</span><br><span class="line">    val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">    val &amp;= ~(3 &lt;&lt; 26); /* 清除以前的设置  */</span><br><span class="line">    val |= (3 &lt;&lt; 26); /* 设置新值 */</span><br><span class="line">    writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        writel(5, SW_MUX_GPIO1_IO03);</span><br><span class="line">        writel(0x10B0, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line">        val = readl(GPIO1_GDIR);</span><br><span class="line">        val &amp;= ~(1 &lt;&lt; 3); </span><br><span class="line">        val |= (1 &lt;&lt; 3);</span><br><span class="line">        writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">        val = readl(GPIO1_DR);</span><br><span class="line">        val |= (1 &lt;&lt; 3) ;</span><br><span class="line">        writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"> /* 注册字符设备驱动 */</span><br><span class="line">/*1、创建设备号 */</span><br><span class="line"> <span class="keyword">if</span> (leddev.major) &#123; /* 定义了设备号 */</span><br><span class="line"> leddev.devid = MKDEV(leddev.major, 0);</span><br><span class="line"> register_chrdev_region(leddev.devid, LEDDEV_CNT,LEDDEV_NAME);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; /* 没有定义设备号 */</span><br><span class="line"> alloc_chrdev_region(&amp;leddev.devid, 0, LEDDEV_CNT,</span><br><span class="line">LEDDEV_NAME);</span><br><span class="line"> leddev.major = MAJOR(leddev.devid);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 2、初始化 cdev */</span><br><span class="line"> leddev.cdev.owner = THIS_MODULE;</span><br><span class="line"> cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line"></span><br><span class="line"> /* 3、添加一个 cdev */</span><br><span class="line"> cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line"> /* 4、创建类 */</span><br><span class="line"> leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line"> <span class="built_in">return</span> PTR_ERR(leddev.class);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 5、创建设备 */</span><br><span class="line"> leddev.device = device_create(leddev.class, NULL, leddev.devid,</span><br><span class="line">NULL, LEDDEV_NAME);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line"> <span class="built_in">return</span> PTR_ERR(leddev.device);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">    iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">    iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">    iounmap(GPIO1_DR);</span><br><span class="line">    iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;leddev.cdev);</span><br><span class="line">    unregister_chrdev_region(leddev.devid, LEDDEV_CNT);</span><br><span class="line">    device_destroy(leddev.class, leddev.devid);</span><br><span class="line">    class_destroy(leddev.class);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static struct platform_driver led_driver = &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">"imx6ul-led"</span>, /* 驱动名字，用于和设备匹配 */</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe = led_probe,</span><br><span class="line">        .remove = led_remove,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void __exit leddriver_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>


<p>设备树版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEDDEV_CNT 1 /* 设备号长度 */</span></span><br><span class="line"><span class="comment">#define LEDDEV_NAME "dtsplatled" /* 设备名字 */</span></span><br><span class="line"><span class="comment">#define LEDOFF 0</span></span><br><span class="line"><span class="comment">#define LEDON 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct leddev_dev&#123;</span><br><span class="line">    dev_t devid;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    struct device_node *node ;</span><br><span class="line">    int  major;</span><br><span class="line">    int minor;</span><br><span class="line">    int led0;  /* LED 灯 GPIO 标号 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct leddev_dev leddev ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*LED 打开关闭*/</span><br><span class="line">static void led_switch(u8 sta)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta == LEDON)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            gpio_set_value(leddev.led0,0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDOFF)</span><br><span class="line">        &#123;</span><br><span class="line">            gpio_set_value(leddev.led0,1); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode,</span><br><span class="line">                     struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    filp-&gt;private_data = &amp;leddev ;</span><br><span class="line">    //printk(<span class="string">"chrdevbase open!\r\n"</span>);</span><br><span class="line">     <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">size_t cnt, loff_t *offt)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> int retvalue;</span><br><span class="line"> unsigned char databuf[1];</span><br><span class="line"> unsigned char ledstat;</span><br><span class="line"></span><br><span class="line"> retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; 0) &#123;</span><br><span class="line"> <span class="built_in">return</span> -EFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ledstat = databuf[0]; /* 获取状态值 */</span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line"> led_switch(LEDON); /* 打开 LED 灯 */</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line"> led_switch(LEDOFF); /* 关闭 LED 灯 */</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations led_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = led_open,</span><br><span class="line">            .write = led_write,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">"led driver and device has matched!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        /* 注册字符设备驱动 */</span><br><span class="line">        /*1、创建设备号 */</span><br><span class="line">        <span class="keyword">if</span> (leddev.major) &#123; /* 定义了设备号 */</span><br><span class="line">        leddev.devid = MKDEV(leddev.major, 0);</span><br><span class="line">        register_chrdev_region(leddev.devid, LEDDEV_CNT,LEDDEV_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; /* 没有定义设备号 */</span><br><span class="line">        alloc_chrdev_region(&amp;leddev.devid, 0, LEDDEV_CNT,</span><br><span class="line">        LEDDEV_NAME);</span><br><span class="line">        leddev.major = MAJOR(leddev.devid);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        /* 2、初始化 cdev */</span><br><span class="line">        leddev.cdev.owner = THIS_MODULE;</span><br><span class="line">        cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">        /* 3、添加一个 cdev */</span><br><span class="line">        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line">        /* 4、创建类 */</span><br><span class="line">        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(leddev.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 5、创建设备 */</span><br><span class="line">        leddev.device = device_create(leddev.class, NULL, leddev.devid,</span><br><span class="line">        NULL, LEDDEV_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(leddev.device);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*初始化IO*/</span><br><span class="line"></span><br><span class="line">        leddev.node = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">        <span class="keyword">if</span> (leddev.node == NULL)&#123;</span><br><span class="line">            printk(<span class="string">"gpioled node nost find!\r\n"</span>);</span><br><span class="line">             <span class="built_in">return</span> -EINVAL;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        leddev.led0 = of_get_named_gpio(leddev.node,<span class="string">"led-gpios"</span>,0);</span><br><span class="line">        <span class="keyword">if</span> (leddev.led0 &lt; 0) &#123;</span><br><span class="line">        printk(<span class="string">"can't get led-gpio\r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gpio_request(leddev.led0, <span class="string">"led0"</span>);</span><br><span class="line"></span><br><span class="line">        gpio_direction_output(leddev.led0, 1); /*设置为输出，默认高电平 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    gpio_set_value(leddev.led0,1);</span><br><span class="line">    cdev_del(&amp;leddev.cdev);</span><br><span class="line">    unregister_chrdev_region(leddev.devid, LEDDEV_CNT);</span><br><span class="line">    device_destroy(leddev.class, leddev.devid);</span><br><span class="line">    class_destroy(leddev.class);</span><br><span class="line">    printk(<span class="string">"driver  release!\r\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 匹配列表 */</span><br><span class="line">static const struct of_device_id  led_of_match[] =&#123;</span><br><span class="line">    &#123; .compatible = <span class="string">"ming,gpioled"</span> &#125;,</span><br><span class="line">    &#123; /* Sentinel */ &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*驱动匹配*/</span><br><span class="line">static struct platform_driver led_driver = &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">"imx6ul-led"</span>, /* 驱动名字，用于和设备匹配 */</span><br><span class="line">        .of_match_table = led_of_match,</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe = led_probe,</span><br><span class="line">        .remove = led_remove,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void __exit leddriver_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>伺服与检测</title>
    <url>/Circuit-Lover/%E4%BC%BA%E6%9C%8D%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p><strong>伺服系统</strong></p>
<p>伺服系统，即随动系统，是能够跟踪输入指令信号进行动作，从而获得精确位置、速度或力输出的自动控制系统。</p>
<p>进给伺服系统（ Feed Servo System ）的定义及组成<br>定义：以移动部件的位置和速度作为控制量的自动控制系统。<br>组成：位置控制单元；速度控制单元；驱动元件(电机)；检测与反馈单元；机械执行部件。</p>
<p>伺服系统的分类<br>（1）开环伺服系统<br>（2）闭环伺服系统<br>脉冲编码器<br>（3）半闭环伺服系统<br>位置检测传感器</p>
<p><strong>三个环</strong></p>
<p> 力环，电流反馈，取样电阻<br> 速度环  速度反馈；测速发电机，光电编码器，旋转变压器等<br> 位置环  位置反馈；光电编码器，旋转变压器，光栅等</p>
<p><strong>检测元件的分类</strong></p>
<img src="/Circuit-Lover/%E4%BC%BA%E6%9C%8D%E4%B8%8E%E6%A3%80%E6%B5%8B/%E6%A3%80%E6%B5%8B%E8%A3%85%E7%BD%AE.jpg" class="">


<p><strong>旋转变压器与感应同步器</strong></p>
<p><strong>光电编码器</strong></p>
<p><strong>光栅尺</strong></p>
<p>莫尔条纹特点：<br>1.放大作用<br>2.平均效应(误差均化)<br>3.信息变换<br>4.光强分布规律</p>
<p>同步、异步电机：<br>异步电动机的转速时刻跟随负载大小的变化而变化。</p>
<p><strong>扩展：</strong></p>
<p><strong>日系驱动器</strong></p>
<p>日系伺服品牌众多，其中比较有代表性的产品主要是<br> YASKAWA 的 Σ （ SIGMA ）—-安川电机<br> Mitsubishi 的 MELSERVO<br> Panasonic 的 MINAS A</p>
<p>这三个可配置数字量输入输出：<br>MINAS A6：10 入 / 6 出；<br>Σ-7： 8 入 / 7 出；<br>MR-J4：3 入 / 3 出；</p>
<p>模拟量输入输出：<br>MINAS A6：3 入 / 2 出；<br>Σ-7： 1 入 / 2 出；<br>MR-J4：1 入 / 2 出；</p>
<p><strong>欧系伺服驱动</strong></p>
<p>比如我们熟知的 SINAMICS S210、HCS01等<br>从驱动器外型上看，大部分主流的欧系伺服驱动，都会采用高、深、薄的书本式设计，并且普遍支持无缝并列的安装样式。这一点可以从几款经典的产品很明显的看出来。</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>platform  设备驱动</title>
    <url>/Linux-Lover/latform-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>驱动的分离与分层这样的软件思路</p>
<p>分离：主机驱动和设备驱动分隔开来。</p>
<p>分层：input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。</p>
<p>主机驱动-》API函数接口-》设备驱动</p>
<p>每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)。</p>
<p><strong>platform  总线</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct bus_type！！！</span><br><span class="line"></span><br><span class="line">static int platform_match(struct device *dev,</span><br><span class="line">struct device_driver *drv)</span><br><span class="line">匹配方式</span><br><span class="line">1、<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较,probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行</span><br><span class="line">2、<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">ACPI 匹配方式。</span><br><span class="line">3、<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">id_table 匹配，每个 platform_driver 结构体有一个 id_table</span><br><span class="line">成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱</span><br><span class="line">动类型。</span><br><span class="line">4、<span class="built_in">return</span> (strcmp(pdev-&gt;name, drv-&gt;name) == 0);</span><br><span class="line">直接比较驱动和设备的 name 字段</span><br></pre></td></tr></table></figure>
<p><strong>platform  驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include/linux/platform_device.h </span><br><span class="line"></span><br><span class="line">定义并初始化好 platform_driver 结构体变量-&gt; 入口注册Linux 内核注册一个 platform 驱动，platform_driver_register -&gt;出口卸载void platform_driver_unregister(struct platform_driver *drv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。</span><br></pre></td></tr></table></figure>

<p><strong>platform  设备</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/platform_device.h</span><br><span class="line">不支持设备树的 Linux 版本中使用的</span><br><span class="line">int platform_device_register(struct platform_device *pdev</span><br><span class="line">void platform_device_unregister(struct platform_device *pdev)</span><br><span class="line"></span><br><span class="line">支持设备数版本，从设备树中读取设备信息，然后将其组织成 platform_device 形式</span><br></pre></td></tr></table></figure>
<p>ls /sys/bus/platform/ 根文件系统目录下查看device、driver</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>异步通知</title>
    <url>/Linux-Lover/%E6%AD%A5%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p><strong>复习：阻塞IO与非阻塞IO</strong></p>
<p>Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况，如果能提供一种类似中断的机制，当驱动程序可以访问的时候主动告诉应用程序那就最好了。</p>
<p>驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据。<br>异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">34 <span class="comment">#define SIGHUP 1 /* 终端挂起或控制进程终止 */</span></span><br><span class="line">35 <span class="comment">#define SIGINT 2 /* 终端中断(Ctrl+C 组合键) */</span></span><br><span class="line">36 <span class="comment">#define SIGQUIT 3 /* 终端退出(Ctrl+\组合键) */</span></span><br><span class="line">37 <span class="comment">#define SIGILL 4 /* 非法指令 */</span></span><br><span class="line">38 <span class="comment">#define SIGTRAP 5 /* debug 使用，有断点指令产生  */</span></span><br><span class="line">39 <span class="comment">#define SIGABRT 6 /* 由 abort(3)发出的退出指令 */</span></span><br><span class="line">40 <span class="comment">#define SIGIOT 6 /* IOT 指令 */</span></span><br><span class="line">41 <span class="comment">#define SIGBUS 7 /* 总线错误 */</span></span><br><span class="line">42 <span class="comment">#define SIGFPE 8 /* 浮点运算错误 */</span></span><br><span class="line">43 <span class="comment">#define SIGKILL 9 /* 杀死、终止进程 */</span></span><br><span class="line">44 <span class="comment">#define SIGUSR1 10 /* 用户自定义信号 1 */</span></span><br><span class="line">45 <span class="comment">#define SIGSEGV 11 /* 段违例(无效的内存段) */</span></span><br><span class="line">46 <span class="comment">#define SIGUSR2 12 /* 用户自定义信号 2 */</span></span><br><span class="line">47 <span class="comment">#define SIGPIPE 13 /* 向非读管道写入数据 */</span></span><br><span class="line">48 <span class="comment">#define SIGALRM 14 /* 闹钟 */</span></span><br><span class="line">49 <span class="comment">#define SIGTERM 15 /* 软件终止 */</span></span><br><span class="line">50 <span class="comment">#define SIGSTKFLT 16 /* 栈异常 */</span></span><br><span class="line">51 <span class="comment">#define SIGCHLD 17 /* 子进程结束 */</span></span><br><span class="line">52 <span class="comment">#define SIGCONT 18 /* 进程继续 */</span></span><br><span class="line">53 <span class="comment">#define SIGSTOP 19 /* 停止进程的执行，只是暂停 */</span></span><br><span class="line">54 <span class="comment">#define SIGTSTP 20 /* 停止进程的运行(Ctrl+Z 组合键) */</span></span><br><span class="line">55 <span class="comment">#define SIGTTIN 21 /* 后台进程需要从终端读取数据  */</span></span><br><span class="line">56 <span class="comment">#define SIGTTOU 22 /* 后台进程需要向终端写数据 */</span></span><br><span class="line">57 <span class="comment">#define SIGURG 23 /* 有"紧急"数据 */</span></span><br><span class="line">58 <span class="comment">#define SIGXCPU 24 /* 超过 CPU 资源限制 */</span></span><br><span class="line">59 <span class="comment">#define SIGXFSZ 25 /* 文件大小超额 */</span></span><br><span class="line">60 <span class="comment">#define SIGVTALRM 26 /* 虚拟时钟信号 */</span></span><br><span class="line">61 <span class="comment">#define SIGPROF 27 /* 时钟信号描述 */</span></span><br><span class="line">62 <span class="comment">#define SIGWINCH 28 /* 窗口大小改变 */</span></span><br><span class="line">63 <span class="comment">#define SIGIO 29 /* 可以进行输入/输出操作 */</span></span><br><span class="line">64 <span class="comment">#define SIGPOLL SIGIO</span></span><br><span class="line">65 /* <span class="comment">#define SIGLOS 29 */</span></span><br><span class="line">66 <span class="comment">#define SIGPWR 30 /* 断点重启 */</span></span><br><span class="line">67 <span class="comment">#define SIGSYS 31 /* 非法的系统调用 */</span></span><br><span class="line">68 <span class="comment">#define SIGUNUSED 31 /* 未使用信号 */</span></span><br></pre></td></tr></table></figure>

<p><strong>信号</strong></p>
<p>1、信号处理函数<br>sighandler_t signal(int signum, sighandler_t handler)<br>参数：signum：要设置处理函数的信号、handler ：信号的处理函数</p>
<p>2、驱动中的信号处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主要：struct fasync_struct *async_queue; /* 异步相关结构体 */ </span><br><span class="line"></span><br><span class="line">框架：</span><br><span class="line"> struct xxx_dev &#123;</span><br><span class="line"> ......</span><br><span class="line"> struct fasync_struct *async_queue; /* 异步相关结构体 */</span><br><span class="line"> &#125;;</span><br><span class="line"> static int xxx_fasync(int fd, struct file *filp, int on)</span><br><span class="line"> &#123;</span><br><span class="line"> struct xxx_dev *dev = (xxx_dev)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)</span><br><span class="line"> <span class="built_in">return</span> -EIO;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line">static struct file_operations xxx_ops = &#123;</span><br><span class="line"> ......</span><br><span class="line"> .fasync = xxx_fasync,</span><br><span class="line">......</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /*释放*/</span><br><span class="line"> static int xxx_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">return</span> xxx_fasync(-1, filp, 0); /*  删除异步通知 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3、kill_sync函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 、kill_fasync  函数</span><br><span class="line">当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync</span><br><span class="line">函数负责发送指定的信号，kill_fasync 函数原型如下所示：</span><br><span class="line">void kill_fasync(struct fasync_struct **fp, int sig, int band)</span><br><span class="line">函数参数和返回值含义如下：</span><br><span class="line">fp：要操作的 fasync_struct。</span><br><span class="line">sig ：要发送的信号。</span><br><span class="line">band ：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure>

<p>4、应用层</p>
<p>1、注册信号函数-&gt;signal()<br>2、将进程号告诉给内核-&gt; fcntl(fd, F_SETOWN, getpid())<br>3、开启异步通知<br>-&gt;&gt;flags = fcntl(fd, F_GETFL); /* 获取当前的进程状态<em>/<br>-&gt;&gt;fcntl(fd, F_SETFL, flags | FASYNC); /</em> 开启当前进程异步通知功能 */</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>container_of函数🏃</title>
    <url>/Linux-Lover/container-of%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>offsetof  宏  判断结构体中成员的偏移位置<br>使用 offsetof 宏需要包含 stddef.h 头文件，实例可以参考<br>offsetof 宏的定义如下：<br>#define offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member)<br>巧妙之处在于将地址 0 强制转换为 type 类型的指针，从而定位到 member 在结构体中偏移位置。编译<br>器认为 0 是一个有效的地址，从而认为 0 是 type 指针的起始地址。</p>
<p>参考：<a href="http://www.cnblogs.com/Anker/p/3472271.html。" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/p/3472271.html。</a></p>
<p>Container_of在Linux内核中是一个常用的宏，inux/kernel.h 。<br> 通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #define container_of(ptr, type, member) (&#123; \</span><br><span class="line">      const typeof( ((type *)0)-&gt;member ) *__mptr &#x3D; (ptr); \</span><br><span class="line">      (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line">      </span><br><span class="line">第一部分：const typeof( ((type *)0)-&gt;member ) *__mptr &#x3D; (ptr);</span><br><span class="line">通过 typeof 定义一个 member 指针类型的指针变量__mptr， （即__mptr 是指向 member 类型的指针），并将__mptr 赋值为 ptr。第一部分的目的是为了将统一转换为 member 类型指针。</span><br><span class="line">第二部分： (type *)( (char *)__mptr - offsetof(type,member) )，通过 offsetof 宏计算出member 在 type 中的偏移，然后用 member 的实际地址__mptr 减去偏移，得到 type 的起始地址，即指</span><br><span class="line">向 type 类型的指针。</span><br></pre></td></tr></table></figure>




 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">hanshucontainer_of(ptr, <span class="built_in">type</span>, member) </span><br><span class="line">ptr:表示结构体中member的地址</span><br><span class="line"><span class="built_in">type</span>:表示结构体类型</span><br><span class="line">member:表示结构体中的成员</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void key_work(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">"work 调用处理下半区\r\n"</span>);</span><br><span class="line">    struct imx6uirq_dev *dev = container_of(work,struct imx6uirq_dev,work);</span><br><span class="line">      </span><br><span class="line">    /*消除抖动处理 10ms*/</span><br><span class="line">    dev-&gt;timer.data = (unsigned long)dev; /*指定设备*/</span><br><span class="line">    mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体不能强制转换类型，但是地址（指针可以）!!!!🏌️</p>
<p>参考：<a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-chain" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/kernel/l-chain</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>向量，链表，队列？</title>
    <url>/C-C-Lover/%E9%87%8F%EF%BC%8C%E9%93%BE%E8%A1%A8%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>向量，链表，队列？</strong></p>
<p><strong>vector</strong></p>
<p>存储特点：连续存储的容器，动态数组，在堆上分配空间<br>底层实现：数组<br>两倍容量增长：空间不够<br>插入方式：<br>        （1）在最后插入（空间够）：很快，（空间不够）需要内存申请和释放，以及对之前数据进行拷贝。<br>        （2）在中间插入（空间够）：内存拷贝，（空间不够）需要内存申请和释放，以及对之前数据进行拷贝。<br>使用场景：支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率</p>
<p><strong>List</strong></p>
<p>存储特点：动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。<br>底层：双向链表<br>插入特性：<br>        插入：很快，一般是常数开销<br>        删除：很快，一般是常数开销<br>适用场景：list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。<br>区别：vector支持随机访问（数组），list不支持（链表）。<br>    vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p><strong>Deque</strong></p>
<p>存储特点： deque相对vector较为有优势。<br>底层： 数组<br>插入特性：<br>        deque头部和尾部添加或移除元素都非常快速，可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。<br>        中间insert()函数。iterator erase(iteratorpos);<br>适用场景：支持随机访问和存取，支持下标访问，而且插入和删除的效率高的容器。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞IO与非阻塞IO</title>
    <url>/Linux-Lover/%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</url>
    <content><![CDATA[<p><strong>阻塞IO与非阻塞IO</strong></p>
<p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃.</p>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int fd;</span><br><span class="line">int data = 0;</span><br><span class="line">fd = open(<span class="string">"/dev/xxx_dev"</span>, O_RDWR); /* 阻塞方式打开 */</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data)); /* 读取数据 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fd;</span><br><span class="line">int data = 0;</span><br><span class="line">fd = open(<span class="string">"/dev/xxx_dev"</span>, O_RDWR | O_NONBLOCK);  /* 非阻塞方式打开 */</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data)); /* 读取数据 */</span><br></pre></td></tr></table></figure>
<p><strong>等待队列头 -&gt; 阻塞</strong></p>
<p>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。</p>
<p>1、等待队列头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct __wait_queue_head &#123;</span><br><span class="line"> spinlock_t lock;</span><br><span class="line"> struct list_head task_list;</span><br><span class="line"> &#125;;</span><br><span class="line">typedef struct __wait_queue_head wait_queue_head_t;</span><br><span class="line">定义好等待队列头以后需要初始化 </span><br><span class="line">void init_waitqueue_head(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure>
<p>2、等待队列项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct __wait_queue &#123;</span><br><span class="line">unsigned int flags;</span><br><span class="line">void *private;</span><br><span class="line">wait_queue_func_t func;</span><br><span class="line">struct list_head task_list;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct __wait_queue wait_queue_t;</span><br><span class="line"></span><br><span class="line">使用宏 DECLARE_WAITQUEUE 定义并初始化一个等待队列项，宏的内容如下：</span><br><span class="line">DECLARE_WAITQUEUE(name, tsk);</span><br><span class="line">name 等待队列项的名字，tsk 等待队列项所属进程</span><br></pre></td></tr></table></figure>
<p>3、添加移除等待队列头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">设备不可访问，只有添加到等待队列头中以后进程才能进入休眠态</span><br><span class="line">可以访问以后再将进程对应的等待队列项从等待队列头中移除即可。</span><br><span class="line"></span><br><span class="line">void add_wait_queue(wait_queue_head_t *q,wait_queue_t *<span class="built_in">wait</span>)</span><br><span class="line"></span><br><span class="line">void remove_wait_queue(wait_queue_head_t *q,</span><br><span class="line">wait_queue_t *<span class="built_in">wait</span>)</span><br></pre></td></tr></table></figure>

<p>4 、等待唤醒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void wake_up(wait_queue_head_t *q)</span><br><span class="line">void wake_up_interruptible(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure>

<p>5、等待事件唤醒</p>
<img src="/Linux-Lover/%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0.jpg" class="">

<p> 实验小结：wait_event()不能被kill- 9 ,建议使用wait_event_iterruptible()</p>
<p>wait_event(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));<br>wake_up(&amp;dev-&gt;r_wait);</p>
<p>-分割线-</p>
<p>wait_event_interruptible(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));<br>wake_up_interruptible(&amp;dev-&gt;r_wait);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if 0</span></span><br><span class="line">     wait_event(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if 0</span></span><br><span class="line">    wait_event_interruptible(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    DECLARE_WAITQUEUE(<span class="built_in">wait</span>, current); /*  定义一个等待队列 */</span><br><span class="line">    add_wait_queue(&amp;dev-&gt;r_wait,&amp;<span class="built_in">wait</span>); /*加入队列*/</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);/*设置为可打断*/</span><br><span class="line">        schedule();  /*切换*/</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(signal_pending(current))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            goto  wait_error;</span><br><span class="line">        &#125;</span><br><span class="line">         __set_current_state(TASK_RUNNING); /*  设置任务为运行态 */</span><br><span class="line">         remove_wait_queue(&amp;dev-&gt;r_wait, &amp;<span class="built_in">wait</span>); /*  将等待队列移除 */</span><br><span class="line">    keyvalue = atomic_read(&amp;dev-&gt;keyvalue);</span><br><span class="line">    releasekey = atomic_read(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasekey)</span><br><span class="line">     &#123; /* 有按键按下 */</span><br><span class="line">        <span class="keyword">if</span> (keyvalue &amp; 0x80)  /*判断有效1000 0000 标志位*/</span><br><span class="line">            &#123;</span><br><span class="line">            keyvalue &amp;= ~0x80;</span><br><span class="line">            ret = copy_to_user(buf, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            goto data_error;</span><br><span class="line">            &#125;</span><br><span class="line">            atomic_set(&amp;dev-&gt;releasekey, 0);  /* 按下标志清零 */</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       goto data_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">wait_error:</span><br><span class="line">    __set_current_state(TASK_RUNNING); /*  设置任务为运行态 */</span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;r_wait, &amp;<span class="built_in">wait</span>); /*  将等待队列移除 */</span><br><span class="line">    data_error:</span><br><span class="line">    <span class="built_in">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>






<p><strong>轮询 -&gt; 非阻塞</strong></p>
<p>应用程序通过 select、epoll 或 poll 使用函数，设备驱动程序中的 poll 函数就会执行。</p>
<p>1、select函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int select(int nfds,</span><br><span class="line">        fd_set *readfds,</span><br><span class="line">        fd_set *writefds,</span><br><span class="line">        fd_set *exceptfds,</span><br><span class="line">        struct timeval *timeout)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">nfds ：要操作的文件描述符个数</span><br><span class="line">readfds 用于监视指定描述符集的读变化</span><br><span class="line">writefs 用于监视这些文件是否可以进行写操</span><br><span class="line">exceptfds 用于监视这些文件的异常</span><br><span class="line">timeout超时时间</span><br><span class="line">定义一个 fd_set 变量</span><br><span class="line">void FD_ZERO(fd_set *<span class="built_in">set</span>)    	  全部清零</span><br><span class="line">void FD_SET(int fd, fd_set *<span class="built_in">set</span>)   某位加1</span><br><span class="line">void FD_CLR(int fd, fd_set *<span class="built_in">set</span>)	某位清0</span><br><span class="line">int FD_ISSET(int fd, fd_set *<span class="built_in">set</span>)	是否可以进行操作</span><br><span class="line"></span><br><span class="line">select框架</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int ret, fd; /* 要监视的文件描述符 */</span><br><span class="line">  fd_set readfds; /* 读操作文件描述符集 */</span><br><span class="line">  struct timeval timeout; /* 超时结构体 */</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">"dev_xxx"</span>, O_RDWR | O_NONBLOCK); </span><br><span class="line">  /* 非阻塞式访问 */</span><br><span class="line">   FD_ZERO(&amp;readfds); /* 清除 readfds */</span><br><span class="line">   FD_SET(fd, &amp;readfds);/* 将 fd 添加到 readfds 里面 */</span><br><span class="line">   /* 构造超时时间 */</span><br><span class="line">   timeout.tv_sec = 0;</span><br><span class="line">   timeout.tv_usec = 500000; /* 500ms */</span><br><span class="line">   ret = select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">   switch (ret) &#123;</span><br><span class="line">   <span class="keyword">case</span> 0: /* 超时 */</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"timeout!\r\n"</span>);</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   <span class="keyword">case</span> -1: /* 错误 */</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"error!\r\n"</span>);</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   default: /* 可以读取数据 */</span><br><span class="line">   <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; /* 判断是否为 fd 文件描述符 */</span><br><span class="line">   /* 使用 <span class="built_in">read</span> 函数读取数据 */</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>2 、poll函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，</span><br><span class="line">poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制。</span><br><span class="line">int poll(struct pollfd *fds,</span><br><span class="line">          nfds_t nfds,</span><br><span class="line">          int timeout)</span><br><span class="line">fds要监视的文件描述符集合以及要监视的事件    </span><br><span class="line">struct pollfd &#123;</span><br><span class="line">      int fd; /* 文件描述符 */</span><br><span class="line">      short events; /* 请求的事件 */</span><br><span class="line">      short revents; /* 返回的事件 */</span><br><span class="line">&#125;;          </span><br><span class="line">nfds：poll 函数要监视的文件描述符数量  </span><br><span class="line">timeout ：超时时间，单位为 ms。</span><br><span class="line">可监视的事件类型:</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT  可以写数据。</span><br><span class="line">    POLLERR  指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP  指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM  等同于 POLLIN</span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret;</span><br><span class="line">int fd; /* 要监视的文件描述符 */</span><br><span class="line">struct pollfd fds;</span><br><span class="line">fd = open(filename, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */</span><br><span class="line"></span><br><span class="line">fds.fd = fd;</span><br><span class="line">fds.events = POLLIN; /* 监视数据是否可以读取*/</span><br><span class="line"></span><br><span class="line">ret = poll(&amp;fds, 1, 500); /* 轮询文件是否可操作，超时 500ms */</span><br><span class="line"><span class="keyword">if</span> (ret) &#123; /* 数据有效 */</span><br><span class="line"> ......</span><br><span class="line">/* 读取数据 */</span><br><span class="line"> ......</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == 0) &#123; /* 超时 */</span><br><span class="line"> ......</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; 0) &#123; /* 错误 */</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 、epoll  函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll因运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int epoll_create(int size)</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd,</span><br><span class="line">          int op,</span><br><span class="line">          int  fd,</span><br><span class="line">          struct epoll_event *event)</span><br><span class="line"></span><br><span class="line">nt epoll_wait(int epfd,</span><br><span class="line">          struct epoll_event *events,</span><br><span class="line">          int maxevents,</span><br><span class="line">          int timeout)</span><br></pre></td></tr></table></figure>

<p><strong>查询实验</strong></p>
<p>``bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__Linux  驱动下的 poll__</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line"></span><br><span class="line">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line"></span><br><span class="line">参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table，就是</span><br><span class="line">file_operations 中 poll 函数的 wait 参数</span><br></pre></td></tr></table></figure>
<p><strong>实验部分</strong></p>
<p>1、驱动层部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static struct file_operations imx6uirq_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = imx6uirq_open,</span><br><span class="line">            .<span class="built_in">read</span> = imx6uirq_read,</span><br><span class="line">            .poll = imx6uirq_poll,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static unsigned int imx6uirq_poll(struct file *filp ,struct poll_table_struct *<span class="built_in">wait</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int mask = 0;</span><br><span class="line">    struct  imx6uirq_dev *dev = filp -&gt;private_data;</span><br><span class="line"></span><br><span class="line">    poll_wait(filp,&amp;dev-&gt;r_wait,<span class="built_in">wait</span>);</span><br><span class="line">    /*返回应用层是否可读*/</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(atomic_read(&amp;dev-&gt;releasekey))</span><br><span class="line">    &#123;</span><br><span class="line">        mask = POLL_IN | POLLRDNORM ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> mask ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、应用层</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ioctl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "poll.h"</span></span><br><span class="line"> <span class="comment">#include "sys/select.h"</span></span><br><span class="line"> <span class="comment">#include "sys/time.h"</span></span><br><span class="line"> <span class="comment">#include "linux/ioctl.h"</span></span><br><span class="line">/*</span><br><span class="line"> *argc:应用程序参数个数</span><br><span class="line"> *argv[]:具体的参数内容，字符串形式 </span><br><span class="line"> *./ledAPP  &lt;filename&gt;  &lt;0:1&gt; 0表示关灯，1表示开灯</span><br><span class="line"> * ./ledAPP /dev/dtsled 0    关灯</span><br><span class="line"> * ./ledAPP /dev/dtsled 1    开灯</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*IOctrl 命令*/</span><br><span class="line"><span class="comment">#define CLOSE_CMD (_IO(0XEF, 0x1)) /* 关闭定时器 */</span></span><br><span class="line"><span class="comment">#define OPEN_CMD (_IO(0XEF, 0x2)) /* 打开定时器 */</span></span><br><span class="line"><span class="comment">#define SETPERIOD_CMD (_IO(0XEF, 0x3)) /* 设置定时器周期命令 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    int ret ;</span><br><span class="line">    char *filename;</span><br><span class="line"></span><br><span class="line">    /*select */</span><br><span class="line">    unsigned char data;</span><br><span class="line">    struct timeval timeout;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    /*poll*/</span><br><span class="line">    struct pollfd  fds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error Usage!\r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    filename = argv[1];</span><br><span class="line">    fd = open(filename,O_RDWR|O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"file %s open failed!\r\n"</span>, argv[1]);</span><br><span class="line">         <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fds.fd = fd ;</span><br><span class="line">        fds.events = POLLIN;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (1)</span><br><span class="line">    &#123;</span><br><span class="line">       ret = poll(&amp;fds,1,2000);/*事件、数量1、超时2s*/</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(data)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"read error !!! \r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"key value = %d \r\n"</span>,data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">" time out!!!\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">"poll error\r\n"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#if 0</span></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">            FD_ZERO(&amp;readfds);</span><br><span class="line">            FD_SET(fd, &amp;readfds);</span><br><span class="line">            timeout.tv_sec = 0;</span><br><span class="line">            timeout.tv_usec = 5000000;</span><br><span class="line"></span><br><span class="line">        ret = select(fd+1,&amp;readfds,NULL,NULL,&amp;timeout);</span><br><span class="line">        switch (ret)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> 0:</span><br><span class="line">            /* 用户自定义超时处理 */</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"time out !!!\r\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -1:</span><br><span class="line">            /* 用户错误 */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select error!!!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds))</span><br><span class="line">            &#123;</span><br><span class="line">                    ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data));</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">               &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"rwad error !!!"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(data)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">"key value = %d \r\n"</span>,data);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>热电式传感器</title>
    <url>/Circuit-Lover/%E7%83%AD%E7%94%B5%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>压电式传感器</title>
    <url>/Circuit-Lover/%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据理论🏃</title>
    <url>/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><strong>关系模式由五部分组成</strong></p>
<p>它是一个五元组：R(U, D, DOM, F)<br>R：      关系名<br>U：       组成该关系的属性名集合<br>D：       属性组U中属性所来自的域<br>DOM： 属性向域的映象集合<br>F：       属性间数据的依赖关系集合<br>简化为一个三元组：R（U, F）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[例1]建立一个描述学校教务的数据库：</span><br><span class="line">	学生的学号（Sno）、所在系（Sdept）</span><br><span class="line">	系主任姓名（Mname）、课程名（Cname）</span><br><span class="line">	成绩（Grade）</span><br><span class="line"></span><br><span class="line">单一的关系模式 ：   Student &lt;U、F&gt;</span><br><span class="line">U ＝｛ Sno, Sdept, Mname, Cname, Grade ｝</span><br><span class="line">属性组U上的一组函数依赖F：</span><br><span class="line">    F ＝｛ Sno → Sdept,  Sdept → Mname, (Sno, Cname) → Grade ｝</span><br><span class="line"></span><br><span class="line">存在问题：</span><br><span class="line">数据冗余太大</span><br><span class="line">更新异常（Update Anomalies）</span><br><span class="line">插入异常（Insertion Anomalies）</span><br><span class="line">删除异常（Deletion Anomalies</span><br></pre></td></tr></table></figure>
<p>把这个单一模式分成3个关系模式：<br>     S（Sno，Sdept，Sno → Sdept）;<br>     SC（Sno，Cno，Grade，（Sno，Cno） → Grade）;<br>     DEPT（Sdept，Mname，Sdept→ Mname）</p>
<p><strong>函数依赖</strong></p>
<p>依赖：Y函数依赖于X”，记作X→Y。  </p>
<p>平凡函数依赖与非平凡函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例：在关系SC(Sno, Cno, Grade)中，</span><br><span class="line">   非平凡函数依赖： (Sno, Cno) → Grade</span><br><span class="line">   平凡函数依赖：     (Sno, Cno) → Sno </span><br><span class="line">                                          (Sno, Cno) → Cno</span><br></pre></td></tr></table></figure>
<p>完全函数依赖与部分函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[例1] 中(Sno,Cno)→Grade是完全函数依赖，</span><br><span class="line">   (Sno,Cno)→Sdept是部分函数依赖</span><br><span class="line">   因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集</span><br></pre></td></tr></table></figure>

<p>传递函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例: 在关系Std(Sno, Sdept, Mname)中，有：</span><br><span class="line">	  Sno → Sdept，Sdept → Mname</span><br><span class="line">      Mname传递函数依赖于Sno</span><br></pre></td></tr></table></figure>

<p><strong>码</strong></p>
<p>主属性与非主属性</p>
<p>整个属性组是码，称为全码（All-key） </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[例2]</span><br><span class="line">    关系模式S(Sno,Sdept,Sage)，单个属性Sno是码，</span><br><span class="line">    SC（Sno，Cno，Grade）中，（Sno，Cno）是码</span><br><span class="line">[例3]</span><br><span class="line">       关系模式R（P，W，A）</span><br><span class="line">       P：演奏者     W：作品    A：听众</span><br><span class="line">       一个演奏者可以演奏多个作品</span><br><span class="line">       某一作品可被多个演奏者演奏</span><br><span class="line">       听众可以欣赏不同演奏者的不同作品</span><br></pre></td></tr></table></figure>

<p><strong>范式</strong></p>
<p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化 </p>
<p>1NF<br>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF,第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库但是满足第一范式的关系模式并不一定是一个好的关系模式.<br>原因：部分函数依赖于码</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/1NF.jpg" class="">

<p>2NF</p>
<p>每一个非主属性完全函数依赖于码</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/2NF.jpg" class="">

<p>3NF<br>消除传递函数依赖</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/3NF.jpg" class="">

<p>BCNF<br>1、所有非主属性对每一个码都是完全函数依赖<br>2、所有的主属性对每一个不包含它的码，也是完全函数依赖<br>3、没有任何属性完全函数依赖于非码的任何一组属性</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/BCNF.jpg" class="">

<p>多值依赖</p>
<p>4NF</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/%E5%B0%8F%E8%8A%82.jpg" class="">

<p>并不是规范化程度越高，模式就越好</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell报错🌝</title>
    <url>/Other-Lover/Powershell%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><strong>powershell不能执行脚本</strong></p>
<img src="/Other-Lover/Powershell%E6%8A%A5%E9%94%99/%E6%8A%A5%E9%94%99.jpg" class="" title="报错">



<img src="/Other-Lover/Powershell%E6%8A%A5%E9%94%99/shell.jpg" class="" title="管理员方式打开">]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 内核中断（设备树）🏊</title>
    <url>/Linux-Lover/inux-%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD%EF%BC%88%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p><strong>设备树中断信息节点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">简单总结一下与中断有关的设备树属性信息：</span><br><span class="line">①、interrupt-cells，指定中断源的信息 cells 个数。</span><br><span class="line">②、interrupt-controller，表示当前节点为中断控制器。</span><br><span class="line">③、interrupts，指定中断号，触发方式等。</span><br><span class="line">④、interrupt-parent，指定父中断，也就是中断控制器。</span><br><span class="line"></span><br><span class="line"> 获取中断号</span><br><span class="line">1、从 interupts 属性中提取到对应的设备号</span><br><span class="line">unsigned int irq_of_parse_and_map(struct device_node *dev,int index)</span><br><span class="line"></span><br><span class="line">2、GPIO 的话，可以使用 gpio_to_irq 函数来获取 gpio 对应的中断号</span><br><span class="line"> int gpio_to_irq(unsigned int gpio)</span><br></pre></td></tr></table></figure>
<p><strong>GIC控制器</strong></p>
<p>在DTS中，外设的interrupt type有两种，一种是SPI，另外一种是PPI。<br>SGI用于processor之间的通信，和外设无关。</p>
<p>（1）外设中断（Peripheral interrupt）。根据目标CPU的不同，外设的中断可以分成PPI（Private Peripheral Interrupt）和SPI（Shared Peripheral Interrupt）。PPI只能分配给一个确定的processor，而SPI可以由Distributor将中断分配给一组Processor中的一个进行处理。外设类型的中断一般通过一个interrupt request line的硬件信号线连接到中断控制器，可能是电平触发的（Level-sensitive），也可能是边缘触发的（Edge-triggered）。</p>
<p>（2）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。</p>
<p>具体的ID分配情况如下：</p>
<p>ID0<del>ID15用于SGI，ID16</del>ID31用于PPI，ID32~ID1019用于SPI。<br>PPI类型的中断会送到指定的process上，和其他的process无关。<br>SGI是通过写GICD_SGIR寄存器而触发的中断。Distributor通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode常见问题</title>
    <url>/Other-Lover/scode%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>常用扩展</strong></p>
<p>我们需要按照的插件有下面几个：<br>1)、C/C++，这个肯定是必须的。<br>2)、C/C++ Snippets，即 C/C++重用代码块。<br>3)、C/C++ Advanced Lint,即 C/C++静态检测 。<br>4)、Code Runner，即代码运行。<br>5)、Include AutoComplete，即自动头文件包含。<br>6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。<br>7)、One Dark Pro，VSCode 的主题。<br>8)、GBKtoUTF8，将 GBK 转换为 UTF8。<br>9)、ARM，即支持 ARM 汇编语法高亮显示。<br>10)、Chinese(Simplified)，即中文环境。<br>11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。<br>12)、compareit，比较插件，可以用于比较两个文件的差异。<br>13)、DeviceTree，设备树语法插件。<br>14)、TabNine，一款 AI 自动补全插件</p>
<p>15)、remote-ssh远程控制</p>
<p><strong>远程控制不能跳转命令</strong></p>
<p>修改f12键绑定的参数<br>将editorHasDefinitionProvider &amp;&amp; editorTextFocus &amp;&amp;!isInEmbeddedEditor<br>改为editor.action.revealDefinition</p>
<p><strong>版本更新后连接不成功</strong><br>rm ./.vscode-server/ -rf</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-admin</title>
    <url>/Other-Lover/hexo-admin/</url>
    <content><![CDATA[<p><strong>安装npm install –save hexo-admin</strong></p>
<p><strong>打不开Cannot GET /admin</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改.config</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"></span><br><span class="line">url: https://github.com/hsm0409/hsm0409.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+gitee</title>
    <url>/Other-Lover/xo-gitee/</url>
    <content><![CDATA[<p>github网速不够快，换成gitees试试？</p>
<p><a href="https://gitee.com/hsm0409/hsm0409.git" target="_blank" rel="noopener">https://gitee.com/hsm0409/hsm0409.git</a><br>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p>如果同时部署：</p>
<p>先关联GitHub的远程库：<br>git remote rm origin<br>git remote add github <a href="mailto:git@github.com">git@github.com</a>:hsm0409/hsm0409.github.io.git<br>接着，再关联Gitee的远程库：<br>git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p><a href="mailto:ssh-Tgit@github.com">ssh-Tgit@github.com</a></p>
<p><a href="mailto:ssh-Tgit@gitee.com">ssh-Tgit@gitee.com</a></p>
<p>git push github master<br>如果要推送到Gitee，使用命令：</p>
<p>git push gitee master</p>
<p>不错的参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712</a></p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+github</title>
    <url>/Other-Lover/hexo-github/</url>
    <content><![CDATA[<p>换电脑或者换系统重新部署hexo</p>
<p>ssh-keygen –t rsa -C “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>   </p>
<p>git config –global user.name “hsm0409”  </p>
<p>//有时候系统没.ssh/id_rsa.pub，输入命令ssh-keygen -o<br>//生成新的密钥</p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a>      //ssh密钥</p>
<p>yes</p>
<p> git config –global user.email “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>“</p>
<p> git config –global user.name “hsm0409”</p>
<p> 就可以了。</p>
<p> //详细参考<a href="https://blog.annieyu.com/posts/207737771.html" target="_blank" rel="noopener">https://blog.annieyu.com/posts/207737771.html</a></p>
<p>回退分支操作 –哈希值</p>
<p>git reset –hard 0e95fae<br>git push -u origin master</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>使用PE系统重装win10QvQ</title>
    <url>/Other-Lover/%E7%94%A8PE%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85win10QvQ/</url>
    <content><![CDATA[<p><strong>1、工具：U盘+白菜PE系统</strong>   </p>
<p><strong>2、系统：win10 解压放在U盘 GHO 目录下。</strong></p>
<p><strong>3、电脑关机，开机启动按住“esc”,选择进入U盘，进入PE系统，我们可以先备份好C盘的资料到其他U盘中，然后点击C盘，还原分区，选择U盘中GHO目录下的镜像文件.gho,点击确定即可。</strong></p>
<p><strong>4、拔出U盘，重启电脑。</strong></p>
<p>(DiskGenius 数据恢复软件)</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>电容传感器</title>
    <url>/Circuit-Lover/%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>电容式传感器是把被测量的变化转换为电容量变化的一类传感器。实质上是一个具有可变参数的电容器。最常用的是平行板电容传感器和圆柱形电容传感器。可用来测量压力、力、位移、振动、液位、成份含量等。</p>
<p>①变极距型（变间隙型）：改变极板距离d0 。<br>②变面积型：改变极板相对面积S 。<br>③变介电常数型：改变介电常数ε。</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>ABCD类ip</title>
    <url>/Linux-Lover/CD%E7%B1%BBip/</url>
    <content><![CDATA[<p>A类地址：一个A类地址由一字节的网络地址和三字节的主机地址组成（网+主+主+主），网络地址的最高位必须为0（二进制即为00000000<del>01111111），即0</del>127。</p>
<p>B类地址：一个B类地址由二字节的网络地址和二字节的主机地址组成（网+网+主+主）,网络地址最高位必须为10（二进制即10000000~10111111）,即128 ~191</p>
<p>C类地址：一个C类地址由三字节的网络地址和一字节的主机地址组成（网+网+网+主），网络地址最高位必须为110（二进制即为11000000<del>11011111），即192</del>223</p>
<p>D类地址：网络—网络—-网络—-网络—主机(11100000<del>11101111)<br>224</del>240<br>224.0.0.0–240.255.255.255  组播（Multicast），这样可以节约网络资源。</p>
<p>E 类 地址属于保留地址。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编基础常用</title>
    <url>/ARM-Lover/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%B8%B8%E7%94%A8/</url>
    <content><![CDATA[<p><strong>伪操作</strong></p>
<p>.section  【段名】<br>.text代码段<br>.data数据<br>.bss未初始化<br>.rodata只读<br>.section   .textsection @定义一个数据段</p>
<p>imx6ull start.S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> SECTIONS&#123;</span><br><span class="line"> . &#x3D; 0X87800000;</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line"> start.o</span><br><span class="line"> main.o</span><br><span class="line"> *(.text)</span><br><span class="line"> &#125;</span><br><span class="line"> .rodata ALIGN(4) : &#123;*(.rodata*)&#125;</span><br><span class="line"> .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line"> __bss_start &#x3D; .;</span><br><span class="line"> .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line">__bss_end &#x3D; .;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">注：</span><br><span class="line">COMMON未初始化的全局变量</span><br><span class="line">.bss未初始化的静态变量，以及初始化为0的全局变量或静态变量</span><br><span class="line">包含data和BSS段的整个区段此时通常称为数据区。</span><br><span class="line">.bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；</span><br><span class="line">.data却需要占用，其内容由程序初始化。</span><br></pre></td></tr></table></figure>

<p>常见的伪操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.byte 定义单字节数据，比如.byte 0x12</span><br><span class="line">.short  定义双字节数据，比如.byte 0x1234。</span><br><span class="line">.long 定义一个 4 字节数如.long0x12345678。</span><br><span class="line">.equ 表达式，比如.equ num, 0x12  num&#x3D;0x12</span><br><span class="line">.align  数据字节对齐，比如：.align 4 表示 4 字节对齐</span><br><span class="line">.end  表示源文件结束</span><br><span class="line">.global  定义一个全局符号，格式为：.global symbol，比如：.global _start。</span><br></pre></td></tr></table></figure>
<p>Cortex-A7常用汇编指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、处理器内部数据传输指令</span><br><span class="line">使用处理器做的最多事情就是在处理器内部来回的传递数据，常见的操作有：</span><br><span class="line">①、将数据从一个寄存器传递到另外一个寄存器。</span><br><span class="line">MOV R1,R2</span><br><span class="line">②、将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。</span><br><span class="line">MRS R0,CPSR</span><br><span class="line">或者：MSR CPSR,R1</span><br><span class="line">③、将立即数传递到寄存器。</span><br><span class="line">MOV R1,#0X12</span><br><span class="line"></span><br><span class="line">2、储存器访问指令   RAM</span><br><span class="line">从存储器 Rn+offset 的位置读取数据存放到 Rd 中</span><br><span class="line">LDR  Rd,[Rn,#offset]    @eg:</span><br><span class="line">LDR R0,&#x3D;0X0209C004@将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1,[R0]@读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br><span class="line">将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</span><br><span class="line">STR Rd,[Rn,#offset]</span><br><span class="line">LDR R0, &#x3D;0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1, &#x3D;0X20000002 @R1 保存要写入到寄存器的值，即 R1&#x3D;0X20000002</span><br><span class="line">STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br><span class="line"></span><br><span class="line">3、压栈和出栈</span><br><span class="line">PUSH &lt;reg list&gt; 将寄存器列表存入栈中。</span><br><span class="line">POP &lt;reg list&gt;  从栈中恢复寄存器列表。</span><br><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br><span class="line">PUSH &#123;LR&#125;</span><br><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br><span class="line">第二种写法：  FD 是 Full Descending 的缩写，即满递减的意思。</span><br><span class="line">STMFD SP！   LDMFD SP!</span><br><span class="line">STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈      右边高地址</span><br><span class="line">STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br><span class="line"></span><br><span class="line">4、跳转指令</span><br><span class="line"></span><br><span class="line">B &lt;label&gt;如果跳转范围超过了+&#x2F;-2KB，可以指定，不用返回</span><br><span class="line">_start:</span><br><span class="line">ldr sp,&#x3D;0X80200000 @设置栈指针</span><br><span class="line">b main @跳转到 main 函数</span><br><span class="line"></span><br><span class="line">BL &lt;label&gt;  跳转到标号地址，并将返回地址保存在 LR 中。</span><br><span class="line">push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line">bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line">cps #0x12 @进入 IRQ 模式</span><br><span class="line">pop &#123;r0, r1&#125;</span><br><span class="line">str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br><span class="line"></span><br><span class="line">L连接寄存器</span><br><span class="line">一是用来保存子程序返回地址；二是当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。</span><br><span class="line"></span><br><span class="line">B.W&lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的跳转</span><br><span class="line">BX &lt;Rm&gt;  间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</span><br><span class="line">BLX &lt;Rm&gt;结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地</span><br><span class="line">址保存在 LR 中，切换指令集。</span><br><span class="line"></span><br><span class="line">5、算数指令</span><br><span class="line"></span><br><span class="line">ADD Rd,Rn,Rm  @ Rd&#x3D;Rn+Rm</span><br><span class="line">DD Rd, Rn, #immed @Rd &#x3D; Rn + #immed</span><br><span class="line">ADC Rd, Rn, Rm Rd &#x3D; Rn + Rm + 进位</span><br><span class="line">ADC Rd, Rn, #immed  Rd &#x3D; Rn + #immed +进位</span><br><span class="line"></span><br><span class="line">SUB Rd, Rn, Rm @Rd &#x3D; Rn – Rm</span><br><span class="line">SUB Rd, #immed  @Rd &#x3D; Rd - #immed</span><br><span class="line">SUB Rd, Rn, #immed @Rd &#x3D; Rn - #immed</span><br><span class="line">SBC Rd, Rn, #immed Rd &#x3D; Rn - #immed – 借位</span><br><span class="line">SBC Rd, Rn ,Rm  Rd &#x3D; Rn – Rm – 借位</span><br><span class="line"></span><br><span class="line">MUL Rd, Rn, Rm    Rd &#x3D; Rn * Rm  乘法(32 位)</span><br><span class="line"></span><br><span class="line">UDIV Rd, Rn, Rm   Rd &#x3D; Rn &#x2F; Rm  无符号除法</span><br><span class="line">SDIV Rd, Rn, Rm   Rd &#x3D; Rn &#x2F; Rm  有符号除法</span><br><span class="line"></span><br><span class="line">6、逻辑指令</span><br><span class="line"></span><br><span class="line">AND Rd, Rn    	@  Rd &#x3D; Rd &amp;Rn</span><br><span class="line">AND Rd, Rn, #immed 	 @Rd &#x3D; Rn &amp;#immed</span><br><span class="line">AND Rd, Rn, Rm	 @Rd &#x3D; Rn &amp; Rm</span><br><span class="line"></span><br><span class="line">ORR Rd, Rn	 @Rd &#x3D; Rd | Rn </span><br><span class="line">ORR Rd, Rn, #immed	 @Rd &#x3D; Rn | #immed</span><br><span class="line">ORR Rd, Rn, Rm 	 @Rd &#x3D; Rn | Rm</span><br><span class="line"></span><br><span class="line">BIC Rd, Rn 	@Rd &#x3D; Rd &amp; (~Rn)   位清除  </span><br><span class="line">BIC Rd, Rn, #immed	 @Rd &#x3D; Rn &amp; (~#immed)</span><br><span class="line">BIC Rd, Rn , Rm 	 @Rd &#x3D; Rn &amp; (~Rm)</span><br><span class="line"></span><br><span class="line">ORN Rd, Rn, #immed    @Rd &#x3D; Rn | (#immed) 按位或非</span><br><span class="line">ORN Rd, Rn, Rm     Rd &#x3D; Rn | (Rm)</span><br><span class="line"></span><br><span class="line">EOR Rd, Rn               Rd &#x3D; Rd ^ Rn按位异或 </span><br><span class="line">EOR Rd, Rn, #immed        Rd &#x3D; Rn ^ #immed</span><br><span class="line">EOR Rd, Rn, Rm            Rd &#x3D; Rn ^ Rm</span><br></pre></td></tr></table></figure>

<p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。<br>MRC 就是读 CP15 寄存器， MCR 就是写 CP15 寄存器，MCR 指令格式如下：</p>
<p>cps   #0x13   模式切换为SVC<br>adr<br>可实际上adr是将基于PC相对偏移的地址值或基于寄存器相对地址值读取的为指令,<br>而ldr用于加载32为立即数或一个地址到指定的寄存器中。</p>
<p><strong>隔离指令</strong><br>DMB<br>数据存储器隔离。 仅当所有在它前面的存储器访问操作都执行完毕后，才提交在它后面的存储器访问操作。<br>DSB<br>数据同步隔离。 仅当所有在它前面的存储器访问操作都执行完毕后，才执行在它后面的指令<br>ISB<br>指令同步隔离。它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。</p>
<p>题外话：<br>今天,差不多所有编程都是基于高级语言的,所以,大程序很少采用这里介绍的汇编语言编程。然而,有时可能需要用汇编语言开发小的软件组件,以达到关键应用所需”的最佳性能。因此,了解如何编写汇编代码是很有用处的。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile小记</title>
    <url>/Makefile-Lover/Makefile%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>学习Makefie,最重要的是搞清楚<code>目标和依赖</code>!!!<br>自动变量</p>
<img src="/Makefile-Lover/Makefile%E5%B0%8F%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F.jpg" class="" title="自动化变量">



<p>命令前加@即为不显示<br>make -s  不输出<br>V=1“来实现完整的命令输出<br>.PHONY 意思表示 clean 是一个“伪目标”<br>Makefile 特定文件命名 make -f Make.Linux</p>
<p>在linux中和编译有关的配置文件有：<br>makefile:<br>Kconfig:<br>.config:全局的配置文件，由它决定makefile来编译哪些文件，一般是自动生成。</p>
<p>执行make menuconfig就会读取源码目录下所有Kconfig内容，并生成界面中的选项菜单</p>
]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile调试参考</title>
    <url>/Makefile-Lover/Makefile%E8%B0%83%E8%AF%95%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>led.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">TARGET         ?= uart</span><br><span class="line"></span><br><span class="line">CC            := $(CROSS_COMPILE)gcc</span><br><span class="line">LD            := $(CROSS_COMPILE)ld</span><br><span class="line">OBJCOPY       := $(CROSS_COMPILE)objcopy</span><br><span class="line">OBJDUMP       := $(CROSS_COMPILE)objdump</span><br><span class="line"></span><br><span class="line">LIBPATH      := -lgcc -L /usr/<span class="built_in">local</span>/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCUDIRS     := stdio/include\</span><br><span class="line">				imx6ul \</span><br><span class="line">			    bsp/clk\</span><br><span class="line">				bsp/delay\</span><br><span class="line">				bsp/beep\</span><br><span class="line">				bsp/key\</span><br><span class="line">				bsp/gpio\</span><br><span class="line">				bsp/int\</span><br><span class="line">				bsp/led\</span><br><span class="line">				bsp/<span class="built_in">exit</span>\</span><br><span class="line">				bsp/epit\</span><br><span class="line">				bsp/keyfilter\</span><br><span class="line">				bsp/uart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SRCUDIRS     := stdio/lib\</span><br><span class="line">				project\</span><br><span class="line">			    bsp/clk\</span><br><span class="line">				bsp/delay\</span><br><span class="line">				bsp/beep\</span><br><span class="line">				bsp/key\</span><br><span class="line">				bsp/gpio\</span><br><span class="line">				bsp/int\</span><br><span class="line">				bsp/led\</span><br><span class="line">				bsp/<span class="built_in">exit</span>\</span><br><span class="line">				bsp/epit\</span><br><span class="line">				bsp/keyfilter\</span><br><span class="line">				bsp/uart</span><br><span class="line"></span><br><span class="line">INCLUDE       := $(patsubst %, -I % , $(INCUDIRS))</span><br><span class="line"></span><br><span class="line">SFILES        := $(foreach dir,$(SRCUDIRS),$(wildcard $(dir)/*.S))</span><br><span class="line">CFILES        := $(foreach dir,$(SRCUDIRS),$(wildcard $(dir)/*.c)) </span><br><span class="line"></span><br><span class="line">SFILESNDIR        := $(notdir $(SFILES))</span><br><span class="line">CFILESNDIR        := $(notdir $(CFILES))</span><br><span class="line"></span><br><span class="line">SOBJS              := $(patsubst %,obj/%,$(SFILESNDIR:.S=.o))</span><br><span class="line">COBJS             := $(patsubst %,obj/%,$(CFILESNDIR:.c=.o))</span><br><span class="line"></span><br><span class="line">OBJS              := $(SOBJS) $(COBJS)</span><br><span class="line"></span><br><span class="line">VPATH             := $(SRCUDIRS)</span><br><span class="line">.PHONY:clean</span><br><span class="line"></span><br><span class="line">$(TARGET).bin : $(OBJS)</span><br><span class="line">	$(LD) -Timx6u.lds -o $(TARGET).elf $^ $(LIBPATH)</span><br><span class="line">	$(OBJCOPY) -O binary -S $(TARGET).elf <span class="variable">$@</span></span><br><span class="line">	$(OBJDUMP) -D -m arm $(TARGET).elf &gt;$(TARGET).dis</span><br><span class="line"></span><br><span class="line">$(COBJS):obj/%.o:%.c</span><br><span class="line">	$(CC) -Wall -Wa,-mimplicit-it=thumb -nostdlib -fno-builtin -c -O2 $(INCLUDE)-o <span class="variable">$@</span> $&lt;</span><br><span class="line">$(SOBJS):obj/%.o:%.S</span><br><span class="line">	$(CC) -Wall -nostdlib -fno-builtin -c -O2 $(INCLUDE)-o <span class="variable">$@</span> $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(TARGET).elf $(TARGET).bin $(TARGET).dis $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中断</title>
    <url>/Linux-Lover/Linux-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p>Linux 内核中也提供了大量的中断相关的 API 函数</p>
<p>1、知道中断号<br>2 、申请函数request_irq<br>3 、free_irq 释放函数<br>4、request_irq 函数申请中断的时候需要设置中断处理函数<br>5、中断使能与禁止函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使能或者禁止某一个中断</span><br><span class="line"></span><br><span class="line">void enable_irq(unsigned int irq)</span><br><span class="line">void disable_irq(unsigned int irq)-&gt;void disable_irq_nosync(unsigned int irq)</span><br><span class="line"></span><br><span class="line">使能或者禁止当前处理器中断系统</span><br><span class="line">local_irq_enable()</span><br><span class="line">local_irq_disable()</span><br><span class="line">推荐：</span><br><span class="line">local_irq_save(flags) </span><br><span class="line">local_irq_restore(flags)</span><br></pre></td></tr></table></figure>
<p><strong>上半部与下半部</strong></p>
<p>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可<br>以放在上半部完成。<br>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部<br>去执行，这样中断处理函数就会快进快出</p>
<p>哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断?<br>正点原子参考：<br>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。<br>②、如果要处理的任务对时间敏感，可以放到上半部。<br>③、如果要处理的任务与硬件有关，可以放到上半部<br>④、除了上述三点以外的其他任务，优先考虑放到下半部。</p>
<p><strong>Linux内核下半部中断机制</strong></p>
<p>buttom half -&gt;软中断和 tasklet </p>
<p><strong>软中断</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">示例代码 51.1.2.1 softirq_action 结构体</span><br><span class="line">433 struct softirq_action</span><br><span class="line">434 &#123;</span><br><span class="line">435 void (*action)(struct softirq_action *);</span><br><span class="line">436 &#125;;</span><br><span class="line">在 kernel/softirq.c 文件中一共定义了 10 个软中断，如下所示：</span><br><span class="line">示例代码 51.1.2.2 softirq_vec 数组</span><br><span class="line">static struct softirq_action softirq_vec[NR_SOFTIRQS];</span><br><span class="line">NR_SOFTIRQS 是枚举类型，定义在文件 include/linux/interrupt.h 中，定义如下：</span><br><span class="line">示例代码 51.1.2.3 softirq_vec 数组</span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">HI_SOFTIRQ=0, /* 高优先级软中断 */</span><br><span class="line">TIMER_SOFTIRQ, /* 定时器软中断 */</span><br><span class="line">NET_TX_SOFTIRQ, /* 网络数据发送软中断 */</span><br><span class="line">NET_RX_SOFTIRQ, /* 网络数据接收软中断 */</span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ, /* tasklet 软中断 */</span><br><span class="line">SCHED_SOFTIRQ, /* 调度软中断 */</span><br><span class="line">HRTIMER_SOFTIRQ, /* 高精度定时器软中断  */</span><br><span class="line">RCU_SOFTIRQ, /* RCU 软中断  */</span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open_softirq 函数注册对应的软中断处理函数</span><br><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br><span class="line"></span><br><span class="line">例：open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line"></span><br><span class="line">raise_softirq 调用函数触发</span><br><span class="line">void raise_softirq(unsigned int nr)</span><br><span class="line"></span><br><span class="line">注意:软中断必须在编译的时候静态注册  kernel/softirq.c</span><br></pre></td></tr></table></figure>

<p><strong>tasklet</strong></p>
<p>前言：tasklet 是利用软中断来实现的另t外一种下半部机制，在软中断和 tasklet 之间，建议使用 tasklet</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct tasklet_struct</span><br><span class="line">&#123;</span><br><span class="line">struct tasklet_struct *next; /* 下一个 tasklet */</span><br><span class="line"> unsigned long state; /* tasklet 状态 */</span><br><span class="line"> atomic_t count; /* 计数器，记录对 tasklet 的引用数 */</span><br><span class="line">void (*func)(unsigned long); /* tasklet  执行的函数 */</span><br><span class="line"> unsigned long data; /* 函数 func 的参数 */</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">tasklet_init 函数初始化</span><br><span class="line"></span><br><span class="line">void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long),unsigned long data)</span><br><span class="line"></span><br><span class="line">也可以初始-》DECLARE_TASKLET(name, func, data)</span><br><span class="line"></span><br><span class="line">void tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line"></span><br><span class="line">t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name tasklet 的参考使用示例如下所示</span><br><span class="line"></span><br><span class="line">/* 定义 taselet */</span><br><span class="line">struct tasklet_struct testtasklet;</span><br><span class="line"></span><br><span class="line">void testtasklet_func(unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">/* tasklet 具体处理内容 */</span><br><span class="line">&#125;</span><br><span class="line">/* 中断处理函数 */</span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 调度 tasklet */</span><br><span class="line">tasklet_schedule(&amp;testtasklet);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">/* 驱动入口函数 */</span><br><span class="line">static int __init xxxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 初始化 tasklet */</span><br><span class="line">tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line">/* 注册中断处理函数 */</span><br><span class="line">request_irq(xxx_irq, test_handler, 0, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作队列</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">工作队列是另外一种下半部执行方式：推后的工作可以睡眠</span><br><span class="line">表示一个工作结构函数</span><br><span class="line">struct work_struct &#123;</span><br><span class="line">atomic_long_t data;</span><br><span class="line">struct list_head entry;</span><br><span class="line">work_func_t func; /* 工作队列处理函数 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">工作组织成工作队列结构</span><br><span class="line">struct workqueue_struct &#123;</span><br><span class="line">struct list_head pwqs;</span><br><span class="line">struct list_head list;</span><br><span class="line">struct mutex mutex;</span><br><span class="line">int work_color;</span><br><span class="line">int flush_color;</span><br><span class="line">atomic_t nr_pwqs_to_flush;</span><br><span class="line">struct wq_flusher *first_flusher;</span><br><span class="line">struct list_head flusher_queue;</span><br><span class="line">struct list_head flusher_overflow;</span><br><span class="line">struct list_head maydays;</span><br><span class="line">struct worker *rescuer;</span><br><span class="line">int nr_drainers;</span><br><span class="line">int saved_max_active;</span><br><span class="line">struct workqueue_attrs *unbound_attrs;</span><br><span class="line">struct pool_workqueue *dfl_pwq;</span><br><span class="line">char name[WQ_NAME_LEN];</span><br><span class="line">struct rcu_head rcu;</span><br><span class="line">unsigned int flags ____cacheline_aligned;</span><br><span class="line">struct pool_workqueue __percpu *cpu_pwqs;</span><br><span class="line">struct pool_workqueue __rcu *numa_pwq_tbl[];</span><br><span class="line">&#125;；</span><br><span class="line">LLinux 内核使用工作者线程(worker thred)来处理工作队列中的各个工作结构</span><br><span class="line">struct worker &#123;</span><br><span class="line">union &#123;</span><br><span class="line">struct list_head entry;</span><br><span class="line">struct hlist_node hentry;</span><br><span class="line">&#125;;</span><br><span class="line">struct work_struct *current_work;</span><br><span class="line">work_func_t current_func;</span><br><span class="line">struct pool_workqueue *current_pwq;</span><br><span class="line">bool desc_valid;</span><br><span class="line">struct list_head scheduled;</span><br><span class="line">struct task_struct *task;</span><br><span class="line">struct worker_pool *pool;</span><br><span class="line">struct list_head node;</span><br><span class="line">unsigned long last_active;</span><br><span class="line">unsigned int flags;</span><br><span class="line">int id;</span><br><span class="line">char desc[WORKER_DESC_LEN];</span><br><span class="line">struct workqueue_struct *rescue_wq;</span><br><span class="line">&#125;;</span><br><span class="line">总结：每个 worker 都有一个工作队列</span><br><span class="line">和 tasklet 一样，工作也是需要调度才能运</span><br><span class="line"></span><br><span class="line">例子</span><br><span class="line">/* 定义工作(work) */</span><br><span class="line">struct work_struct testwork;</span><br><span class="line">void testwork_func_t(struct work_struct *work);</span><br><span class="line">&#123;</span><br><span class="line">/* work 具体处理内容 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 调度 work */</span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">static int __init xxxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 初始化 work */</span><br><span class="line">INIT_WORK(&amp;testwork, testwork_func_t);</span><br><span class="line">/* 注册中断处理函数 */</span><br><span class="line">request_irq(xxx_irq, test_handler, 0, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>c和c++中struct的主要区别</title>
    <url>/C-C-Lover/c%E5%92%8Cc-%E4%B8%ADstruct%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。</p>
<p>c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下函数常见报错随记</title>
    <url>/Linux-Lover/nux%E4%B8%8B%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>gets(str)<br>函数报错：warning: the ‘gets’ function is dangerous and should not be used.<br>原因：<br>注意，gets的行为与fgets使用stdin作为参数时的行为不完全相同:首先，在使用fgets时，结束换行字符不包含在gets中，而在使用fgets时，它包含在fgets中。其次，gets不允许您指定要读取的字符数限制，因此必须小心使用str指向的数组的大小，以避免缓冲区溢出。<br>解决办法：采用<br>fgets(cmd,100,stdin);//100为size</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ioctl函数</title>
    <url>/Linux-Lover/ctl%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>ioctl 系统调用主要用于增加系统调用的硬件控制能力，它可以构建自己的命令，也能接受参数.<br>应用程序 ioctl 函数<br>int ioctl (int fd, unsigned long cmd, arg)<br>fd 是被打开的设备文件， cmd 是操作设备的命令，“ …”代表可变数目的参数表，通常用 char *argp 来定义，如果 cmd 命令不需要参数，则传入 NULL 即可。</p>
<p>内核空间 iotcl 函数<br>int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);</p>
<p>ioctl 操作与硬件平台相关，使用 ioctl 的驱动需要包含&lt;linux/ioctl.h&gt;文件。每个 ioctl 命令cmd实际上都是一个 32 位整型数，各字段和含义如下表所示。<br>已经被使用的幻数列表详见内核源码目录Documentation/ioctl/ioctl-number.txt文件。</p>
<p>|一般形式<br>|-|-|<br>|_IO(type,nr) 构造无参数的命令编号<br>|_IOW(type,nr,size) 构造往驱动写入数据的命令编号<br>|_IOR(type,nr,size) 构造从驱动中读取数据的命令编号<br>|_IOWR(type,nr,size)构造双向传输的命令编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line">/*0XFE---幻数，1.2.3.---功能号*/</span><br><span class="line">/*IOctrl 命令*/</span><br><span class="line"><span class="comment">#define CLOSE_CMD (_IO(0XEF, 0x1)) /* 关闭定时器 */</span></span><br><span class="line"><span class="comment">#define OPEN_CMD (_IO(0XEF, 0x2)) /* 打开定时器 */</span></span><br><span class="line"><span class="comment">#define SETPERIOD_CMD (_IO(0XEF, 0x3)) /* 设置定时器周期命令 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TIMER_NAME  "timer"</span></span><br><span class="line"><span class="comment">#define TIMER_CNT  1</span></span><br><span class="line">struct timer_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid;</span><br><span class="line"></span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct device_node *nd;</span><br><span class="line">    struct class * class;</span><br><span class="line">    struct device * device;</span><br><span class="line"></span><br><span class="line">    int led_gpio;</span><br><span class="line">    int timeperiod;</span><br><span class="line">    struct timer_list timer;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct timer_dev timer;</span><br><span class="line"></span><br><span class="line">static int led_init (struct timer_dev * dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    dev-&gt;nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;nd == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;led_gpio = of_get_named_gpio(dev-&gt;nd,<span class="string">"led-gpios"</span>,0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;led_gpio &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't get led \r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*申请注册IO*/</span><br><span class="line"></span><br><span class="line">    gpio_request(dev-&gt;led_gpio,<span class="string">"led"</span>);</span><br><span class="line"></span><br><span class="line">    ret = gpio_direction_output(dev-&gt;led_gpio,1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't set gpion\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int timer_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;timer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static long timer_unlocked_ioctl(struct file *filp, unsigned int cmd,</span><br><span class="line">						unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        struct timer_dev *dev = (struct timer_dev *)filp-&gt;private_data;</span><br><span class="line">        int ret  = 0;</span><br><span class="line">        int timeperiod ;</span><br><span class="line">        unsigned long flags;</span><br><span class="line">        switch (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CLOSE_CMD:</span><br><span class="line">                del_timer(&amp;dev-&gt;timer);</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> OPEN_CMD:</span><br><span class="line">                spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">                timeperiod = dev-&gt;timeperiod;</span><br><span class="line">                spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line">                mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> SETPERIOD_CMD:</span><br><span class="line">            dev-&gt;timeperiod = arg;</span><br><span class="line">            mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg));</span><br><span class="line">            <span class="built_in">break</span> ;     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int timer_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct file_operations timer_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">    .open  = timer_open ,</span><br><span class="line">    .release = timer_release,</span><br><span class="line">	.unlocked_ioctl	= timer_unlocked_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void  timer_function(unsigned long arg )</span><br><span class="line">&#123;</span><br><span class="line">    struct timer_dev *dev = (struct timer_dev*)arg;</span><br><span class="line">    static int sta = 1 ;</span><br><span class="line">    int timeperiod;</span><br><span class="line">     unsigned long flags;</span><br><span class="line">    sta = !sta ;</span><br><span class="line">    gpio_set_value(dev-&gt;led_gpio,sta);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">     timeperiod = dev-&gt;timeperiod;</span><br><span class="line">     spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line"></span><br><span class="line">   mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init timer_init(void )</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    </span><br><span class="line">    spin_lock_init(&amp;timer.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer.major)</span><br><span class="line">    &#123;</span><br><span class="line">    timer.devid = MKDEV(timer.devid,0);</span><br><span class="line">    register_chrdev_region(timer.devid,TIMER_CNT,TIMER_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;timer.devid, 0, TIMER_CNT,TIMER_NAME);</span><br><span class="line">        timer.major = MAJOR(timer.devid);</span><br><span class="line">        timer.minor = MINOR(timer.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    timer.cdev.owner = THIS_MODULE ;</span><br><span class="line">	cdev_init(&amp;timer.cdev, &amp;timer_fops);</span><br><span class="line">    cdev_add(&amp;timer.cdev, timer.devid,TIMER_CNT);</span><br><span class="line">	</span><br><span class="line">    /*自动设备节点*/</span><br><span class="line">    timer.class = class_create(THIS_MODULE, TIMER_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.class))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.class);</span><br><span class="line"></span><br><span class="line">    timer.device = device_create(timer.class, NULL, timer.devid, NULL, TIMER_NAME);</span><br><span class="line">				  </span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.device))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.device);</span><br><span class="line"></span><br><span class="line">        ret  = led_init(&amp;timer);</span><br><span class="line">        <span class="keyword">if</span>(ret  &lt;  0)</span><br><span class="line">        &#123;</span><br><span class="line">            goto fail_ledinit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    init_timer(&amp;timer.timer);</span><br><span class="line">    timer.timer.function = timer_function;</span><br><span class="line">    timer.timer.data = (unsigned long ) &amp; timer;</span><br><span class="line">    timer.timer.expires = jiffies + msecs_to_jiffies(5000);/*500ms*/</span><br><span class="line">    add_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0 ;</span><br><span class="line"></span><br><span class="line">    fail_ledinit:</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit timer_exit(void )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    gpio_set_value(timer.led_gpio,1);</span><br><span class="line">    del_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;timer.cdev);</span><br><span class="line">    unregister_chrdev_region(timer.devid,TIMER_CNT);</span><br><span class="line">    device_destroy(timer.class,timer.devid);</span><br><span class="line">    class_destroy(timer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ioctl(fd,cmd,arg);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>电感式传感器</title>
    <url>/Circuit-Lover/%E7%94%B5%E6%84%9F%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>电感式传感器是利用被测量的变化引起线圈自感或互感系数的变化，从而导致线圈电感量改变这一物理现象来实现测量的。因此根据转换原理，电感式传感器可以分为自感式和互感式两大类。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 电感式传感器与其它传感器相比，具有以下优点：</span><br><span class="line"> 1) 结构简单，工作可靠，寿命长；</span><br><span class="line"> 2) 灵敏度好、分辨率高。能测量0.1μm甚至更小的机械位移，能感受0.1角秒的微小角位移；</span><br><span class="line"> 3) 重复性好，线性度优良。在一定位移范围 (最小几十微米，最大可达数十至数百毫米) 内，输出线性度可达±0.1%，且比较稳定。</span><br><span class="line"> 4) 输出信号强。电压灵敏度一般可达数百毫伏每毫米，因此，有利于信号的传输和放大。</span><br><span class="line"></span><br><span class="line">主要缺点：</span><br><span class="line"> 1）存在零点残余电压；</span><br><span class="line"> 2）灵敏度、线性度和测量范围相互制约；</span><br><span class="line"> 3）传感器自身频率响应低，不适用于快速动态测量。</span><br></pre></td></tr></table></figure></p>
<p>自感：闭磁路型、开磁路型</p>
<p>互感：差动变压器、涡流式</p>
<img src="/Circuit-Lover/%E7%94%B5%E6%84%9F%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="">]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核定时器</title>
    <url>/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p><strong>节拍率</strong><br>中断周期性产生的频率就是系统频率，<br>也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz<br>高节拍率和低节<br>拍率的优缺点：<br>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。<br>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz的系统节拍率相比，中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率，本教程我们全部采用默认的 100Hz 系统节拍率。<br>方法一：make menuconfig<br>-&gt; Kernel Features<br>-&gt; Timer frequency (<choice> [=y])<br>方法二： param.h文件 # define USER_HZ    100    </p>
<p><strong>节拍数 jiffies</strong></p>
<p>extern u64 __jiffy_data jiffies_64; /<em>64系统</em>/<br>extern unsigned long volatile __jiffy_data jiffies;/<em>32系统</em>/</p>
<p>不管是 32 位还是 64 位的 jiffies，都有溢出的风险<br>假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 为的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。</p>
<p> HZ 表示一秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies/HZ 就<br>是系统运行时间，单位为秒。</p>
<img src="/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E8%8A%82%E6%8B%8D%E5%87%BD%E6%95%B0.jpg" class="">


<p>timer.h总结构体 timer_list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">struct list_head entry;</span><br><span class="line">unsigned long expires; /* 定时器超时时间，单位是节拍数 */</span><br><span class="line">struct tvec_base *base;</span><br><span class="line">void (*<span class="keyword">function</span>)(unsigned long); /* 定时处理函数 */</span><br><span class="line">unsigned long data; /* 要传递给 <span class="keyword">function</span> 函数的参数 */</span><br><span class="line">int slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list timer; /* 定义定时器 */</span><br><span class="line">/* 定时器回调函数 */</span><br><span class="line"> void <span class="keyword">function</span>(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">* 定时器处理代码</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* 如果需要定时器周期性运行的话就使用 mod_timer</span><br><span class="line"> * 函数重新设置超时值并且启动定时器。</span><br><span class="line"> */</span><br><span class="line"> mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(2000));</span><br><span class="line"> &#125;</span><br><span class="line"> /* 初始化函数 */</span><br><span class="line"> void init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> init_timer(&amp;timer); /* 初始化定时器 */</span><br><span class="line"></span><br><span class="line"> timer.function = <span class="keyword">function</span>; /* 设置定时处理函数 */</span><br><span class="line"> timer.expires=jffies + msecs_to_jiffies(2000);/* 超时时间 2 秒 */</span><br><span class="line"> timer.data = (unsigned long)&amp;dev; /* 将设备结构体作为参数 */</span><br><span class="line"></span><br><span class="line">add_timer(&amp;timer); /* 启动定时器 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 退出函数 */</span><br><span class="line"> void <span class="built_in">exit</span>(void)</span><br><span class="line"> &#123;</span><br><span class="line"> del_timer(&amp;timer); /* 删除定时器 */</span><br><span class="line"> /* 或者使用 */</span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">参考正点原子</span><br></pre></td></tr></table></figure>
<p><strong>纳秒、微秒和毫秒延时函数</strong><br>void ndelay(unsigned long nsecs)<br>void udelay(unsigned long usecs)<br>void mdelay(unsigned long mseces)</p>
]]></content>
  </entry>
  <entry>
    <title>Uboot常用命令</title>
    <url>/Linux-Lover/oot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>2.1、help命令</strong></p>
<p>查看某一个命令帮助信息，？命令名</p>
<p><strong>2.2、信息查询</strong></p>
<p>1、bdinfo 板子信息<br>2、printenv命令 重要</p>
<p><strong>2.3、setenv命令</strong></p>
<p>设置环境变量，也可以自定义环境变量，也可以删除环境变量<br>setenv xx = 空<br><strong>2.4、saveenv命令 重点</strong><br> 保存环境变量。</p>
<p> <strong>2.5、内存操作命令</strong></p>
<p> （.b 一个字节,.w两个字节，.l四个字节）<br>1、md命令   显示<br>2、nm命令  写入<br>3、mm命令  持续写入<br>4、mw命令   填充写入 mw.l 0a0a0a0a 10(0x10即为16个)<br>5、cp命令   复制<br>6、cmp命令   只输出一样与否</p>
<p><strong>2.8、网络操作命令</strong><br>网线插如到ENET2上，保证开发板和电脑处于同一个网段内。</p>
<p>1、ping命令 重点</p>
<p>2、dhcp命令</p>
<p>3、nfs命令 重点</p>
<p>4、tftp命令 重点</p>
<p><strong>2.9 EMMC/SD卡操作命</strong></p>
<p>1、mmc命令</p>
<p>2、mmc info命令</p>
<p>3、mmc rescan命令</p>
<p>4、mmc list命令</p>
<p>5、mmc dev命令</p>
<p>6、mmc part命令</p>
<p>7、mmc read命令</p>
<p>8、mmc write命令</p>
<p>9、mmc erase命令最好不要使用！！</p>
<p><strong>2.10 FAT格式文件系统操作命令</strong></p>
<p> 对于I.MX6U来说，SD/EMMC分为三个分区：<br>第一个：存放uboot<br>第二个:存放Linux zImage，.dtb。FAT<br>第三个：系统的根文件系统，EXT4</p>
<p>1、fatinfo命令</p>
<p>2、fatls命令</p>
<p>3、fstype命令</p>
<p>4、fatload命令    命令用于将指定的文件读取到 DRAM 中</p>
<p>5、fatwrite命令     命令用于将 DRAM 中的数据写入到 MMC 设备中</p>
<p>fatwrite mmc 1:1 80800000 zImage 0x5c2720</p>
<p><strong>2.11 EXT格式文件系统操作命令</strong></p>
<p>1、ext4ls命令(略)</p>
<p>2.13 BOOT操作命令</p>
<p>1、booz命令<br>要启动Linux必须将zImage，dtb放到DRAM。</p>
<p>2、bootm命令</p>
<p>3、boot命令</p>
<p>2.14 其他命令</p>
<p>1、reset命令</p>
<p>2、go命令</p>
<p>3、run命令</p>
<p>setenv mybooyemmc</p>
<p>run mybootemmc</p>
<p>4、mtest命令</p>
<h4 id="IMX6ULL-我的常用小记"><a href="#IMX6ULL-我的常用小记" class="headerlink" title="IMX6ULL 我的常用小记"></a>IMX6ULL 我的常用小记</h4><p><strong>挂载打不开？</strong><br>1、先ping下网络，然后再ubuntu下ifconfig 检查是否存在。<br>2、局域网络<br>3、文件的损坏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bootcmd 的 默 认 值 就 是 CONFIG_BOOTCOMMAND </span><br><span class="line">bootargs 的 默 认 值 就 是CONFIG_BOOTARGS</span><br><span class="line"></span><br><span class="line">4.1 从EMMC启动</span><br><span class="line"></span><br><span class="line">1、首先查看EMMC里面是否有系统，linux镜像zImage和.dtb文件。先将当前设备切换到EMMC：</span><br><span class="line"></span><br><span class="line">mmc dev 1     &#x2F;&#x2F;切换到EMMC  mmc dev 0 SD 卡</span><br><span class="line"></span><br><span class="line">fatls mmc 1:1  &#x2F;&#x2F;查看EMMC分区1里面的文件</span><br><span class="line">fatload mmc 1:1 80800000 zImage &#x2F;&#x2F;将zimage下载到DDR的0x80800000处</span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;将dtb读取到0X83000000</span><br><span class="line">bootz 80800000 – 83000000 &#x2F;&#x2F;启动内核</span><br><span class="line"></span><br><span class="line">如果内核启动成功，说明uboot支持emmc启动，验证成功。</span><br><span class="line"></span><br><span class="line">4.2 从网络启动</span><br><span class="line"></span><br><span class="line"> tftp 80800000 zImage         &#x2F;&#x2F;从tftp服务器下载zimage</span><br><span class="line"> tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;从tftp服务器下载.dtb     </span><br><span class="line"> bootz 80800000 – 83000000 &#x2F;&#x2F;启动系统</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;系统烧写</span><br><span class="line">tftp   确保开启！！！！不要从外不复制粘贴，会乱码</span><br><span class="line"></span><br><span class="line">setenv bootcmd  &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-ming-emmc.dtb;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;setenv bootcmd  &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb;bootz 80800000 - 83000000;&#39;</span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">tftp 80800000 zImage</span><br><span class="line"></span><br><span class="line">tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 80800000 zImage</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dt;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">saveenv</span><br><span class="line"></span><br><span class="line">boot</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">tftp 87800000 uart.bin</span><br><span class="line"></span><br><span class="line">go 87800000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">grep -nr  xxxx</span><br><span class="line"></span><br><span class="line">查找当前目录下包含关键字“NEON”的所有文件，并列出行号。</span><br><span class="line"></span><br><span class="line">QAQ--------&#x2F;修改bootargs进入根系统&#x2F;----------</span><br><span class="line"></span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.0.128:&#x2F;home&#x2F;ming&#x2F;linux&#x2F;nfs&#x2F;rootfs ip&#x3D;192.168.0.50:192.168.0.128:192.168.0.1:255.255.255.0::eth0:off&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buildrootfs 根文件系统</span><br><span class="line">setenv bootargs &#39;console&#x3D;tty1 console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.0.128:&#x2F;home&#x2F;ming&#x2F;linux&#x2F;nfs&#x2F;rootfs rw ip&#x3D;192.168.0.50:192.168.0.128:192.168.0.1:255.255.255.0::eth0:off&#39;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统根目录空间不足</title>
    <url>/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/1.jpg" class="">


<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/2.jpg" class="">





<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/4.jpg" class="">

<p>参考<br><a href="https://blog.csdn.net/daemon_2017/article/details/80660372" target="_blank" rel="noopener">https://blog.csdn.net/daemon_2017/article/details/80660372</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库完整性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<p><strong>数据库的完整性</strong></p>
<p>数据库的正确性和相容性。</p>
<p>注：数据的完整性和安全性是两个不同概念<br>数据的完整性<br>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据<br>防范对象：不合语义的、不正确的数据<br>数据的安全性<br>保护数据库防止恶意的破坏和非法的存取<br>防范对象：非法用户和非法操作</p>
<p>为维护数据库的完整性，DBMS必须：<br>1.提供定义完整性约束条件的机制<br>2.提供完整性检查的方法<br>3.违约处理</p>
<p><strong>实体完整性</strong></p>
<p>定义为列级约束条件     (Sno  CHAR(9)  PRIMARY KEY<br>定义为表级约束条件     PRIMARY KEY (Sno)</p>
<p><strong>参照完整性</strong></p>
<p> FOREIGN KEY (Cno) REFERENCES Course(Cno)    </p>
<p><strong>用户定义的完整性</strong></p>
<p>列值非空（NOT NULL）<br>列值唯一（UNIQUE）<br>检查列值是否满足一个布尔表达式（CHECK）<br> CHECK (Ssex=’女’ OR Sname NOT LIKE ‘Ms.%’)</p>
<p><em>_完整性约束命名字句</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONSTRAINT &lt;完整性约束条件名&gt;</span><br><span class="line">［PRIMARY KEY短语</span><br><span class="line">   |FOREIGN KEY短语</span><br><span class="line">   |CHECK短语］</span><br><span class="line"></span><br><span class="line">可以先删除原来的约束条件，再增加新的约束条件</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999)，</span><br></pre></td></tr></table></figure>
<p><strong>域中的完整性限制</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">［例15］建立一个性别域GenderDomain，并对其中的限制命名</span><br><span class="line">           CREATE DOMAIN GenderDomain CHAR(2)</span><br><span class="line">           CONSTRAINT GD CHECK ( VALUE IN (<span class="string">'男'</span>，<span class="string">'女'</span>) );</span><br><span class="line"></span><br><span class="line">在域GenderDomain上增加限制条件GDD。</span><br><span class="line">          ALTER  DOMAIN  GenderDomain  </span><br><span class="line">         ADD CONSTRAINT GDD CHECK (VALUE IN ( <span class="string">'1'</span>，<span class="string">'0'</span>) ); </span><br><span class="line">	就把性别的取值范围由(<span class="string">'男'</span>，<span class="string">'女'</span>)改为 ( <span class="string">'1'</span>，<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>触发器</strong></p>
<p>定义触发器 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER语法格式</span><br><span class="line">	   </span><br><span class="line">	  CREATE TRIGGER &lt;触发器名&gt;  </span><br><span class="line">       &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">        FOR EACH  &#123;ROW | STATEMENT&#125;</span><br><span class="line">      ［WHEN &lt;触发条件&gt;］</span><br><span class="line">        &lt;触发动作体&gt;</span><br><span class="line"></span><br><span class="line">［例18］  定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</span><br><span class="line">    CREATE TRIGGER Insert_Or_Update_Sal </span><br><span class="line">         BEFORE INSERT OR UPDATE ON Teacher  </span><br><span class="line">        /*触发事件是插入或更新操作*/</span><br><span class="line">         FOR EACH ROW                      /*行级触发器*/</span><br><span class="line">        AS BEGIN                                  /*定义触发动作体，是PL/SQL过程块*/</span><br><span class="line">              IF (new.Job=<span class="string">'教授'</span>) AND (new.Sal &lt; 4000) THEN   </span><br><span class="line">              new.Sal :=4000;                </span><br><span class="line">              END IF;</span><br><span class="line">        END;</span><br></pre></td></tr></table></figure>


<p>激活触发器<br>同一个表上的多个触发器激活时遵循如下的执行顺序：<br>（1） 执行该表上的BEFORE触发器；<br>（2） 激活触发器的SQL语句；<br>（3） 执行该表上的AFTER触发器。</p>
<p>删除触发器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">DROP TRIGGER Insert_Sal ON Teacher;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>union的用法及应用场景</title>
    <url>/C-C-Lover/nion%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>union的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">大小一块内存选最大的那个声明。</span><br><span class="line">struct&#123;</span><br><span class="line">	char name[20];</span><br><span class="line">    int num ;</span><br><span class="line">    char sex;</span><br><span class="line">    char profession;</span><br><span class="line">    union &#123;</span><br><span class="line">    <span class="built_in">float</span> score;</span><br><span class="line">    char course[20];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>共用体还真是贴切——完全就是共用一个内存首地址。<br>nion成员共享同一块大小的内存，一次只能使用其中的一个成员；<br>应用场景：</p>
<p>1、一个学生与老师的数据表中，有一项共用的（老师所教课程与学生课程分数）<br>2、union量的存放顺序是所有成员都从低地址开始存放的，可以用来判断大端和小端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int checkCPU()</span><br><span class="line">&#123;</span><br><span class="line">     union cpu</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        char b;</span><br><span class="line">     &#125;c;</span><br><span class="line">    c.a = 1;</span><br><span class="line">    <span class="built_in">return</span> ( c.b == 1 );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器算法小结</title>
    <url>/C-C-Lover/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>vector 单端，尾插<br>deque 双端，首部尾部插<br>stack  先进后出（deques首部闭合）  pop push<br>quece 队列，先进先出<br>list   链表，随时插入</p>
<p>set 唯一值，数值顺序排顺序</p>
<p>map/multimap    关联式map&lt;T1,T2&gt; map TT;</p>
<p>map.insert(map&lt;int,string&gt;::value_type(1,”小李”)）</p>
<p>map.insert(pair &lt;int , string &gt;(3,”小张”))；</p>
<p>map.insert(make_pair(-1,”小张-1”))；</p>
<p><strong>头文件</strong><br>#include <algorithm> //算法<br>#include <numeric> //数学<br>#include <functional>//模板<br>#include <memory>//智能指针 auto_ptr</p>
<p><strong>概念</strong><br>一元函数对象：函数参数1个；<br>二元函数对象：函数参数2个；<br>一元谓词对象：函数参数1个,返回bool；<br>二元谓词对象：函数参数2个,返回bool；</p>
<p>遍历算法 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">for_each(v1.begin(),v1.end(), show)   //容器为int</span><br><span class="line"></span><br><span class="line">void show(const int &amp;iItem)  </span><br><span class="line"></span><br><span class="line">&#123;         cout&lt;&lt; iItem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">transform() //转移容器，用于合并，函数返回值</span><br><span class="line">transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase);      </span><br><span class="line">int increase (int i) </span><br><span class="line"></span><br><span class="line">&#123;     <span class="built_in">return</span> i+1;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找算法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adjacent_find()；查找相邻重复元素，返回指向这对元素的第一个元素的迭代器。</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt;::iterator it = adjacent_find(v.begin(),vend());</span><br><span class="line"></span><br><span class="line">binary_search（）;在有序序列中查找value,无序不可</span><br><span class="line"></span><br><span class="line">bool bFind = binary_search(setInt.begin(),setInt.end(),5);</span><br><span class="line"></span><br><span class="line">count（）；计算个数</span><br><span class="line"></span><br><span class="line">intiCount = count(vecInt.begin(),vecInt.end(),2);  </span><br><span class="line"></span><br><span class="line">count_if()；</span><br><span class="line"></span><br><span class="line">bool GreaterThree(int iNum)</span><br><span class="line"></span><br><span class="line">&#123;  <span class="keyword">if</span>(iNum&gt;=3)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int iCount = count_if(vecIntA.begin(),vecIntA.end(), GreaterThree);</span><br><span class="line"></span><br><span class="line">find()；find顺序查找O(n)</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5);</span><br><span class="line"></span><br><span class="line">find_if()；</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree);</span><br></pre></td></tr></table></figure>
<p>排序算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">merge();合并排序</span><br><span class="line"></span><br><span class="line">merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin();</span><br><span class="line"></span><br><span class="line">sort();内省排序O(n*log2n)</span><br><span class="line"></span><br><span class="line">sort(vecStu.begin(),vecStu.end(),Compare);//bool()函数</span><br><span class="line"></span><br><span class="line">random_shuffle();随机排序</span><br><span class="line"></span><br><span class="line">random_shuffle(str.begin(),str.end());   </span><br><span class="line"></span><br><span class="line">reverse()；反序</span><br><span class="line"></span><br><span class="line">拷贝和替换算法</span><br><span class="line"></span><br><span class="line">copy()；</span><br><span class="line"></span><br><span class="line">replace()；</span><br><span class="line"></span><br><span class="line">replace(vecIntA.begin(), vecIntA.end(), 3,8);          //（1,3，5,3,9）&#123;1,8,5,8,9&#125;</span><br><span class="line"></span><br><span class="line">replace_if(vecIntA.begin(),vecIntA.end(), GreaterThree, 8);           </span><br><span class="line"></span><br><span class="line">swap();</span><br><span class="line"></span><br><span class="line">swap(vecIntA,vecIntB);</span><br></pre></td></tr></table></figure>

<p>算术和生成算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accumulate()；</span><br><span class="line"></span><br><span class="line">int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100);</span><br><span class="line"></span><br><span class="line">fill()；</span><br><span class="line"></span><br><span class="line"> fill(vecIntA.begin(), vecIntA.end(),8);</span><br></pre></td></tr></table></figure>
<p>集合算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">set_union()  并集有序</span><br><span class="line"></span><br><span class="line">set_intersection()交集有序</span><br><span class="line"></span><br><span class="line">set_difference()第一个有第二个没有的差集</span><br><span class="line"></span><br><span class="line">set_difference(vecIntA.begin(), vecIntA.end(),vecIntB.begin(), vecIntB.end(), vecIntC.begin());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多核处理器概念</title>
    <url>/Linux-Lover/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>这种架构在并发程序设计中，大致会引来两个问题。<br>一个是内存可见性，一个是Cache一致性流量。<br>内存可见性属于并发安全的问题，Cache一致性流量引起的是性能上的问题。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux并发与竞争</title>
    <url>/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<p><strong>Linux 系统并发产生的原因</strong><br>①、多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。<br>②、抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以<br>在任意时刻抢占正在运行的线程，从而运行其他的线程。<br>③、中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可<br>是很大的。<br>④、SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并<br>发访问。</p>
<p>临界区就是共享数据段<br>一般在编写驱动的时候就要考虑到并发与竞争，而不是驱动都编写完了然后再处理并发与竞争。</p>
<p><strong>原子操作</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/atomic.h&gt;</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line"> int counter;</span><br><span class="line">&#125; atomic_t;/*32位*/</span><br><span class="line">atomic_t v = ATOMIC_INIT(0); /* 定义并初始化原子变零 v=0 */</span><br><span class="line">atomic_set(10); /* 设置 v=10 */</span><br><span class="line">atomic_read(&amp;v); /* 读取 v 的值，肯定是 10 */</span><br><span class="line">atomic_inc(&amp;v); /*++v*/</span><br><span class="line">特点：原子操作只能对整形变量或者位进行保护</span><br><span class="line"></span><br><span class="line">操作一个atomic lock ; </span><br><span class="line">初始赋值为1，打开时判断， 0 错误返回 ， 1 atomic_dec(lock)，同时减1为0 ，（故一个时刻只能打开一次）</span><br><span class="line">关闭 atomic_inc(lock) +1 </span><br><span class="line">操作过程打不开，需等待第一个驱动任务完成，关闭函数atomic_inc(lock) +1 ，然后再次打开</span><br></pre></td></tr></table></figure>
<p><strong>自旋锁</strong><br>#include &lt;linux/atomic.h&gt;<br>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以<br>用，可以访问共享资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct spinlock &#123;</span><br><span class="line"> union &#123;</span><br><span class="line"> struct raw_spinlock rlock;</span><br><span class="line"> <span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"> <span class="comment"># define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"> struct &#123;</span><br><span class="line"> u8 __padding[LOCK_PADSIZE];</span><br><span class="line"> struct lockdep_map dep_map;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"> &#125; spinlock_t;</span><br><span class="line">特点：自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了</span><br><span class="line"></span><br><span class="line">死锁：</span><br><span class="line">被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数。自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，导致死锁现象的发生</span><br><span class="line"></span><br><span class="line">中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生</span><br><span class="line"></span><br><span class="line"> DEFINE_SPINLOCK(lock) /* 定义并初始化一个锁 */</span><br><span class="line"></span><br><span class="line">/* 线程 A */</span><br><span class="line">void <span class="function"><span class="title">functionA</span></span> ()&#123;</span><br><span class="line">unsigned long flags; /* 中断状态 */</span><br><span class="line">spin_lock_irqsave(&amp;lock, flags) /* 获取锁 推荐用这个*/</span><br><span class="line">/* 临界区 */</span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags)  /* 释放锁推荐用这个 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/* 中断服务函数 */ </span><br><span class="line">void <span class="function"><span class="title">irq</span></span>() &#123;</span><br><span class="line">spin_lock(&amp;lock) /* 获取锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line">spin_unlock(&amp;lock) /* 释放锁 */</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> 其他锁：</span><br><span class="line"> 读写锁》》》顺序锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E8%87%AA%E6%97%8B%E9%94%81.jpg" class="" title="自旋锁">


<p><strong>信号量</strong></p>
<p>（1）自旋锁，<strong>信号量可以使线程进入休眠状态</strong>，但信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。<br>（2）如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换<br>线程引起的开销要远大于信号量带来的那点优势<br>(3)计数型信号量不能用于互斥访问，因为它允许多个线程同时访问共享资源。(二值信号值)<br>自动唤醒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line">struct semaphore &#123;</span><br><span class="line">raw_spinlock_t lock;</span><br><span class="line">unsigned int count;</span><br><span class="line">struct list_head wait_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct semaphore sem; /* 定义信号量 */</span><br><span class="line">sema_init(&amp;sem, 1)； /* 初始化信号量 */</span><br><span class="line">down(&amp;sem); /* 申请信号量 */</span><br><span class="line">/* 临界区 */</span><br><span class="line">up(&amp;sem);</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" class="" title="信号量">



<p><strong>互斥体-mutex</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct mutex &#123;</span><br><span class="line">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span><br><span class="line">atomic_t count;</span><br><span class="line">spinlock_t wait_lock;</span><br><span class="line">&#125;;</span><br><span class="line"> struct mutex lock; /* 定义一个互斥体 */</span><br><span class="line">mutex_init(&amp;lock); /* 初始化互斥体 */</span><br><span class="line"></span><br><span class="line"> mutex_lock(&amp;lock); /* 上锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line"> mutex_unlock(&amp;lock); /* 解锁 *</span><br><span class="line">①、mutex 可以导致休眠，因此不能在中断中使用 mutex，__中断中只能使用自旋锁__。</span><br><span class="line">②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</span><br><span class="line">③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并</span><br><span class="line">且 mutex 不能递归上锁和解锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BA%92%E6%96%A5%E4%BD%93.jpg" class="" title="互斥体">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>gpioled 基本框架</title>
    <url>/Linux-Lover/pioled-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>用来复习QvQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define GPIOLED_CNT   1       /*数量*/</span></span><br><span class="line"><span class="comment">#define GPIOLED_NAME  "gpioled"    /*名字*/</span></span><br><span class="line"><span class="comment">#define LEDOFF       0       /*关闭*/ </span></span><br><span class="line"><span class="comment">#define LEDON       1         /*开启*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct gpioled_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid ;</span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    struct device_node * nd;</span><br><span class="line">    int led_gpio;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct gpioled_dev gpioled;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled; /*传递结构*/</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">			 size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    int ret ;</span><br><span class="line">    unsigned char databuf[1];</span><br><span class="line">    struct gpioled_dev *dev = filp-&gt;private_data;</span><br><span class="line">    ret = __copy_from_user(databuf,buf,count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(databuf[0] == LEDON)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_value(dev-&gt;led_gpio,0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (databuf[0] == LEDOFF)</span><br><span class="line">    &#123;</span><br><span class="line">       gpio_set_value(dev-&gt;led_gpio, 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 操作集 */</span><br><span class="line">static const struct file_operations led_fops = &#123;</span><br><span class="line">    .owner		=	THIS_MODULE,</span><br><span class="line">	.write		=	led_write,</span><br><span class="line">	.open		=	led_open,</span><br><span class="line">	.release	=	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init led_init(void )</span><br><span class="line">&#123;</span><br><span class="line">int ret  ;</span><br><span class="line">    gpioled.major = 0;</span><br><span class="line">    <span class="keyword">if</span> (gpioled.major)</span><br><span class="line">    &#123;</span><br><span class="line">        gpioled.devid = MKDEV(gpioled.major,0);</span><br><span class="line">        register_chrdev_region(gpioled.devid,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alloc_chrdev_region(&amp;gpioled.devid,0,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">        gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">        gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"gpioled.major = %d ,gpioled.minor = %d\r\n"</span>,gpioled.major,gpioled.minor);</span><br><span class="line"></span><br><span class="line">*初始化cdev*/</span><br><span class="line">    gpioled.cdev.owner = THIS_MODULE ;</span><br><span class="line">    /*初始化*/</span><br><span class="line">    cdev_init(&amp;gpioled.cdev,&amp;led_fops);</span><br><span class="line">    </span><br><span class="line">  ret = cdev_add(&amp;gpioled.cdev,gpioled.devid,GPIOLED_CNT);</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; 0) </span><br><span class="line">        goto fail_cdev;  </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    /*创建class*/</span><br><span class="line">    gpioled.class = class_create(THIS_MODULE,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.class))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*创建device*/</span><br><span class="line">   gpioled.device = device_create(gpioled.class,NULL,gpioled.devid,NULL,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.device))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   /* 1，获取设备节点 */</span><br><span class="line">    gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    /* 2, 获取LED所对应的GPIO */</span><br><span class="line">    gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">        printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">    /* 3,申请IO */</span><br><span class="line">    ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpio"</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 4,使用IO，设置为输出 */</span><br><span class="line">    ret = gpio_direction_output(gpioled.led_gpio, 1);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		goto fail_setoutput;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 0);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">    fail_setoutput:</span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line">    fail_findnode:</span><br><span class="line">    fail_cdev:</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">static void __exit led_exit(void )</span><br><span class="line">&#123;</span><br><span class="line">      /* 关灯 */</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 1);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;gpioled.cdev);</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">    device_destroy(gpioled.class,gpioled.devid);</span><br><span class="line">    class_destroy(gpioled.class);</span><br><span class="line"></span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树</title>
    <url>/Linux-Lover/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<p>Linux 内核中 ARM 架构下有太多的冗余的垃圾板</p>
<p>级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树</p>
<p>dts、dtbs、dtc、dtsi<br>设备树包括DTC（device tree compiler）,DTS(device tree source和DTB（device tree blob）。DTC为编译工具，它可以将.dts文件编译成.dtb文件。</p>
<p><strong>of 查找设备节点</strong></p>
<p>of_find_node_by_name 函数通过节点名字查找指定的节点</p>
<p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点</p>
<p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点</p>
<p>of_find_node_by_path 函数通过路径来查找指定的节点</p>
<p><strong>查找父/ 子节点的 OF 函数</strong></p>
<p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)</p>
<p>of_get_next_child 函数用迭代的查找子节点</p>
<p><strong>提取属的 性值的 OF 函数</strong></p>
<p>of_find_property 函数用于查找指定的属性</p>
<p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，</p>
<p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值</p>
<p>of_property_read_u8_array 函数</p>
<p>of_property_read_u16_array  函数</p>
<p>of_property_read_u32_array  函数</p>
<p>of_property_read_u64_array</p>
<p>of_property_read_string 函数用于读取属性中字符串值</p>
<p>of_n_addr_cells 函数用于获取#address-cells 属性值</p>
<p>of_size_cells 函数用于获取#size-cells 属性值</p>
<p>其他常用的 OF</p>
<p>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性</p>
<p>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性</p>
<p>值，函数属性如下</p>
<p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址</p>
<p>of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型</p>
<p>of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。</p>
<p>因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>yocto 根文件命令小记</title>
    <url>/Linux-Lover/octo-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>cat /proc/devices  设备</p>
<p>/lib/module</p>
<p>depmod //第一次加载驱动的时候需要运行此命令</p>
<p>modprobe chrdevbase</p>
<p>//可以看到“chrdevbase init！” chrdevbase_init 输出的信息，说明模块加载成功！</p>
<p>cat /proc/devices  //查看设备信息</p>
<p>mknod /dev/chrdevbase c 200 0//设备节点</p>
<p>原因如下<br>（注意：这里不要有后缀.ko，不然会找不到，如：ko文件名是chrdevbase.ko，那么modprobe chrdevbase） 就可以了。具体步骤：</p>
<p>rmmod beep.ko</p>
<p>···<br>cd /proc/device-tree  设备树信息</p>
<p>cat /proc/interrupts  设备中断</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动开发准备知识</title>
    <url>/Linux-Lover/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>学习 Linux驱动开发</strong></p>
<p>linaro（利纳罗） 5.4.0   交叉编译器<br>ubuntu 16.04.9<br>flash EMMC NAND——–ROM 8g<br>DDR3 ——RAM 512m<br>Linux 内核版本为 4.1.15，其支持设备树(Device tree)<br> Linux 中的三大类驱动：字符设备驱动（简单）、块设备驱动（储存有关）和网络设备驱动（上网功能）（过于复杂开发商写好）。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl +gpio系统</title>
    <url>/Linux-Lover/nctrl-gpio%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>pinctl子系统 设置GPIO复用电气属性</strong><br>imx6ull.dtsi文件</p>
<p>IO分类：<br>IOMUXC SNVS控制器<br>IOMUXC控制器<br>gpr控制器</p>
<p>添加一个PIN的信息 打开imx6ul-pinfunc.h</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pinctrl_hog_1: hoggrp-1 &#123;</span><br><span class="line">			fsl,pins = &lt;</span><br><span class="line">				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 </span><br><span class="line">			&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19  0x0090 0x031C 0x0000 0x5 0x0</span><br><span class="line">&lt;mux_reg 	conf_reg	 input_reg	 mux_mode	 input_val&gt;</span><br><span class="line">0x0090 		0x031C 	 0x0000 	  0x5 		 0x0</span><br></pre></td></tr></table></figure>
<p>mux_reg：IOMUXC父节点首地址0x020e0000，因此UART1_RTS_B这个PIN的mux寄存器地址 就是：0x020e0000+0x0090=0x020e 0090。<br>conf_reg：0x020e0000+0x031C=0x020e 031C，这个寄存器就是UART1_RTS_B的电气属性配置寄存器。<br>input_reg，为0，表示UART1_RTS_B这个PIN没有input功能。<br>mux_mode： 5表示复用为GPIO1_IO19，将其写入0x020e 0090<br>input_val：就是写入input_reg寄存器的值。</p>
<p><strong>pincrtl驱动原理？</strong><br>    全局搜索，设备节点里面的compatible属性的值，看看在哪个.c文件里面有，那么此.c文件就是驱动文件。<br>    找到pinctrl-imx6ul.c文件，那么此文件就是6UL/6ULL的pinctrl驱动文件。当驱动和设备匹配以后执行，probe函数。也就是imx6ul_pinctrl_probea函数，其中<br>imx_pinconf_set函数设置PIN的电气属性<br>imx_pmx_set函数设置PIN的复用</p>
<p><strong>gpio子系统 设置引脚属性</strong></p>
<p>文件devicetree\bindings\gpio<br>用法：<br>cd-gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_LOW&gt;;</p>
<p>设备数函数常用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 2, 获取LED所对应的GPIO */</span><br><span class="line">   gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">       printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">   /* 3,申请IO */</span><br><span class="line">   ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpios"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   /* 4,使用IO，设置为输出 */</span><br><span class="line">   ret = gpio_direction_output(gpioled.led_gpios, 1);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	goto fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">   gpio_set_value(gpioled.led_gpio, 0);</span><br></pre></td></tr></table></figure>





<p><strong>gpio驱动原理</strong><br>1、gpiolib<br>两部分，给原厂编写GPIO底层驱动的，给驱动开发人员使用GPIO操作函数的。<br>使用gpiochip_add向系统添加gpio_chip，这些都是半导体原厂做的，这部分就是最底层的GPIO驱动。<br>2、gpio驱动<br>在drivers/gpio目录下，gpio-xxx.c文件为具体芯片的驱动文件，</p>
<p>申请IO的时候失败，大部分原因是这个IO被其他外设占用了。检查设备树，查找有哪些使用同一IO的设备。<br>    1，检查复用，也就是pinctl设置。<br>    2，gpio使用</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>信号高级用法(sigaction与sigqueue)</title>
    <url>/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><strong>信号的高级用法</strong></p>
<p>sigaction函数注册信号处理函数<br>int  sigaction(int signum,const struct sigaction *act,const struct sigaction *old);</p>
<p>第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一 个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。<br>第二个参数是指向结构sigaction的一个实例的指针，在结构 sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理<br>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。<br>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigaction 结构体</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_sigaction &#x3D; myhandle;</span><br><span class="line">act.sa_flags &#x3D;SA_SIGINFO;&#x2F;&#x2F;表示能接受数据</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;recv a sig&#x3D;%d\n&quot;, sig);	</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;         </span><br><span class="line">	struct sigaction act;</span><br><span class="line">	sigset_t sa_mask;</span><br><span class="line">	act.sa_handler &#x3D; handler;</span><br><span class="line">	act.sa_flags &#x3D; 0;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	&#x2F;&#x2F;测试信号安装函数</span><br><span class="line">	sigaction(SIGINT, &amp;act, NULL);</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">	pause();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装my_signal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define ERR_EXIT(m) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        perror(m); \</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">    &#125; <span class="keyword">while</span>(0)void handler(int sig);/* 系统调用signal()实际上调用了sigaction() */</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler);int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    my_signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">for</span> (; ;)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler)</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    struct sigaction oldact;</span><br><span class="line">    act.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;act, &amp;oldact) &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> SIG_ERR;</span><br><span class="line">    <span class="built_in">return</span> oldact.sa_handler; // 返回先前的处理函数指针&#125;void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rev sig=%d\n"</span>, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/mysignal.jpg" class="" title="5s阻塞后到达">

<p>typedef union sigval<br>{<br>int sival_int;<br>void *sival_ptr;<br>}sigval_t; </p>
<p>sigqueue新的信号发送函数<br>原型:int sigqueue(pid_t pid, int sig, const union sigval value);<br> 第一个参数是指定接收信号的进程id<br> 第二个参数确定即将发送的信号<br> 第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line">pid_t pid_Array[10]; //pid 数组</span><br><span class="line">void myhandle(int sig,siginfo_t*st, void *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sig == SIGRTMIN)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子1收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[1] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">if</span>(sig == SIGRTMIN+1)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子2收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[3] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sig == SIGRTMIN+2)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：父亲收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"pid[0]:%d  pid[1]%d \n"</span>,pid_Array[0],pid_Array[1]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid;</span><br><span class="line">	</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_sigaction = myhandle;</span><br><span class="line">	act.sa_flags =SA_SIGINFO; //可传递数据</span><br><span class="line">	int i=0;</span><br><span class="line">	/*注册信号*/</span><br><span class="line">     <span class="keyword">if</span>(sigaction(SIGRTMIN, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+1, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+2, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*fork两个进程*/</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid_Array[i] = pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">			perror(<span class="string">"fork fail"</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(pid&gt;0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"fork %d \n"</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid ==  0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"i:%d\n"</span>,i);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*两个进程处理函数*/</span><br><span class="line">	<span class="keyword">if</span>( pid==0 &amp;&amp; i == 0)  //第一个子进程</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程1运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程1醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = getpid()*2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子1给子2发信号  %d \n"</span>,getpid()*2);</span><br><span class="line">		sigqueue(pid_Array[1],SIGRTMIN+1,value);     </span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid==0 &amp;&amp; i==1)//第二个子进程</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程2运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程2醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[3];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子2给父进程发 %d \n"</span>,pid_Array[3]);</span><br><span class="line">		sigqueue(getppid(),SIGRTMIN+2,value);     //父进程pid</span><br><span class="line">			<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//父进程</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[1]; //传递进程2 pid   给进程 1 </span><br><span class="line">		sigqueue(pid_Array[0],SIGRTMIN,value);    </span><br><span class="line"></span><br><span class="line">		sleep(10);</span><br><span class="line">		int mypid =0;</span><br><span class="line">		int  pidnum = 1 ;</span><br><span class="line">		<span class="keyword">while</span>((mypid = waitpid(-1,NULL,WNOHANG))&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"子进程：%d 退出%d\n"</span>,pidnum++,mypid); </span><br><span class="line">		&#125;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"父进程退出\n"</span>);</span><br><span class="line">	     <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> ---------------------------</span><br><span class="line"> ming@ubuntu:~/Day6/22$ ./3</span><br><span class="line">fork 0 </span><br><span class="line">i:0</span><br><span class="line">子进程1运行然后睡眠</span><br><span class="line">fork 1 </span><br><span class="line">i:1</span><br><span class="line">子进程2运行然后睡眠</span><br><span class="line">处理函数：孩子1收到信号5135</span><br><span class="line">信号，子进程1醒来</span><br><span class="line">子1给子2发信号  10268 </span><br><span class="line">处理函数：孩子2收到信号10268</span><br><span class="line">信号，子进程2醒来</span><br><span class="line">子2给父进程发 10268 </span><br><span class="line">处理函数：父亲收到信号10268</span><br><span class="line">pid[0]:5134  pid[1]5135 </span><br><span class="line">子进程：1 退出5134</span><br><span class="line">父进程退出</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>和kill函数相比Int kill(pid_t pid, int siq)多了参数<br>但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket-Api编程</title>
    <url>/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>多并发？</strong></p>
<p>每来一个客户，创建一个进程的思路。</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91.jpg" class="" title="基本框架">

<p><strong>流协议与粘包</strong></p>
<p>tcp    字节流 无边界<br>udp    消息、数据报 有边界<br>对等方，一次读操作，不能保证完全把消息读完。<br>对方接受数据包的个数是不确定的。</p>
<hr>
<p><strong>TCP/IP协议的11种状态</strong></p>
<p>两端同时关闭    将产生closing状态，最后双方都进入TIME_WAIT状态。<br>执行主动关闭的那一端，进入TIME_WAIT状态</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/11.jpg" class="" title="11种">


<p><strong>为什么TCP/IP要三次握手，和四次断开？</strong></p>
<p>全双工协议。（客户收发、服务收发确认）</p>
<p><em>_TIME_WAIT 时间是多长2MSL （2倍的最大生命期时间）</em></p>
<p>原因：（ACK y+1）如果发送失败可以重发。 最后 一个确认包的确认完成。<br>服务器端处于closed状态，不等于客户端也处于closed状态。。</p>
<p><strong>SIGPIPE</strong></p>
<p>如果对方socket已关闭，对等方再发写数据，则会产生SIGPIPE信号<br>常做忽略处理：<br>signal(SIGPIPE, SIG_IGN); </p>
<p><strong>close与shutdown区别</strong><br>refcnt 引用计数</p>
<p>close终止了数据传送的两个方向。<br>shutdown可以有选择的终止某个方向的数据传送或者终止数据传送的两个方向。<br>shutdown how=1就可以保证对等方接收到一个EOF字符，而不管其他进程是否已经打开了套接字（引用计数!）。而close不能保证，直到套接字引用计数减为0时才发送。也就是说直到所有的进程都关闭了套接字。</p>
<p><em>了解5种IO模型_</em></p>
<p>阻塞IO<br>非阻塞IO<br>复用IO<br>信号驱动IO<br>异步IO</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统移植问题</title>
    <url>/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>工具区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bootmgr  RAM空间  选择  windows下</span><br><span class="line">Grub  引导不同的内核启动 RAM空间  选择  支持多操作系统</span><br><span class="line">BIOS  初始化硬件不能引导OS内核   ROM芯片上的程序 开启时运行的第一个程序</span><br><span class="line">Bootloader 引导内核程序运行 RAM空间 内核运行前的程序 Bootloader =BIOS+Grub/Bootmgr </span><br><span class="line">U-boot  通用Bootloader</span><br><span class="line">U-Boot，全称为Universal Boot Loader，即通用Bootloader</span><br></pre></td></tr></table></figure>
<p><strong>ARM U-boot 内核传递参数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">•	U-boot引导程序，在启动的时候会给给Linux Kernel传递很多参数</span><br><span class="line">•	串口波特率，RAM大小，视频fb，MAC地址等</span><br><span class="line">•	设备树的入口地址</span><br><span class="line">•	u-boot如何进行传递的？</span><br><span class="line">•	U-boot把要传递给kernel的东西：保存在struct tag数据结构中</span><br><span class="line">•	启动kernel时，把这个结构体的物理地址传给kernel</span><br><span class="line">•	kernel解析传递的参数？</span><br><span class="line">•	Linux内核通过这个地址，用parse_tags分析出传递过来的参数</span><br><span class="line"></span><br><span class="line">1、内核引导程 arch/arm/lib/vectors.S   用完释放 kernel_entry()</span><br><span class="line">2、内核启动</span><br><span class="line">执行head-armv.S     关闭中断、关闭 MMU。②、关闭 </span><br><span class="line">ENTERY(stxet)      arch/arm/kernel/head.S</span><br><span class="line">Start_kernel();</span><br><span class="line"></span><br><span class="line">ARM架构上，u-boot向Linux内核传递参数利用了R0，R1和R2三个寄存器</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/linux.jpg" class="">


<p>Linux驱动开发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主设备号</span><br><span class="line">•	主设备号标识设备对应的驱动程序。</span><br><span class="line">次设备号</span><br><span class="line">•	次设备号由内核使用，用于正确确定设备文件所指的设备。</span><br><span class="line">字符设备的两种注册方式</span><br><span class="line">void cdev_init(struct cdev *cdev, struct file_operations *fops)</span><br><span class="line">int register_chrdev(unsigned int major, const char *namem , struct file_operations *fopen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：insomd加载一个驱动模块，会执行模块中的那个函数？rmmod呢？这两个函数在设计上要注意什么？遇到过卸载驱动出现异常没？是什么问题引起的？</span><br><span class="line">$ insmod  hello.ko  // 模块加载函数 , 只加载hello.ko模块;</span><br><span class="line">$ modprobe  -r hello.ko	// 模块加载函数,  将加载hello.ko 依赖的所有模块;</span><br><span class="line">（1）insmod调用初始函数，rmmod调用退出函数；</span><br><span class="line">（2）卸载模块时曾出现卸载失败的原因：原因是存在进行中的使用模块，检查代码后发现产生了死锁的问题。</span><br><span class="line">（3）初始化函数中申请的资源在出口函数中要释放：也就是一个模块注册进内核，退出内核时要清理所带来的影响，带走一切不留下一点痕迹。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/Other-Lover/xo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>npm install hexo-asset-image –save</p>
<p>npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save</p>
<p>hexo new”postName” #新建文章</p>
<p>hexo new page”pageName” #新建页面</p>
<p>hexo new page categories 分类页面</p>
<p>hexo new page tags 分类页面</p>
<p>hexo new page about  关于页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #将.deploy目录部署到指定空间</p>
<p>hexo help # 查看帮助</p>
<p>hexo version #查看Hexo的版本</p>
<p>hexo server 本地</p>
<p>hexo deploy 部署</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>序号</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>5</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td></td>
<td>192</td>
</tr>
</tbody></table>
<p><strong>着重号</strong></p>
<p><em>这是斜体</em> 或 <em>这也是斜体</em></p>
<p><strong>这是粗体</strong></p>
<p><strong><em>这是加粗斜体</em></strong></p>
<p><del>这是删除线</del></p>
<p>内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>///</p>
<p>推荐链接：<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>背景清晰度：<a href="https://www.zhihu.com/question/268140594/answer/335335120" target="_blank" rel="noopener">https://www.zhihu.com/question/268140594/answer/335335120</a></p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6>]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>架构概念</title>
    <url>/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<img src="/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84.jpg" class="" title="架构概念">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>变量知识点</title>
    <url>/C-C-Lover/%E5%8F%98%E9%87%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>i.    预编译: 处理#开头的指令，比如拷贝 #include 包含的文件代码,#define 宏定义的替换 , 条件编译等,就是为编译做的预备工作的阶段。<br>ii.    编译: 分析代码的语法和语义, 将变量和关键字 翻译成中间代码或者汇编代码;<br>iii.    汇编: 将汇编语言翻译为机器可识别的二进制代码.o 是二进制文件<br>iv.    链接:将目标文件所需的库, 文件进行链接</p>
<p>volatile应该是在编译阶段，extern在链接阶段。<br>volatile：告诉编译器，修饰的变量不能优化，每次读取需要从内存中读取；</p>
<p>Static</p>
<ol>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>extern “C”<br>•    被 extern 限定的函数或变量是 extern 类型的<br>•    被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的<br>•    extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
</ol>
<p>#define dPS struct s *             // 宏定义 dPS 表示 struct s*<br>typedef struct s * tPS;            // typedef 表示，将struct *s 重命名为tPS</p>
<p>#define是一个预处理器令牌：编译器本身将永远看不到它。<br>typedef是一个编译器令牌：预处理器不关心它。</p>
<p>•    typedef以分号结尾，而#define不以分号结尾。<br>•    typedef用于为现有类型赋予新的符号名称，而#define用于创建任何类型和值的别名。</p>
<p> explicit关键字<br>只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).<br>  如下面写法是否被允许。<br>  CxString string1(24);<br> CxString string2 = 10;  </p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>串口、COM、RS232、RS485</title>
    <url>/MCU-Lover/%E5%8F%A3%E3%80%81COM%E3%80%81RS232%E3%80%81RS485/</url>
    <content><![CDATA[<p><strong>uart</strong> （Universal Asynchronous Receiver／Transmitter）<br><strong>usart</strong> （Universal Synchronous Asynchronous Receiver Transmitter）</p>
<p>Uart  异步。（预先知道波特率的大小,传输效率比同步通信要低。）  全双工方式<br>Usart <strong>同步多条时钟线</strong>，也可当做uart使用。</p>
<p>COM异步通信口，被USB取代</p>
<p>COM/USB -&gt; MAX232-&gt; 单片机UART/USART<br>COM/USB -&gt; CH340-&gt; 单片机UART/USART</p>
<p>需要注意的是,串口、UART/USART通常指的是硬件接口。</p>
<p>RS-232指的是属于物理层范畴的串行通信接口标准,RS-232就是个标准。<br>三种接口都是属于串口通信,主要有几个方面的区别。<br>1、通讯距离, RS232接口通讯距离为15米,而RS422/485最大通讯距离可以达到1200米。<br>2、所连设备数, RS232只能连接一个设备,而RS485可以同时连接多个设备。<br>3、端口定义, RS232为标准接口,一般为D型9针的DB9头,接口信号一般为标准默认的。而RS422/RS485为非标准接口,一般为15针串口接口(也可以做9针接口) ,每个设备的接口定义也不太一样, RS422一般为4线制全双工模式,而RS485为两线制,<strong>半双工模式</strong>。</p>
<table>
<thead>
<tr>
<th>SPI与IIC区别</th>
</tr>
</thead>
<tbody><tr>
<td>SPI 是同步串行接口，是一种高速、全双工的同步通信总线</td>
</tr>
<tr>
<td>IIC 是多主设备的总线 , 只有一根数据线，所以是半双工通信</td>
</tr>
<tr>
<td>1. SPI适合数据流应用，而IIC更适合“字节设备”的多主设备应用。</td>
</tr>
<tr>
<td>2. IIC 只需两根信号线，而标准SPI至少四根信号。</td>
</tr>
<tr>
<td>3. 数据吞吐/传输速度   SPI &gt; IIC 8M &gt; 400K</td>
</tr>
<tr>
<td>4、7位I2C总线可以挂接127个不同地址的I2C设备,0号”设备”作为群呼地址.</td>
</tr>
<tr>
<td>5、SPI接口的一个缺点：没有指定的流控制,没有应答机制确认是否接收到数据</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么说你了解过SPI</title>
    <url>/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/</url>
    <content><![CDATA[<p><strong>四线SPI</strong></p>
<p>①、CS/SS，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可。<br>②、SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。<br>③、MOSI/SDO，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线<br>只能用于主机向从机发送数据，也就是主机输出，从机输入。<br>④、MISO/SDI，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。<br>SPI 通信都是由主机发起的，主机需要提供通信的时钟信号。</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/spi.JPG" class="">

<p><em>_SPI 有四种工作模式</em></p>
<p>通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：<br>①、CPOL=0，串行时钟空闲状态为低电平。<br>②、CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具<br>体的传输协议。<br>③、CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。<br>④、CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。<br>    SPI 的时序图很简单，不像 I2C 那样还要分为读时序和写时序，因为 SPI 是全双工的，所以读写时序可以一起完成.</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/%E5%9B%9B%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.JPG" class="">


<p> <strong>时序图</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/%E6%97%B6%E5%BA%8F.JPG" class="">

<p> <strong>spi基本框架</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #ifndef _BSP_SPI_H</span><br><span class="line">#define _BSP_SPI_H</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line">&#x2F;* 函数声明 *&#x2F;</span><br><span class="line">void spi_init(ECSPI_Type *base);</span><br><span class="line">unsigned char spich0_readwrite_byte(ECSPI_Type *base, unsigned char txdata);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p> mpu9250传感器包括 3 轴加速度和 3 轴陀螺仪</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么说你了解过IIC</title>
    <url>/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/</url>
    <content><![CDATA[<p>8位IIC 最多连接127个器件。我们可以 2^8-最高位的广播(128)-1<br>IIC 速度能到达400K,接4.7k电阻</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/iic.JPG" class="">


<p><strong>起始位</strong></p>
<p>在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E8%B5%B7%E5%A7%8B%E4%BD%8D.JPG" class="">

<p><strong>停止位</strong></p>
<p>在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E5%81%9C%E6%AD%A2%E4%BD%8D.JPG" class="">

<p><strong>数据传输</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.JPG" class="">

<p><strong>应答信号</strong></p>
<p>应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p>



<p>通信不外乎两个操作：写和读</p>
<p><strong>I2C写时序</strong></p>


<p>1)、开始信号。<br>2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决<br>定访问哪个 I2C 器件。<br>3)、 高 7 位是设备地址,I2C 器件地址后面跟着一个读写位,为 0 表示写操作，为 1 表示读操作。<br>4)、从机发送的 ACK 应答信号。<br>5)、重新发送开始信号。<br>6)、发送要写写入数据的寄存器地址。<br>7)、从机发送的 ACK 应答信号。<br>8)、发送要写入寄存器的数据。<br>9)、从机发送的 ACK 应答信号。<br>10)、停止信号</p>
<p>注：先高位（MSB)后低位(LSB)？<br>通常，MSB位于二进制数的最左侧，LSB位于二进制数的最右侧。<br>首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。</p>
<p><strong>I2C读时序</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E8%AF%BB%E6%97%B6%E5%BA%8F.JPG" class="I2C">

<p>1)、主机发送起始信号。<br>2)、主机发送要读取的 I2C 从设备地址。<br>3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。<br>4)、从机发送的 ACK 应答信号。<br>5)、重新发送 START 信号。<br>6)、主机发送要读取的寄存器地址。<br>7)、从机发送的 ACK 应答信号。<br>8)、重新发送 START 信号。<br>9)、重新发送要读取的 I2C 从设备地址。<br>10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。<br>11)、从机发送的 ACK 应答信号。<br>12)、从 I2C 器件里面读取到的数据。<br>13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。<br>14)、主机发出 STOP 信号，停止 I2C 通信。</p>
<p><strong>基本I2C框架？</strong><br>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _BSP_I2C_H</span><br><span class="line">#define _BSP_I2C_H</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;* 相关宏定义 *&#x2F;</span><br><span class="line">#define I2C_STATUS_OK				(0)</span><br><span class="line">#define I2C_STATUS_BUSY				(1)</span><br><span class="line">#define I2C_STATUS_IDLE				(2)</span><br><span class="line">#define I2C_STATUS_NAK				(3)</span><br><span class="line">#define I2C_STATUS_ARBITRATIONLOST	(4)</span><br><span class="line">#define I2C_STATUS_TIMEOUT			(5)</span><br><span class="line">#define I2C_STATUS_ADDRNAK			(6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * I2C方向枚举类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">enum i2c_direction</span><br><span class="line">&#123;</span><br><span class="line">    kI2C_Write &#x3D; 0x0, 		&#x2F;* 主机向从机写数据 *&#x2F;</span><br><span class="line">    kI2C_Read &#x3D; 0x1,  		&#x2F;* 主机从从机读数据 *&#x2F;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 主机传输结构体</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_transfer</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char slaveAddress;      	&#x2F;* 7位从机地址 			*&#x2F;</span><br><span class="line">    enum i2c_direction direction; 		&#x2F;* 传输方向 			*&#x2F;</span><br><span class="line">    unsigned int subaddress;       		&#x2F;* 寄存器地址			*&#x2F;</span><br><span class="line">    unsigned char subaddressSize;    	&#x2F;* 寄存器地址长度 			*&#x2F;</span><br><span class="line">    unsigned char *volatile data;    	&#x2F;* 数据缓冲区 			*&#x2F;</span><br><span class="line">    volatile unsigned int dataSize;  	&#x2F;* 数据缓冲区长度 			*&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*函数集合*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_init(I2C_Type *base); &#x2F;*初始化*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_start(I2C_Type *base, unsigned char address, enum i2c_direction direction);&#x2F;*第一次start*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_repeated_start(I2C_Type *base, unsigned char address,  enum i2c_direction direction);&#x2F;*第二次start*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_check_and_clear_error(I2C_Type *base, unsigned int status);&#x2F;*检查并清除错误*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_stop(I2C_Type *base);&#x2F;*停止信号*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_master_write(I2C_Type *base, const unsigned char *buf, unsigned int size);&#x2F;*写*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_master_read(I2C_Type *base, unsigned char *buf, unsigned int size); &#x2F;*读*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_transfer(I2C_Type *base, struct i2c_transfer *xfer);&#x2F;*I2C数据传输，包括读和写*&#x2F;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>设备调用？</strong></p>
<p>AP3216:这颗芯片集成了光强传感器（ALS:AmbientLight Sensor），接近传感器（PS: Proximity Sensor），还有一个红外LED（IR LED）。这个芯片设计的用途是给手机之类的使用，比如：返回当前环境光强以便调整屏幕亮度；用户接听电话时，将手机放置在耳边后，自动关闭屏幕避免用户误触碰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _BSP_AP3216C_H</span><br><span class="line">#define _BSP_AP3216C_H</span><br><span class="line">&#x2F;***************************************************************</span><br><span class="line">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">文件名	: 	 bsp_ap3216c.h</span><br><span class="line">作者	   : 左忠凯</span><br><span class="line">版本	   : V1.0</span><br><span class="line">描述	   : AP3216C驱动头文件。</span><br><span class="line">其他	   : 无</span><br><span class="line">论坛 	   : www.wtmembed.com</span><br><span class="line">日志	   : 初版V1.0 2019&#x2F;3&#x2F;26 左忠凯创建</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line"></span><br><span class="line">#define AP3216C_ADDR    	0X1E	&#x2F;* AP3216C器件地址 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AP3316C寄存器 *&#x2F;</span><br><span class="line">#define AP3216C_SYSTEMCONG	0x00	&#x2F;* 配置寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_INTSTATUS	0X01	&#x2F;* 中断状态寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_INTCLEAR	0X02	&#x2F;* 中断清除寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_IRDATALOW	0x0A	&#x2F;* IR数据低字节 			*&#x2F;</span><br><span class="line">#define AP3216C_IRDATAHIGH	0x0B	&#x2F;* IR数据高字节 			*&#x2F;</span><br><span class="line">#define AP3216C_ALSDATALOW	0x0C	&#x2F;* ALS数据低字节 		*&#x2F;</span><br><span class="line">#define AP3216C_ALSDATAHIGH	0X0D	&#x2F;* ALS数据高字节			*&#x2F;</span><br><span class="line">#define AP3216C_PSDATALOW	0X0E	&#x2F;* PS数据低字节 			*&#x2F;</span><br><span class="line">#define AP3216C_PSDATAHIGH	0X0F	&#x2F;* PS数据高字节 			*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数声明 *&#x2F;</span><br><span class="line">unsigned char ap3216c_init(void);</span><br><span class="line">unsigned char ap3216c_readonebyte(unsigned char addr,unsigned char reg);</span><br><span class="line">&#x2F;*调用I2c读封装*&#x2F;</span><br><span class="line">unsigned char ap3216c_writeonebyte(unsigned char addr,unsigned char reg, unsigned char data);&#x2F;*调用I2c写封装*&#x2F;</span><br><span class="line">void ap3216c_readdata(unsigned short *ir, unsigned short *ps, unsigned short *als);&#x2F;*封装读和写数据*&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
















<p><em>_I2C读时序</em></p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql常见报错</title>
    <url>/MySql-Lover/MySql%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>外键约束报错？</p>
<p>SET foreign_key_checks = 0;<br>······<br>SET foreign_key_checks = 1;</p>
<p>update 修改报错？<br>这是因为MySql运行在safe-updates模式下，该模式会导致非主键条件下无法执行update或者delete命令，执行命令SET SQL_SAFE_UPDATES = 0;</p>
<p>限制执行完语句<br>DELIMITER $<br>····<br>$</p>
<p>referencing 在mysql中是不存在的，在mysql里面 等同的是NEW关键字 和OLD关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC_U(</span><br><span class="line">	Sno CHAR(9) NOT NULL,</span><br><span class="line">	Cno CHAR(4) NOT NULL,</span><br><span class="line">	Oldgrade SMALLINT,</span><br><span class="line">	Newgrade SMALLINT</span><br><span class="line">);</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE TRIGGER SC_T </span><br><span class="line">AFTER UPDATE  ON SC</span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">IF (NEW.Grade &gt;&#x3D; 1.1 * OLD.Grade)THEN</span><br><span class="line">	INSERT INTO SC_U(Sno,Cno,OldeGrade,NewGrade)</span><br><span class="line">    VALUES (OLD.Sno,OLD.Cno,OLD.Grade,NEW.Grade);</span><br><span class="line"> END IF;</span><br><span class="line"> END</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql+qt基本命令</title>
    <url>/MySql-Lover/mysql-qt%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>– 创建一个名称为info的数据库。</p>
<p>create database info;</p>
<p>– 删除数据库info</p>
<p>– drop database info;</p>
<p>– 使用数据库 info</p>
<p>use info;</p>
<p>– 创建表</p>
<p>– create table student(id int primary key auto_increment, name varchar(255), age int, score int);</p>
<p>create table student(id int primary key, name varchar(255), age int, score int);</p>
<p>– 删除student表</p>
<p>– drop table student;</p>
<p>– 插入数据</p>
<p>insert into student(id, name, age) values(1, ‘mike’, 18);</p>
<p>insert into student(id, name, age, score) values(2, ‘lucy’, 22, 90);</p>
<p>insert into student(id, name, age, score) values(3, ‘Tom’, 20, 78);</p>
<p>– 更新数据</p>
<p>update student set score = 90 where id = 3;</p>
<p>– 查找数据</p>
<p>select * from student;</p>
<p>select score from student where name = ‘mike’;</p>
<p>– 删除数据库</p>
<p>delete from student where name = ‘mike’;</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>原始套接字</title>
    <url>/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>对于一个自定义的IP包，或者一个ICMP协议包，又是如何实现传送的呢？<br>原始套接字就允许对这些较底层次的协议（IP、ICMP、IGMP）进行直接访问。</p>
<p><strong>原始套接字定义</strong></p>
<p>原始套接字编程是一种非面向连接的、C/S传输方式的网络编程，使用原始套接字编程进行服务器端与客户端的通信前，首先要创建各自的套接字，然后对相应的套接字进行数据传输，在数据传输过程中，需要使用sendto()函数和recvfrom()函数进行发送与接收，在发送与接收函数中设置相应的IP地址。</p>
<p>扩展：原始套接字往往应用于高级网络编程，如比较流行的网络嗅探器（sniffer）、拒绝服务攻击（DOS）、IP欺骗等等都可以实现，并且还可以通过原始套接字来模拟IP的一些实用工具，如Ping命令。</p>
<p>1.创建函数<br>，如TCP套接字编程选择的是SOCK_STREAM类型的套接字，UDP套接字编程选择的是SOCK_DGRAM类型的套接字，而原始套接字编程则需要选择SOCK_RAW类型的套接字。<br>上述代码创建了一个AF_INET协议族中的原始套接字，协议类型为protocol。<br>协议类型protocol通常设置0，可以取值还包括如下四种：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>IPPROTO_IP、IPPROTO_ICMP、IPPROTO_TCP、IPPROTO_UDP</td>
</tr>
</tbody></table>
<p>说明：创建完原始套接字后，可以通过向网络中定义自己的IP数据包，但是在Linux系统中，为了保护网络系统的安全，规定只有超级用户才有创建原始套接口的权限。</p>
<p>2.设置套接字选项<br>函数setsockopt()主要用于实现对套接字相关的选项设置当前值。</p>
<p>int setsockopt(int s, int  level,  int  optname,  const  void  *optval, socklen_t optlen);</p>
<p>|参数解释<br>|-|-|<br>|参数s表示套接字描述符；<br>|参数level代表的是选项定义的层次，如IPPROTO_IP；<br>|参数optname代表套接字选项的名称，例如IP_HDRINCL表示要构造IP头部；<br>|参数optval表示指向存放选项数据的缓冲区的指针；<br>|参数optlen表示optval参数指向的缓冲区的长度。</p>
<p>当使用套接字选项IP_HDRINCL设置套接字后，接收和发送数据的时候，接收到的数据包含IP数据的，包含IP的头部。用户之后需要对IP层相关的数据段进行处理，例如IP头部数据的设置和分析，校验和的计算等。设置方法如下：<br>int set = 1;<br>if(setsockopt(rawsock, IPPROTO_IP, IP_HDRINCL, &amp;set, sizeof(set))&lt;0)<br>{<br>/<em>错误信息提示</em>/<br>}</p>
<p><strong>了解报文</strong></p>
<img src="/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="报文结构">








]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/Linux-Lover/%E9%94%81/</url>
    <content><![CDATA[<p>产生死锁的必要条件是什么？解决死锁有几种方法？</p>
<p>安全状态与不安全状态：安全状态指系统能按某种进程顺序来为每个进程分配其所需资源，直 至最大需求，使每个进程都可顺利完成。若系统不存在这样一个， 则称系统处于不安全状态。</p>
<p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再 向前推进。<br>产生死锁的原因：（1）竞争系统资源 （2）进程的推进顺序不当<br>满足四个条件：</p>
<ol>
<li>互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</li>
<li>占有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；</li>
<li>不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</li>
<li>循环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</li>
</ol>
<p>解决死锁的基本方法：</p>
<p>预防死锁：<br>（1）资源一次性分配：（破坏请求和保持条件）<br>（2）可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）<br>（3）资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<p>避免死锁:最具有代表性的避免死锁算法是银行家算法。</p>
<p>解除死锁:<br>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
<p>检测死锁<br>有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:<br>1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来<br>2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求<br> 如果第二步返回真,表示出现了死锁</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/Linux-Lover/UDP/</url>
    <content><![CDATA[<p><strong>基于UDP的网络编程</strong></p>
<p>主要用到的函数有socket()、bind()、sendto()、recvfrom()和close()。<br>UDP是面向无连接的网络通信，并不需要像TCP套接字编程那样需要通过connect()与服务器建立连接，然后调用listen()函数使服务器处于监听状态，在通过accept()函数接收客户端的连接请求。</p>
<p>UDP套接字编程，只需要创建用于通信的套接字，然后在服务器端绑定端口，然后就可以实现数据的传输。<br>在绑定了地址信息之后，进行数据传输时，服务器会阻塞recvfrom()函数，等待客户端调用sendto()函数发送数据，同时客户端的recvfrom()被阻塞，然后，服务器会调用recvfrom()函数接收数据，接着向客户端作出应答，同时，服务端的recvfrom()被阻塞，接着，客户端调用recvfrom()接收数据。</p>
<p>1.发送数据、函数sendto()<br>ssize_t  sendto(int  s,  const  void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf用于指向发送信息的缓冲区的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len是发送的信息的长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>to</td>
<td>参数to为存放接收处的信息的指针</td>
</tr>
<tr>
<td>tolen</td>
<td>参数tolen是接收方地址的大小</td>
</tr>
</tbody></table>
<p>说明：如果sendto()函数用于面向连接的网络通信时，套接字类型为SOCK_STREAM或SOCK_SEQPACKET。此时参数to指向NULL，参数tolen为0，若不为此值，就会出现错误信息提示。</p>
<p>2.接收数据、函数recvfrom()</p>
<p>ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf指向接收信息的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len代表缓冲区的最大长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>from</td>
<td>参数from表示发送此信息处的地址指针</td>
</tr>
<tr>
<td>fromlen</td>
<td>参数fromlen指向发送处地址大小的指针。</td>
</tr>
</tbody></table>
<p>字节序转换函数 </p>
<p>    uint32_t htonl(uint32_t hostlong);<br>    uint16_t htons(uint16_t hostshort);<br>    uint32_t ntohl(uint32_t netlong);<br>    uint16_t ntohs(uint16_t netshort);<br>    说明：在上述的函数中，h代表host；<br>    n代表network s代表short；l代表long</p>
<p>地址转换函数 </p>
<p>    #include &lt;netinet/in.h&gt;<br>    #include &lt;arpa/inet.h&gt;<br>    int inet_aton(const char *cp, struct in_addr *inp);<br>    in_addr_t inet_addr(const char *cp);<br>    char *inet_ntoa(struct in_addr in);</p>
<p>serv.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*服务器端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in s_addr;	//服务器地址结构</span><br><span class="line">	struct sockaddr_in c_addr;	//客户端地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	socklen_t addr_len;		//地址结构长度</span><br><span class="line">	int len;			//接收到的消息字节数</span><br><span class="line">	char buff[128];			//存放接收消息的缓冲区</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/*清空地址结构*/</span><br><span class="line">	memset(&amp;s_addr, 0, sizeof(struct sockaddr_in));</span><br><span class="line">/* 设置地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET;</span><br><span class="line">	s_addr.sin_port = htons(PORT);</span><br><span class="line">	s_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">/* 绑定地址和端口信息 */</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">bind</span>(sock, (struct sockaddr *) &amp;s_addr, sizeof(s_addr))) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"bind error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind address to socket successfuly.\n\r"</span>);</span><br><span class="line">/* 循环接收数据 */</span><br><span class="line">	addr_len = sizeof(c_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		len = recvfrom(sock, buff, sizeof(buff) - 1, 0,(struct sockaddr *) &amp;c_addr, &amp;addr_len);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; 0) &#123;//接收失败</span><br><span class="line">			perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(errno);</span><br><span class="line">		&#125;</span><br><span class="line">		buff[len] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"收到来自远端计算机%s，端口号为%d的消息:\n%s\n\r"</span>,inet_ntoa(c_addr.sin_addr), ntohs(c_addr.sin_port), buff);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*客户端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;//定义变量</span><br><span class="line">	struct sockaddr_in s_addr;	//套接字地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	int addr_len;			//地址结构长度</span><br><span class="line">	int len;			//发送字节长度</span><br><span class="line">	char buff[]=<span class="string">"Hello everyone,Merry Christmas!"</span>;	//发送的消息</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/* 设置对方地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET; 	//地址族</span><br><span class="line"></span><br><span class="line">		s_addr.sin_port = htons(PORT);</span><br><span class="line">	<span class="keyword">if</span> (argv[1])</span><br><span class="line">		s_addr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"没有输入消息的接受者！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	addr_len = sizeof(s_addr);	//地址结构长度</span><br><span class="line">/*从客户端的buff缓冲区中发送消息到地址结构为s_addr的远端机器*/</span><br><span class="line">	len = sendto(sock, buff, sizeof(buff), 0,(struct sockaddr *) &amp;s_addr, addr_len);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; 0) &#123;			//如果发送失败</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\rsend error.\n\r"</span>);</span><br><span class="line">		<span class="built_in">return</span> 3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"send success.\n\r"</span>);	//发送成功</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/Linux-Lover/UDP/%E7%BB%93%E6%9E%9C.jpg" class="" title="结果">

]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/Linux-Lover/TCP/</url>
    <content><![CDATA[<p>__TCP三次握手，包头中的标志变化</p>
<img src="/Linux-Lover/TCP/TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class="" title="TCP3次握手">


<p>第一次握手：建立连接时，客户端发送 syn 包(tcp协议中syn位置1，序号为X)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p>
<p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN，同时自己也发送一个 SYN 包，即 SYN+ACK包（tcp协议中syn位置1，ack位置1，序号K，确定序号为X+1），此时服务器进入 SYN_RECV 状态；</p>
<p>第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(tcp协议中ack位置1，确认序号Y+1), 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手</p>
<img src="/Linux-Lover/TCP/%E5%8C%85.jpg" class="" title="TCP3次握手">

<p>seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。 </p>
<img src="/Linux-Lover/TCP/TCP.jpg" class="" title="accetp()一直阻塞到客户端连接">

<p>serv.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;netinet/in.h&gt;  // 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include&lt;arpa/inet.h&gt; // 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char sendbuf[256]=<span class="string">"ok"</span>;</span><br><span class="line">   char buf[256] ;</span><br><span class="line">   int s_fd,c_fd;// 服务器和客户套接字标识符</span><br><span class="line">   int s_len,c_len;// 服务器和客户消息长度</span><br><span class="line">   </span><br><span class="line">   struct sockaddr_in s_addr; // 服务器套接字地址</span><br><span class="line">   struct sockaddr_in c_addr;// 客户套接字地址</span><br><span class="line">   </span><br><span class="line">   s_fd = socket(AF_INET,SOCK_STREAM,0); //创建套接字</span><br><span class="line">   </span><br><span class="line">   s_addr.sin_family = AF_INET;//套接字的域</span><br><span class="line">   s_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">   s_addr.sin_port = PORT ;//定义服务器套接字端口</span><br><span class="line">   s_len = sizepf(s_addr);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">bind</span>(s_fd,(struct sockaddr *) &amp;s_addr,s_len);//绑定套接字 </span><br><span class="line">   </span><br><span class="line">   listen(s_fd,10); // 监听状态，守候进程,允许等待队列请求数10 </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"请稍后，等待客户端的发送数据\n"</span>);</span><br><span class="line">   </span><br><span class="line">   /*接收客户端请求*/</span><br><span class="line">   c_len = sizeof(c_addr);</span><br><span class="line">   c_fd = accetp(s_fd,(struct sockaddr*)&amp; c_addr,c_len); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">   &#123;</span><br><span class="line">    	<span class="keyword">if</span>(recv(c_fd,buf,256,0) &gt; 0) //收到客户   </span><br><span class="line">        &#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"收到客户端消息：\n %s\n"</span>,buf);</span><br><span class="line">         send(c_fd,sendbuf,sizeof(sendbuf),0);//回复客户</span><br><span class="line">   		 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	close(c_fd);// 关闭连接</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;		   // 包含套接字函数库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;			// 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;			// 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   int sockfd;								// 客户套接字标识符</span><br><span class="line">   int len;									// 客户消息长度</span><br><span class="line">   struct sockaddr_in addr;				// 客户套接字地址</span><br><span class="line">   int newsockfd;</span><br><span class="line">   char buf[256]=<span class="string">"come on!"</span>;//要发送的消息</span><br><span class="line">   int len2;							</span><br><span class="line">   char rebuf[256];  </span><br><span class="line">  </span><br><span class="line">	sockfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">   addr.sin_family = AF_INET;  // 客户端套接字地址中的域</span><br><span class="line">   addr.sin_addr.s_addr=htonl(INADDR_ANY);   </span><br><span class="line">   addr.sin_port = PORT;		// 客户端套接字端口</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   len = sizeof(addr);</span><br><span class="line">  	newsockfd = connect(sockfd,(struct sockaddr *)&amp;addr ,len);//发送连接服务器的请求</span><br><span class="line">  <span class="keyword">if</span> (newsockfd == -1)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">"连接诶失败\n"</span>);</span><br><span class="line">  <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">  len2 = sizeof(buf);</span><br><span class="line">  <span class="keyword">while</span>(1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要发送的数据:"</span>);</span><br><span class="line">    scanf(<span class="string">"%s"</span>,buf);</span><br><span class="line">    send(sockfd,buf,len2,0); //发送消息</span><br><span class="line">  <span class="keyword">if</span>(recv(sockfd,rebuf,256,0) &gt; 0)  //接收到</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"收到服务器消息:\n%s\n"</span>,rebuf);//输出到终端	</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  close(sockfd);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<img src="/Linux-Lover/TCP/%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="基本套接字">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>美的面试</title>
    <url>/My-interview-Lover/%E7%BE%8E%E7%9A%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>四大业务：数字化业务、消费者家电、空调业务、机器人自动化</p>
]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻式传感器</title>
    <url>/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>应变式 （丝式、箔式和薄膜式三种）</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%85%AC%E5%BC%8F.jpg" class="" title="应变式">

<p>要把电阻的变化转换为电压或电流的变化，需要转换电路来实现。转换电路常采用直流电桥或交流电桥。</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<p><strong>压阻式传感器是基于半导体材料的压阻效应来工作的传感器</strong></p>
<p>__分为半导体应变式压阻传感器 、扩散型压阻传感器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">与金属电阻应变片相比，半导体应变式具有：体积小、横向效应小、灵敏度高等特点。</span><br><span class="line">将P型杂质扩散到N型硅底层上，形成一层极薄的导电P型层，装上引线接点后，即形成扩散型半导体应变片。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>电阻式传感器应用</th>
</tr>
</thead>
<tbody><tr>
<td>（1）应变式测力与荷重传感器</td>
</tr>
<tr>
<td>（2）应变式压力传感器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32单片机</title>
    <url>/MCU-Lover/STM32%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>时钟系统</strong></p>
<p>晶体振荡器与RC振荡器</p>
<p>注意：RC振荡器成本低，但是受电阻电容温度影响较大。</p>
<img src="/MCU-Lover/STM32%E5%8D%95%E7%89%87%E6%9C%BA/clock.jpg" class="">


<p>四种时钟源</p>
<p>HSI:高速内部时钟，RC振荡器，频率8MHz</p>
<p>HSE:高速外部时钟，4-16MHz</p>
<p>LSI:低速内部时钟，RC振荡器，40Hz,独立看门狗或RTC</p>
<p>LSE:低速内部时钟，32.768Hz,RTC时钟源。</p>
<p>ABP：内核等<br>AHP：外设等</p>
<p><strong>SysTick 定时器</strong></p>
<p>系统嘀嗒校准值固定为9000，当系统嘀嗒时钟设定为9MHz(HCLK/8的最大值)，产生1ms时间基准。<br>滴答定时器，2^24次方，向下递减，为0中断重新赋值。</p>
<p><strong>中断</strong></p>
<p>16个可编程的优先等级(使用了4位中断优先级)；</p>
<p>进入中断<br>进入中断</p>
<p>入堆栈ISR<br>保存现场{PC,PSR,R0-R3,R12,ISR} ISR:当前中断服务寄存器<br>保存完后，ISR进入中断<br>晚来的中断可以ISR进入，不用重新保存现场。</p>
<p>退出中断<br>出栈恢复现场<br>也可以被打断进入新的中断。</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机</title>
    <url>/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机构造:</span><br><span class="line">40引脚双列直插DIP封装, PO, P1, P2, P3,其中P0不仅作为普通的1/0口使用,还可以作为地址/数据线使用【双向口】总共32个输入输出引脚, 2个电源接地, 2个管教接晶振,复位和控制4个: EA 【内外存储选择引脚,EA 为低电平,只访问外部程序存储器】</span><br><span class="line"></span><br><span class="line">工作方式:复位位方式【RST引脚输入高电平有效】,单步执行方式【通过外来脉冲控制,来一个脉冲执行一条指令,借助外部中断功能】,程序执行方式【主要方式,复位后PC指向地址0000H,从此执行复制导址方式:立即寻址,直接寻址,寄存器寻址,寄存器间接寻址,变址寻址,相对寻址,位寻址</span><br><span class="line"></span><br><span class="line">512字节RAM 8字节ROM（EEPROM）</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/51.jpg" class="" width="51">




<p>__晶体与晶振</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">晶体（crystal）也叫做无缘晶体。它是石英晶片，镀上电极，装在支架上，放在外壳里，就是石英晶体振荡器，简称晶体。常见的有两只脚。</span><br><span class="line">晶振（crystal oscillator）也叫做有源晶振。在晶体的基础上，再加上振荡、放大或者整形电路，然后封装到壳子里，就是晶振。常见的有四只脚。</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%99%B6%E4%BD%93%E4%B8%8E%E6%99%B6%E6%8C%AF.jpg" class="" title="晶体与晶振">


<p>常见问题 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、单片机中的程序计数器PC是16位的寻址范围是64KB怎么来的呀</span><br><span class="line">2 ^ 16，保存指示下一个指令地址</span><br><span class="line"></span><br><span class="line">2、三个周期</span><br><span class="line">时钟周期是单片机的基本时间单位。</span><br><span class="line">机器周期，它是CPU完成一个基本操作所需的时间。</span><br><span class="line">指令周期，是指CPU执行一条指令需要花费的时间。</span><br><span class="line">外接11.0592MHZ晶体，</span><br><span class="line">时钟周期=1/11.0592M</span><br><span class="line">机器周期=12/11.0592M ≈1.085us</span><br><span class="line">指令周期=1个，2个或4个机器周期</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习</title>
    <url>/shell-Lover/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>bash</strong><br>大多数Linux系统默认使用的shell，bash shell 是shell 的一个免费版本，它是最早的 Unix shell，bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。</p>
<p>注意：windows 下 powershell QAQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">编写：test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello world '</span></span><br><span class="line">运行 ./test.sh</span><br></pre></td></tr></table></figure>

<p><strong>定义</strong><br>shell是核心程序kernel之外的指令解析器，是一个程序，同时是一种命令语言和程序设计语言。</p>
<p>cat /etc/shells 看系统下的shell<br>echo $SHELL 看当前用户运行的shell</p>



<p>硬连接 ln  source_path target_path<br>软连接 ln -s source_path target_path</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	umask     文件      目录</span><br><span class="line">	0         6         7</span><br><span class="line">	1         5         6</span><br><span class="line">	2         4         5</span><br><span class="line">	3         3         4</span><br><span class="line">	4         2         3</span><br><span class="line">	5         1         2</span><br><span class="line">	6         0         1</span><br><span class="line">	7         0         0</span><br></pre></td></tr></table></figure>
<p><strong>基本概念及变量</strong></p>
<p>管道<br>把一个命令的输出作为另外一个命令的输入<br>ls -l| sort;  ls | sort<br>重定向  &lt; 输入   &gt;输出<br>///这个&gt;的实现原理，其实就是 open+close+dup<br>先使用 open 打开某个文件，然后利用 close 将文件描述符 1 关闭，就是把标准输出关闭，在利用 dup 将文件描述符 1 复制出来到某个文件即可)//<br>与管道相关，可以改变程序运行的输入来源和输出地点<br>sort&lt; myfile.txt    //sort 行进行排序<br>sort&lt;myfile.txt &gt;myfile+sort.txt</p>
<p>unset 清除变量<br>unset testvar  ; 测试 echo $testvar;//空行输出<br>readonly的变量，不能被清除</p>



<p>位置变量<br>位置变量表示$0 $1 $2 $3····<br>$0 代表bash文件名称 其他就是命令行参数</p>
<p>bash默认建立了一些标准环境变量，可在/etc/profile中定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	EXINIT 	定义一些vim的初始化参数</span><br><span class="line">	HOME 	echo $HOME</span><br><span class="line">	IFS		在linux系统中字符之间的间隔</span><br><span class="line">	测试echo $IFS </span><br><span class="line">	LOGNAME </span><br><span class="line">	测试 echo $LOGNAME set |grep “LOG”</span><br><span class="line">	MAIL当前登录用户，其邮箱在什么地方存储</span><br><span class="line">	MAILCHECK</span><br><span class="line">	MAILPATH</span><br><span class="line">	TERM	登录服务器，终端类型vt100</span><br><span class="line">	PATH标准变量	</span><br><span class="line">	可以使用set |grep “PATH”来查看path配置路径</span><br><span class="line">	当我们在shell运行一个程序时，shell会从path路径中查找程序。</span><br><span class="line">	TZ	时区</span><br><span class="line">	PS1 提示符 </span><br><span class="line">	echo $PS1</span><br><span class="line">	PS1&#x3D;’[\u@\h \w] \$’  u代表用户名 h主机名 w代表当前目录 </span><br><span class="line">	可以自己更改PS1 比如： PS1&#x3D;”wangbaoming”</span><br><span class="line">	PS2 “&gt; ”  大尖括号+空格 在一行上面运行多个命令 命令打不完 \</span><br><span class="line">	PWD</span><br><span class="line">	SHELL 我当前运行的shell时那个shell解析器</span><br><span class="line">	MANPATH</span><br><span class="line">	TERMINFO</span><br></pre></td></tr></table></figure>

<p>表达式类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$[ ] 表示形式告诉shell对方括号中的表达式求值</span><br><span class="line">eg: echo $[3+9] </span><br><span class="line"></span><br><span class="line">适应不同进制</span><br><span class="line">[base#n]	n表示基数从2到36任意基数</span><br><span class="line">ming@ubuntu:~$ echo $[10#8+191] </span><br><span class="line">199</span><br><span class="line">ming@ubuntu:~$ echo $[16#a+191] </span><br><span class="line">201</span><br></pre></td></tr></table></figure>

<p>shell输入与输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &#39;请输入需要创建的文件路径：&#39; filepath</span><br><span class="line">touch $filepath</span><br><span class="line">echo &#39;创建成功&#39;</span><br><span class="line">ls -l $filepath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一些运算</span><br><span class="line"></span><br><span class="line">-z    空串</span><br><span class="line">-n    非空串</span><br><span class="line">-eq         数值相等。</span><br><span class="line">-ne         数值不相等。</span><br><span class="line">-gt         第一个数大于第二个数。</span><br><span class="line">-lt          第一个数小于第二个数。</span><br><span class="line">-le         第一个数小于等于第二个数。</span><br><span class="line">-ge         第一个数大于等于第二个数。</span><br><span class="line">加法运算：expr 10 + 10</span><br><span class="line">减法运算：expr 20 - 10</span><br><span class="line">加法运算：expr 10 &#x2F; 5</span><br><span class="line">乘法运算：expr 10 \* 5</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL语言</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>很棒的一个链接：<a href="https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql" target="_blank" rel="noopener">https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql</a><br>不会就打开看看QvQ</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>1、<strong>数据库由几个部分组成，这个结构有什么好处。</strong><br>答:①数据库、数据库管理系统（及其开发工具）、数据库管理员、应用系统。<br>三级模式:模式、外模式、内模式<br>两层映像结构:外模式模式映像,模式内模式映像<br>好处：保证了数据与程序的逻辑独立性和物理独立性</p>
<p>2、<strong>数据模型</strong></p>
<p>概念模型：实体、属性、码、实体型、实体集、联系</p>
<p>数据模型由数据结构、数据操纵、数据约束规则三个部分组成。</p>
<p>3、<strong>常见模型</strong><br>层次模型：<br>网状模型：<br>（重点）关系模型：<br>面向对象模型：<br>对象关系模型：<br>半结构化模型：</p>
<p>重点：<br>关系模型数据结构:二维表（关系、元组（行）、属性（列）码、域、分组、关系模式）<br>关系模型数据操纵:插入、删除、更新、查询。<br>关系模型数据完整性约束规则:实体完整性、参照完整性、用户自定义完整性。</p>
<p>4、<strong>关系模型</strong></p>
<p>（1）关系：域、笛卡尔积、关系..<br>扩展：<br>候选码(Candidate Key)：一个或者多个属性的集合，可以唯一确定实体的一个实例；<br>主码(Primary Key):从候选码中，选中用来作为唯一标识的属性或者属性组被称为主码；<br>可选码(Alternative Key):候选码中没有选中的其他码，称为可选码；</p>
<p>（2）关系操作：查询分一类，插入、删除、修改一类</p>
<p>关系数据库语言：关系代数与关系演算(SQL 两者的结合)<br>（3）关系代数</p>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.jpg" class="" title="关系代数">

<p>专门关系运算：选择、投射、连接、除运算。</p>


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%96%E8%BF%9E%E6%8E%A5.jpg" class="" title="外连接是自然连接">

<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E9%99%A4%E6%B3%95.jpg" class="" title="除运算">

<p>（4）关系演算（*）</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>微波传感器</title>
    <url>/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<h5 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h5><p>微波是0.1m-1m的电磁波，波长相对较长的电磁波。对应的波段频率范围为300 MHz～3000 GHz。 </p>
<h5 id="微波特点"><a href="#微波特点" class="headerlink" title="微波特点"></a>微波特点</h5><p>(1)似光性和似声性<br>(2)分析方法的独特性<br>低频电路不适用<br>(3)共度性<br>电子在真空管内的渡越时间（10-9秒左右）与微波的振荡周期（ 10-9 ～10-15秒）相当的这一特性称共度性，利用该特性可以做成各种微波电真空器件，得到微波振荡源。<br>(4)穿透性<br>(5)信息性<br>(6)非电离性</p>
<h5 id="微波传感器"><a href="#微波传感器" class="headerlink" title="微波传感器"></a>微波传感器</h5><p><strong>原理</strong><br>微波传感器是利用微波特性来检测某些物理量的器件或装置。由发射天线发出微波，此波遇到被测物体时将被吸收或反射，使微波功率发生变化。若利用接收天线，接收到通过被测物体或由被测物体反射回来的微波，并将它转换为电信号，再经过信号调理电路，即可以显示出被测量，实现了微波检测。<br><strong>分类</strong><br>根据微波传感器的原理，微波传感器可以分为反射式和遮断式两类。<br><strong>组成</strong><br>微波传感器通常由微波发射器（即微波振荡器）、 微波天线及微波检测器三部分组成。<br><strong>微波振荡器</strong> 的器件有调速管、磁控管或某些固态器件，小型微波振荡器也可以采用体效应管<br><strong>微波天线</strong> 为了使发射的微波具有尖锐的方向性，天线要具有特殊的结构。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E5%A4%A9%E7%BA%BF.jpg" class="" title="微波天线">
<p><strong>微波检测器</strong><br>一种是将微波变化为电流的视频变化方式<br>一种是与本机振荡器并用而变化为频率比微波低的外差法。（差分方式）</p>
<h5 id="微波传感器应用"><a href="#微波传感器应用" class="headerlink" title="微波传感器应用"></a>微波传感器应用</h5><p><strong>微波液位计</strong></p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E4%BE%A7%E4%BD%8D%E8%AE%A1.jpg" class="" title="微波侧位计">

<p><strong>微波湿度传感器</strong></p>
<p>扩展：<br>一般干燥的物体，如木材、皮革、谷物、 纸张、 塑料等，其ε′在1～5范围内， 而水的ε′则高达64， 因此如果材料中含有少量水分子时，其复合ε′将显著上升， ε″也有类似性质。 使用微波传感器，测量干燥物体与含一定水分的潮湿物体所引起的微波信号的相移与衰减量， 就可以换算出物体的含水量。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="微波湿度传感器">

<p><strong>微波测厚仪</strong><br>利用微波在传播过程中遇到被测物体金属表面被反射，且反射波的波长与速度都不变的特性进行测厚的。<br>基本原理：<br>（1）在被测金属物体上下两表面各安装一个终端器。微波信号源发出的微波，经过环行器A、 上传输波导管传输到上终端器，由上终端器发射到被测物体上表面上，微波在被测物体上表面全反射后又回到上终端器，再经过传输导管、环行器A、下传输波导管传输到下终端器。</p>
<p>（2）由下终端器发射到被测物体下表面的微波，经全反射后又回到下终端<br>器，再经过传输导管回到环行器A。因此被测物体的厚度与微波传输过<br>程中的行程长度有密切关系，当被测物体厚度增加时，微波传输的行程<br>长度便减小。 </p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B5%8B%E5%8E%9A%E4%BB%AA.jpg" class="" title="微波测厚仪">


<p><strong>微波辐射计（温度传感器）</strong>(*)</p>
<p><strong>微波测定移动物体的速度和距离</strong>(*)</p>
<p><strong>微波无损检测</strong>(*)</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程了解</title>
    <url>/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>1)socket可以看成是用户进程与内核网络协议栈的编程接口。<br>1)socket不仅可以用于本机的进程间通信，还可以用于网络上不同主机的进程间通信。</p>
<img src="/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/1.jpg" class="">

<h5 id="大端、小端"><a href="#大端、小端" class="headerlink" title="大端、小端"></a>大端、小端</h5><p>0x 12 34 56 78<br>低字节78放高位地址，大端；高字节12放低位位地址<br>低字节78放低位地址，小端；高字节12放高位地址</p>
<p>大端：0x12345678<br>小端：0x87654321<br>#include <iostream><br>using namespace std;<br>int main ()<br>{<br>int i =0x12345678 ;<br>if (<em>(char</em>)&amp;i == 0x12) //地址转化再访问<br>{<br>cout &lt;&lt; “大端” &lt;&lt;endl;<br>}<br>else<br>{<br>cout &lt;&lt; “小端” &lt;&lt;endl;<br>}<br>}</p>
<h5 id="Socket-API基本用法"><a href="#Socket-API基本用法" class="headerlink" title="Socket API基本用法"></a>Socket API基本用法</h5><p>#include &lt;sys/socket.h&gt;</p>
<p><strong>socket函数</strong></p>
<p>int socket(int domain, int type, int protocol);<br>创建一个套接字用于通信</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>domain</td>
<td>指定通信协议族（protocol family）</td>
<td>AF_INET</td>
</tr>
<tr>
<td>type</td>
<td>指定socket类型</td>
<td>流式套接字SOCK_STREAM，数据报套接字SOCK_DGRAM，原始套接字SOCK_RAW</td>
</tr>
<tr>
<td>protocol</td>
<td>协议类型</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>bind函数</strong></p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>绑定一个本地地址到套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要绑定的地址</td>
</tr>
<tr>
<td>len</td>
<td>地址长度</td>
</tr>
</tbody></table>
<p><strong>listen函数</strong></p>
<p>一般来说，listen函数应该在调用socket和bind函数之后，调用函数accept之前调用。<br>int listen(int sockfd, int backlog);<br>参数sockfd 是socket()函数返回的套接字描述符；<br>参数backlog指定在请求队列中允许的最大请求数，</p>
<p>对于给定的监听套接口，内核要维护两个队列：<br>1、已由客户发出并到达服务器，服务器正在等待完成相应的TCP三路握手过程<br>2、已完成连接的队列</p>
<p><strong>accept函数</strong></p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<br>从已完成连接队列返回第一个连接，如果已完成连接队列为空，则阻塞。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>将返回对等方的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>返回对等方的套接字地址长度</td>
</tr>
</tbody></table>
<p><strong>connect函数</strong></p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>建立一个连接至addr所指定的套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>未连接套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要连接的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>地址长度</td>
</tr>
</tbody></table>
<h5 id="Socket-API地址复用"><a href="#Socket-API地址复用" class="headerlink" title="Socket API地址复用"></a>Socket API地址复用</h5><p>SO_REUSEADDR：服务器端尽可能使用SO_REUSEADDR，在绑定之前尽可能调用setsockopt来设置SO_REUSEADDR套接字选项。</p>
<p>作用：使用SO_REUSEADDR选项可以使得不必等待TIME_WAIT状态消失就可以重启服务器</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int optval = 1;</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setsockopt bind\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Socket多客户端连接"><a href="#Socket多客户端连接" class="headerlink" title="Socket多客户端连接"></a>Socket多客户端连接</h5>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/Linux-Lover/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h5 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">中断分类</span><br><span class="line">	硬件中断（外部中断）</span><br><span class="line">	外部中断是指由外部设备通过硬件请求的方式产生的中断，也称为硬件中断</span><br><span class="line">	软件中断（内部中断）</span><br><span class="line">	内部中断是由CPU运行程序错误或执行内部程序调用引起的一种中断，也称为软件中断。</span><br></pre></td></tr></table></figure>
<h5 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号是UNIX系统响应某些状况而产生的事件，进程在接收到信号时会采取相应的行动。</span><br><span class="line">信号是因为某些错误条件而产生的，比如内存段冲突、浮点处理器错误或者非法指令等</span><br><span class="line">信号是在软件层次上对中断的一种模拟，所以通常把它称为是软中断</span><br></pre></td></tr></table></figure>
<h5 id="信号和中断的区别"><a href="#信号和中断的区别" class="headerlink" title="信号和中断的区别"></a>信号和中断的区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号与中断的相似点：</span><br><span class="line">（1）采用了相同的异步通信方式；</span><br><span class="line">（2）当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序；</span><br><span class="line">（3）都在处理完毕后返回到原来的断点；</span><br><span class="line">（4）对信号或中断都可进行屏蔽。</span><br><span class="line">信号与中断的区别：</span><br><span class="line">（1）中断有优先级，而信号没有优先级，所有的信号都是平等的；</span><br><span class="line">（2）信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行；</span><br><span class="line">（3）中断响应是及时的，而信号响应通常都有较大的时间延迟。</span><br></pre></td></tr></table></figure>
<h5 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIGABRT	进程停止运行 6</span><br><span class="line">SIGHUP	系统挂断</span><br><span class="line">SIGINT	终端中断  2</span><br><span class="line">SIGPIPE	向没有读者的管道写入数据</span><br><span class="line">SIGQUIT	终端退出   3</span><br><span class="line">SIGTERM	终止 </span><br><span class="line">SIGUSR1	用户定义信号1</span><br><span class="line">SIGUSR2	用户定义信号2</span><br><span class="line">SIGCHLD	子进程已经停止或退出  </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h4 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)忽略信号  </span><br><span class="line">	不采取任何操作、有两个信号不能被忽略：SIGKILL（9号信号）和SIGSTOP。如果应用程序可以忽略这2个信号，系统管理无法杀死、暂停进程，无法对系统进行管理。）。SIGKILL（9号信号）和SIGSTOP信号是不能被捕获的。</span><br><span class="line">2)捕获并处理信号   </span><br><span class="line">	内核中断正在执行的代码，转去执行先前注册过的处理程序。</span><br><span class="line">3)执行默认操作   </span><br><span class="line">	默认操作通常是终止进程，这取决于被发送的信号。</span><br></pre></td></tr></table></figure>

<h5 id="了解常见信号signal函数"><a href="#了解常见信号signal函数" class="headerlink" title="了解常见信号signal函数"></a>了解常见信号signal函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIG_IGN	屏蔽该信号</span><br><span class="line"> signal(2,SIG_IGN);</span><br><span class="line"> //ctrl+c 被屏蔽</span><br><span class="line">SIG_DFL	恢复默认行为</span><br><span class="line"> signal(2,SIG_DFL);</span><br></pre></td></tr></table></figure>
<h5 id="信号发送函数"><a href="#信号发送函数" class="headerlink" title="信号发送函数"></a>信号发送函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）int <span class="built_in">kill</span>(pid_t pid, int siq)</span><br><span class="line">	pid&gt;0 将信号sig发给pid进程</span><br><span class="line">	pid=0 将信号sig发给同组进程</span><br><span class="line">	pid=-1 将信号sig发送给所有进程，调用者进程有权限发送的每一个进程（除了1号、自身）</span><br><span class="line">	pid&lt;-1 将信号sig发送给进程组是pid（绝对值）的每一个进程</span><br><span class="line">    </span><br><span class="line">（2）raise(sig)等价于<span class="built_in">kill</span>(getpid(), sig);</span><br><span class="line"></span><br><span class="line">（3）killpg(pgrp, sig)等价于<span class="built_in">kill</span>(-pgrp, sig);</span><br><span class="line"></span><br><span class="line">（4）pause()函数将进程置为可中断睡眠状态。然后它调用内核函数schedule()，使linux进程调度器找到另一个进程来运行。调用者进程挂起，直到一个信号被捕获</span><br><span class="line"></span><br><span class="line">（5）alarm函数，设置一个闹钟延迟发送信号告诉linux内核n秒中以后，发送SIGALRM信号//alarm(1)</span><br><span class="line"></span><br><span class="line">搭配使用：	</span><br><span class="line">void  myhandle(int num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"recv signal id num : %d \n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGALRM, myhandle) == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"func signal err\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">alarm(1);//调用myhandle</span><br></pre></td></tr></table></figure>
<h5 id="可睡眠中断与不可睡眠中断"><a href="#可睡眠中断与不可睡眠中断" class="headerlink" title="可睡眠中断与不可睡眠中断"></a>可睡眠中断与不可睡眠中断</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sleep(100);//可以中断睡眠，内核让进程睡眠，可以被别的信号唤醒，继续往下运行。</span><br><span class="line">要不可中断睡眠，醒来继续运行sleep。根据sleep会返回剩余秒数。</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">  n = sleep (100);</span><br><span class="line">&#125;<span class="keyword">while</span>(n &gt; 0)；</span><br><span class="line">醒来继续睡。。。</span><br><span class="line">pause();//可中断睡眠</span><br></pre></td></tr></table></figure>
<h5 id="不可重入与可重入函数"><a href="#不可重入与可重入函数" class="headerlink" title="不可重入与可重入函数"></a>不可重入与可重入函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可重入函数每次可能调用效果不一样。</span><br><span class="line">全局变量、mallco函数调用（重新覆盖很恐怖）。</span><br><span class="line"></span><br><span class="line">所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</span><br><span class="line"></span><br><span class="line">启示：尽量不使用全局变量和静态变量的函数。特别是这个变量在程序中随时读写。</span><br></pre></td></tr></table></figure>

<h5 id="信号阻塞、未决、忽略"><a href="#信号阻塞、未决、忽略" class="headerlink" title="信号阻塞、未决、忽略"></a>信号阻塞、未决、忽略</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号屏蔽状态字（block）、信号未决状态字（pending）、忽略标志。</span><br><span class="line">注：阻塞和忽略是不同，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">向进程发送SIGINT，内核首先判断信号屏蔽状态字是否阻塞，信号未决状态字（pending相应位制成1；若阻塞解除，信号未决状态字（pending）相应位制成0；表示信号可以抵达了。</span><br><span class="line">block状态字、pending状态字 64bit；</span><br><span class="line">block状态字用户可以读写，pending状态字用户只能读；这是信号设计机制。</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E4%BF%A1%E5%8F%B7/1.jpg" class="" title="来源：linux编程王保明">


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigset_t pset; //用来打印的信号集</span><br><span class="line">sigset_t bset; //用来设置阻塞的信号集</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;bset);</span><br><span class="line">sigaddset(&amp;bset, SIGINT);</span><br><span class="line"></span><br><span class="line">sigprocmask()读取或更改进程的信号屏蔽状态（block） </span><br><span class="line">eg:</span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;bsetbset,NUU);//阻塞</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;bset,NULL);//解除阻塞</span><br><span class="line">sigpending(&amp;pset);//获取未决字信息</span><br></pre></td></tr></table></figure>

<h5 id="可靠信号、不可靠信号"><a href="#可靠信号、不可靠信号" class="headerlink" title="可靠信号、不可靠信号"></a>可靠信号、不可靠信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可靠信号</span><br><span class="line">unix系统，进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理</span><br><span class="line">可靠信号</span><br><span class="line">linux优化，信号的发送和安装也出现了新版本：信号发送函数sigqueue()及信号安装函数sigaction()</span><br><span class="line">扩展：</span><br><span class="line">非实时信号都不支持排队，都是不可靠信号</span><br><span class="line">实时信号都支持排队，都是可靠信号</span><br></pre></td></tr></table></figure>
<h5 id="信号的高级用法"><a href="#信号的高级用法" class="headerlink" title="信号的高级用法"></a>信号的高级用法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigaction函数注册信号处理函数</span><br><span class="line"></span><br><span class="line">sigqueue新的信号发送函数</span><br><span class="line">原型:int sigqueue(pid_t pid, int sig, const union sigval value);</span><br><span class="line"></span><br><span class="line">和<span class="built_in">kill</span>函数相比Int <span class="built_in">kill</span>(pid_t pid, int siq)多了参数</span><br><span class="line">但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解守护进程</title>
    <url>/Linux-Lover/%E8%A7%A3%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">守护进程是在后台运行不受控端控制的进程，通常情况下守护进程在系统启动时自动运行。</span><br><span class="line">守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</span><br></pre></td></tr></table></figure>
<h5 id="了解会话期"><a href="#了解会话期" class="headerlink" title="了解会话期"></a>了解会话期</h5> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 远程登录服务器，登录成功之后，linux服务器和终端之间建立一个会话期，会话期默认启动shell程序。</span><br><span class="line">注：</span><br><span class="line">shell是进程组， ps -ef | grep xx 也是进程组。。。都在终端中，如果想脱离终端，必须建立子进程代替父进程，该子进程为未来守护进程，调用setsid创建新的会话期。</span><br></pre></td></tr></table></figure>
<h5 id="手动创建守护进程步骤"><a href="#手动创建守护进程步骤" class="headerlink" title="手动创建守护进程步骤"></a>手动创建守护进程步骤</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)调用fork(),创建新进程，它会是将来的守护进程</span><br><span class="line">2)在父进程中调用<span class="built_in">exit</span>，保证子进程不是进程组组长</span><br><span class="line">3)调用setsid创建新的会话期</span><br><span class="line">4)将当前目录改为根目录 （如果把当前目录作为守护进程的目录，当前目录不能被卸载，它作为守护进程的工作目录了。</span><br><span class="line">5）将标准输入、标准输出、标准错误重定向到/dev/null</span><br></pre></td></tr></table></figure>
<h5 id="调用api创建守护进程"><a href="#调用api创建守护进程" class="headerlink" title="调用api创建守护进程"></a>调用api创建守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line">nochdir：=0将当前目录更改至“/”</span><br><span class="line">noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”</span><br><span class="line">例子:</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">int setup_daemon(int nochdir, int noclose);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    mydaemon(1, 1);</span><br><span class="line">    //man daemon 可以看到</span><br><span class="line">    //0表示改变重定向   1表示不改变</span><br><span class="line">    //daemon(1, 1);  //调用函数</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test ...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) ;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mydaemon(int nochdir, int noclose) //自建函数</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == -1)</span><br><span class="line">        ERR_EXIT(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; 0)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    setsid();</span><br><span class="line">    <span class="keyword">if</span> (nochdir == 0)</span><br><span class="line">        <span class="built_in">chdir</span>(<span class="string">"/"</span>);//系统调用函数改变当前路径 </span><br><span class="line">		<span class="keyword">if</span> (noclose == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        <span class="keyword">for</span> (i=0; i&lt;3; ++i)</span><br><span class="line">            close(i);</span><br><span class="line">        open(<span class="string">"/dev/null"</span>, O_RDWR);  </span><br><span class="line">        dup(0); //标准输出 也指向/dev/null  //    dup2(0, 1);</span><br><span class="line">        dup(0); //标准错误输出，也指向/dev/null //    dup2(0, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>来源：Linux应用编程王保明</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程概念</title>
    <url>/Linux-Lover/%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程是操作系统分配的内存、CPU时间片等资源的基本单位,是资源分配的最小单位(线程是CPU执行单位)。</span><br><span class="line">进程是操作系统对资源的一种抽象，一个进程由三部分组成:</span><br><span class="line">1）进程控制块PCB：用于描述进程情况及控制进程运行所需的全部信息。</span><br><span class="line">2）代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</span><br><span class="line">3）数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</span><br><span class="line">分式操作系统 </span><br><span class="line">基于时间片轮转，每一个进程有自己的地址空间和执行状态。</span><br></pre></td></tr></table></figure>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作系统经典三态:就绪	等待、（阻塞）、运行等</span><br><span class="line">还有其他挂起、僵尸进程等。。。</span><br><span class="line">Linux内核中的进程状态：</span><br><span class="line">▽	运行状态</span><br><span class="line">▽	可中断睡眠状态7</span><br><span class="line">▽	不可中断睡眠状态</span><br><span class="line">▽	暂停状态</span><br><span class="line">▽	僵死状态</span><br></pre></td></tr></table></figure>
<h5 id="进程调度及调度算法"><a href="#进程调度及调度算法" class="headerlink" title="进程调度及调度算法"></a>进程调度及调度算法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先来先服务调度算法</span><br><span class="line">短进程优先调度算法</span><br><span class="line">高优先级优先调度算法</span><br><span class="line">时间片轮转法（公平）</span><br></pre></td></tr></table></figure>

<h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程描述信息（进程标识符）</span><br><span class="line">进程控制信息（进程当前状态等）</span><br><span class="line">资源信息（I/O设备号、缓冲、内存等）</span><br><span class="line">现场保护信息（寄存器、PC、PSW、栈指针）</span><br></pre></td></tr></table></figure>
<h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、分配一个内部标识，在内核中建立进程结构.</span><br><span class="line">复制父进程的环境。</span><br><span class="line">2、为进程分配资源，包括所有元素（程序、数据、用户栈等，复制父进程地址空间的内容到该进程地址空间中。</span><br><span class="line">3、置该进程的状态为就绪，插入就绪队列。</span><br></pre></td></tr></table></figure>
<h5 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关闭软中断:因为进程即将终止而不再处理任何软中断信号；</span><br><span class="line">回收资源：释放进程分配的所有资源，如关闭所有已打开文件，释放进程相应的数据结构等；</span><br><span class="line">写记帐信息：将进程在运行过程中所产生的记帐数据（其中包括进程运行时的各种统计信息）记录到一个全局记帐文件中；</span><br><span class="line">置该进程为僵死状态:向父进程发送子进程死的软中断信号，将终止信息status送到指定的存储单元中；</span><br><span class="line">转进程调度:因为此时CPU已经被释放，需要由进程调度进行CPU再分配。</span><br></pre></td></tr></table></figure>
<h5 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">避免僵尸进程</span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line">signal(SIGCHLD, SIG_IGN);//子进程信号，忽略</span><br></pre></td></tr></table></figure>

<h5 id="1：n-的机制"><a href="#1：n-的机制" class="headerlink" title="1：n 的机制"></a>1：n 的机制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、从子进程获得父进程id容易。</span><br><span class="line">2、把子进程id返回给父进程，以便控制</span><br></pre></td></tr></table></figure>
<p>创建多个子进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;string.h&gt;</span><br><span class="line"> #include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line"> #include &lt;sys&#x2F;sem.h&gt;</span><br><span class="line"> #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"> #include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;    </span><br><span class="line">    int i; </span><br><span class="line">    int num &#x3D; 3 ; </span><br><span class="line">    for(i&#x3D;0;i&lt;num;i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        pid&#x3D;fork();    </span><br><span class="line">        if(pid&#x3D;&#x3D;0||pid&#x3D;&#x3D;-1)  &#x2F;&#x2F;子进程或创建进程失败均退出,这里是关键所在  </span><br><span class="line">        &#123;    </span><br><span class="line">            break;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    if(pid&#x3D;&#x3D;-1)    </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(&quot;fail to fork!\n&quot;);    </span><br><span class="line">        exit(1);    </span><br><span class="line">    &#125;    </span><br><span class="line">    else if(pid&#x3D;&#x3D;0 || i &#x3D;&#x3D; 0)    </span><br><span class="line">    &#123;    </span><br><span class="line">        printf(&quot;子进程id&#x3D;%d,其对应的父进程id&#x3D;%d\n&quot;,getpid(),getppid());    </span><br><span class="line">        exit(0);    </span><br><span class="line">    &#125;    </span><br><span class="line"> else if(pid&#x3D;&#x3D;0 || i &#x3D;&#x3D; 1)    </span><br><span class="line">    &#123;    </span><br><span class="line">        printf(&quot;子进程id&#x3D;%d,其对应的父进程id&#x3D;%d\n&quot;,getpid(),getppid());    </span><br><span class="line">        exit(0);    </span><br><span class="line">    &#125;  </span><br><span class="line">     else if(pid&#x3D;&#x3D;0 || i &#x3D;&#x3D; 2)    </span><br><span class="line"></span><br><span class="line">    &#123;    </span><br><span class="line">        printf(&quot;子进程id&#x3D;%d,其对应的父进程id&#x3D;%d\n&quot;,getpid(),getppid());    </span><br><span class="line"></span><br><span class="line">        exit(0);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">    &#123;    </span><br><span class="line">        printf(&quot;父进程id&#x3D;%d\n&quot;,getpid());    </span><br><span class="line">        exit(0);    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个指定，建议用高级信号的写法<br>sigaction、signalqueue<br>把pidpid_Array[i] = pid = fork();</p>
<p>rk();</p>
<p> fork();</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程获取标识</title>
    <url>/Linux-Lover/%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程ID</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"UID=%ld\n"</span>,(long)getuid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"EUID=%ld\n"</span>,(long)geteuid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">用户ID  创建者信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int flag1,flag2;</span><br><span class="line">flag1=setuid(0);</span><br><span class="line">flag2=setgid(500);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag1=%d\n,flag2=%d\n"</span>,flag1,flag2);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">用户组ID  用户组信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"group ID=%d\n"</span>,(long)getgid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"effective group ID=%d\n"</span>,(long)getegid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/Linux-Lover/%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>什么是线程</strong></p>
<p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”<br>一切进程至少都有一个执行线程  </p>
<p><strong>进程与线程</strong></p>
<p>进程是资源竞争的基本单位<br>线程是程序执行的最小单位<br>线程共享进程数据，但也拥有自己的一部分数据<br>    线程ID<br>    程序计数器<br>    寄存器组<br>    栈<br>    errno</p>
<p>一个进程内部的线程可以共享资源<br>    代码段<br>    数据段<br>    打开文件和信号</p>
<p>fork和创建新线程的区别<br>    当一个进程执行一个fork调用的时候，会创建出进程的一个新拷贝，新进程将拥有它自己的变量和它自己的PID。这个新进程的运行时间是独立的，它在执行时几乎完全独立于创建它的进程<br>    在进程里面创建一个新线程的时候，新的执行线程会拥有自己的堆栈（因此也就有自己的局部变量），但要与它的创建者共享全局变量、文件描述符、信号处理器和当前的工作目录状态</p>
<p>pthread_create函数<br>    功能：创建一个新的线程<br>pthread_exit函数<br>    功能：线程终止<br>pthread_join函数<br>    功能：等待线程结束<br>pthread_cancel函数<br>    功能：取消一个执行中的线程</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>void *</title>
    <url>/C-C-Lover/id/</url>
    <content><![CDATA[<p>C语言中void *为不确定类型指针.</p>
<p>void* 可以用来声明指针。<br>例如: void <em>a;<br>(1) void</em>可以接受任何的t值:void *a= NULL；<br>   int  *b=NULL；<br>   a= b; 任何类型的指针都可以直接赋值给它,无需进行强制类型转换</p>
<p>(2) void<em>可以赋值给任何类型的变量但是需要进行强制转换:<br>例如：int a = NULL;void*b;a = (int</em>) b:</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件IO</title>
    <url>/Linux-Lover/%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="典型产品开发过程"><a href="#典型产品开发过程" class="headerlink" title="典型产品开发过程"></a>典型产品开发过程</h5><p>1、让 Linux 系统在硬件上跑起来（系统移植工作）<br>2、基于 Linux 系统来开发应用程序实现产品功能（应用编程属于这一步骤）<br>基于 Linux 做应用编程其实就是调用 API 来实现应用需要完成的一些任务。</p>
<h5 id="文件自身信息"><a href="#文件自身信息" class="headerlink" title="文件自身信息"></a>文件自身信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//索引节点所包含信息存在结构体<span class="built_in">stat</span></span><br><span class="line">struct <span class="built_in">stat</span></span><br><span class="line">&#123;</span><br><span class="line">dev_t stdev; /*文件使用设备号*/</span><br><span class="line">ino_t st_ino;  /*索引节点*/</span><br><span class="line">mode_t st_mode; /*访问模式*/</span><br><span class="line">nlink_t st_nlink;/*硬链接*/</span><br><span class="line">uidt st_uid; /*所有者用户ID*/</span><br><span class="line">gid_t st_gid; /*用户组ID*/</span><br><span class="line">dev_t st_rdev;/*设备文件设备号 */</span><br><span class="line">off_t st_size; /*文件大小 字节单位/</span><br><span class="line">blksize_t st_blksize; /*系统磁盘块大小*/</span><br><span class="line">blkcnt_t st blocks; /*文件磁盘块大小*/</span><br><span class="line">time_t st_atime; /*最后一次访问时间*/</span><br><span class="line">time_t st_mtime; /*最后一次修改时间*/</span><br><span class="line">time_t st_ctime; /*最后一次修改文件状态时间*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">根据处理的不同：</span><br><span class="line">缓冲区文件、非缓冲区文件（系统I/O，二进制文件）</span><br><span class="line"></span><br><span class="line">缓冲：缓冲区的大小由各个具体的C 版本确定，一般为512 字节。</span><br><span class="line">全缓冲(文件把缓冲区写满才写到文件里)</span><br><span class="line">行缓冲（<span class="built_in">printf</span>）</span><br><span class="line">无缓冲（内核调用函数）</span><br><span class="line">根据其存放数据的作用的不同：</span><br><span class="line">其分为普通文件、目录文件、链接文件、设备文件和管道文件</span><br><span class="line"></span><br><span class="line">linux 文件 IO操作有两套大类的操作方式：不带缓存的文件 IO 操作，带缓存的文件 IO操作。不带缓存的属于直接调用系统调用（system call）的方式，高效完成文件输入输出。它以文件标识符（整型）作为文件唯一性的判断依据。这种操作不是 ASCI 标准的，与系统有关，移植有一定的问题。而带缓存的是在不带缓存的基础之上封装了一层，维护了一个输入输出缓冲区，使之能跨 OS，成为 ASCI 标准，称为标准 IO库。不带缓存的方式频繁进行用户态 和内核态的切换，高效但是需要程序员自己维护；带缓冲的方式因为有了缓冲区，不是非常高效，但是易于维护。由此，</span><br><span class="line">不带缓冲区的通常用于文件设备的操作，而带缓冲区的通常用于普通文件的操作。</span><br></pre></td></tr></table></figure>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IO操作分两类</span><br><span class="line">基于文件描述符的IO操作、基于数据流的IO操作</span><br><span class="line"></span><br><span class="line">1、文件描述符-------用户与内核之间</span><br><span class="line">打开磁盘文件一次，内核创建一个文件表项，文件表项包含文件状态信息、存储内容缓存、当前文件路径等。</span><br><span class="line">例如：table[0]=a、table[1]=b、table[3]=c</span><br><span class="line">a,b,c文件表项，描述符为0,1，2 。可以用des[3] = &#123;0,1,2&#125;保存访问磁盘文件。</span><br><span class="line">头文件<span class="comment">#include&lt;unistd.h&gt;。linux系统提供，open（）、close、read（）、write（）、lseek（）等</span></span><br><span class="line">eg:ssize_t <span class="built_in">read</span>(int fp,char *buf,size_t count)</span><br><span class="line">off_t lseek(int fildes,off_t,int <span class="built_in">whence</span>)</span><br><span class="line">参数<span class="built_in">whence</span>:</span><br><span class="line">SEEK_SET:文件开头</span><br><span class="line">SEEK_CUR:文件偏移量</span><br><span class="line">SEEK_END:文件结尾</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、数据流概述----fwrite应用层标准 IO 库自己维护的，然后再到write内核</span><br><span class="line">count 来选择好的时机来完成 write 到内核中的 buf</span><br><span class="line">标准I/O库函数，stdio.h头文件</span><br><span class="line">标准 IO 加了封装之后主要，是为了在应用层添加一个缓冲机制</span><br><span class="line">fopen()、fread()、fclose()、fgetc(0）、fscanf()等</span><br><span class="line">eg: FILE open （const char * path ,const char *mode）</span><br><span class="line">char *fgets(char *s ,int size,FILE *stream);</span><br><span class="line">int fputs(char *s FILE *stream);</span><br><span class="line"></span><br><span class="line">size_t fread(void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">size_t fwrite(const void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>


<h5 id="linux-系统如何管理文件"><a href="#linux-系统如何管理文件" class="headerlink" title="linux 系统如何管理文件"></a>linux 系统如何管理文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、硬盘中的静态文件和 inode（i 节点）</span><br><span class="line"></span><br><span class="line">(1)文件平时都放在硬盘中，硬盘中以一种固定的形式存放，我们称为静态文件</span><br><span class="line">(2)一块硬盘中分为两大区域：一个是硬盘内容管理表，另一个是真正存储的内容区域。操作系统访问硬盘时先去读取硬盘内容管理表，从中找到我们访问的那个扇区级别的信息，然后用这个信息去查询真正的存储内容的区域，然后得到我们要的文件</span><br><span class="line">(3)管理表中以文件为单位，记录了各个文件的各种信息，每一个文件有一个文件列表（我们叫 inode，i节点，其实质是一个结构体，这个结构体有很多元素，每个元素记录了这个文件的一些信息，其中包括文件名，文件在硬盘上对应的扇区号，块号等。。</span><br><span class="line">(4)硬盘管理的时候以文件为单位，每个文件一个 inode，每个 inode 有一个数字编号，对应一个结构体，结构体记录了各种信息</span><br><span class="line"></span><br><span class="line">2、内存中被打开的文件和 vnode（v 节点）</span><br><span class="line">(1)快速格式化只是删除了 U 盘硬盘内容管理表（inode），真正存储的内容没有动，这种格式化可能被找回。</span><br><span class="line">(2)一个程序的运行就是一个进程，我们在程序中打开的文件就属于某个进程。每个进程都有一个数据结构来记录这个进程的所有信息（进程信息），表中有一个指针会指向一个文件管理表，文件管理表中记录了当前进程及其相关信息。</span><br><span class="line">(3)文件管理表中用来索引各个打开的文件的 index 就是文件描述符 f，我们最终找到的就是一个已经被打开的文件的管理结构体 vnode</span><br><span class="line">(4)一个 vnode 中记录了一个被打开的文件的各种信息，而且我们只要知道这个文件的 fd，就可以很容易找到这个文件的 vnode 进而对这个文件进行各操作。</span><br><span class="line"></span><br><span class="line">3、文件和流的概念</span><br><span class="line"></span><br><span class="line">（1）文件操作中，文件类似一个包裹，里面装了一堆字符，但是文件被读出&#x2F;写入时都只能一个字符一个字符的进行，而不能一个文件中 N 多个字符被挨个一次读出&#x2F;写入时，这些字符就构成了字符流</span><br><span class="line">（2）流是动态的，不是静态的</span><br><span class="line">（3）硬盘内容管理表 、文件管理表</span><br><span class="line">inode 用来表示一个静态文件 </span><br><span class="line">vnode 用来表示一个动态文件</span><br></pre></td></tr></table></figure>







<p>参考：王维鋆的个人博客：<a href="https://blog.csdn.net/wangweijundeqq" target="_blank" rel="noopener">https://blog.csdn.net/wangweijundeqq</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库安全性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h5 id="数据库安全概述"><a href="#数据库安全概述" class="headerlink" title="数据库安全概述"></a>数据库安全概述</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据库安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</span><br><span class="line">数据库不安全因素:</span><br><span class="line">(1)非授权用户对数据库进行破坏</span><br><span class="line">(2)数据库重要或者敏感数据泄露</span><br><span class="line">(3)安全环境的脆弱性</span><br></pre></td></tr></table></figure>
<h5 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安全标准：TCSEC标准、CC标准(TCSEC相互总结互补发展而来)</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/1.jpg" class="" title="TCSEC标准">


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/2.jpg" class="" title="CC标准">

<h5 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）用户身份鉴别</span><br><span class="line">	静态鉴别、动态鉴别、生物鉴别、智能卡鉴别。</span><br><span class="line">（2）存取控制 （自主存取控制和强制存取控制，定义用户权限和合法权限检查机制）</span><br><span class="line">	授权:授予和收回</span><br><span class="line">    </span><br><span class="line">	GRANT  &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	TO &lt;用户&gt;</span><br><span class="line">	WITH GRANT OPTION ;（能传递权限，但不能形成循环传递）</span><br><span class="line"></span><br><span class="line">	REVOKE &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	FROM &lt;用户&gt;</span><br><span class="line"></span><br><span class="line">（3）视图机制</span><br><span class="line"></span><br><span class="line">（4）审计</span><br><span class="line">审计功能把用户对数据库的所有操作自动记录下来放入审计日志(auditlog)中。</span><br><span class="line">审计员可以利用审计日志监控数据库中的各种行为,重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。</span><br><span class="line">AUDIT ALTER，PDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line">NOAUDIT ALTER ,UPDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（5）数据加密：传输加密、存储加密</span><br><span class="line">其他安全性保护：推理控制、隐蔽信道、数据隐私保护。</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/3.jpg" class="" title="视图例子">]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>进程创建、等待、结束</title>
    <url>/Linux-Lover/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>作业：用户在依次解题或者一次事物处理过程中要求计算机系统所做工作的集合。<br>进程：一个程序在一个数据集合上的一次运行过程。<br>进程是资源竞争的基本单位<br>线程：进程中的一个实体。<br>线程是程序执行的最小单位<br>管程：只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现). </p>
<h5 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork 系统调用"></a>fork 系统调用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一次调用，二次返回？</span><br><span class="line">答：如果成功创建一个子进程，对于父进程来说返回子进程ID</span><br><span class="line">如果成功创建一个子进程，对于子进程来说返回值为0</span><br><span class="line">问题的本质是：两次返回，是在各自的进程空间中返回的。</span><br><span class="line">子进程和父进程各有自己的内存空间 （fork：代码段、数据段、堆栈段、PCB进程控制块的copy）。</span><br><span class="line">fork返回值大于零的是父进程，为什么这样设计:？</span><br><span class="line">答：因为父进程求子进程的pid比较困难，子进程求父进程的id比较容易</span><br></pre></td></tr></table></figure>
<h5 id="fork-c"><a href="#fork-c" class="headerlink" title="fork.c"></a>fork.c</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">    //子进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the child process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">    //父进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the parent process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="vfork-与fork区别"><a href="#vfork-与fork区别" class="headerlink" title="vfork 与fork区别"></a>vfork 与fork区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vfork函数vfork函数与fork函数相同,都是系统调用函数,两者的区别是在创建子进程时, fork函数会复制所有的父送源,包括进程环境、内荐资源等。而vfork函数在创建子进程时,不会复制父进程的所有资源,父子进程共享空间，可以修改父进程内存空间中的值。</span><br><span class="line">注意：在使用vfork函数时,父进程会被阻塞,需要学进程调用_exit函数退出子进程,不能使用<span class="built_in">exit</span>退出.</span><br></pre></td></tr></table></figure>
<h5 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int gvar=2;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int var=5;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"process id:%ld\n"</span>,(long)getpid());//getpid 获取当前进程id</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"gvar=%d var=%d\n"</span>,gvar,var);</span><br><span class="line">	<span class="keyword">if</span>((pid=vfork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"error!"</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		gvar--;</span><br><span class="line">		var++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		_exit(0);//退出子程序</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the parent process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行简要结果 ： //当前</span><br><span class="line">	process id:2825</span><br><span class="line">	gvar=2 var=5</span><br><span class="line">	the child process id:2826</span><br><span class="line">	gvar=1 var=6//子进程  共享变量的修改</span><br><span class="line">	the parent process id:2825//父进程</span><br><span class="line">	gvar=1 var=6</span><br></pre></td></tr></table></figure>
<h5 id="exec调用函数"><a href="#exec调用函数" class="headerlink" title="exec调用函数"></a>exec调用函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       <span class="comment">#include &lt;unistd.h&gt; </span></span><br><span class="line">       extern char **environ;</span><br><span class="line">       int execl(const char *path, const char *arg, ...); </span><br><span class="line">       int execlp(const char *file, const char *arg, ...); </span><br><span class="line">       int execle(const char *path, const char *arg,</span><br><span class="line">                  ..., char * const envp[]);    </span><br><span class="line">       int execv(const char *path, char *const argv[]);</span><br><span class="line">       int execvp(const char *file, char *const argv[]);</span><br><span class="line">参数说明：</span><br><span class="line">	path参数表示你要启动程序的名称包括路径名</span><br><span class="line">	arg参数表示启动程序所带的参数</span><br><span class="line">	返回值:成功返回0,失败返回-1</span><br><span class="line">函数名说明： </span><br><span class="line">    l代表可变参数列表，p代表在path环境变量中搜索file文件。envp代表环境变量。</span><br><span class="line">例子1：</span><br><span class="line">----------------execve.c-----------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">/*	execve(<span class="string">"new"</span>,argv,environ);</span><br><span class="line">	puts(<span class="string">"正常情况下无法输出此信息"</span>);</span><br><span class="line">*/</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create child process failed!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	       execve(<span class="string">"new"</span>,argv,environ);//文件名字+当前路径+环境变量</span><br><span class="line">           // execve(<span class="string">"./new"</span>,NULL,NULL);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		puts(<span class="string">"正常情况下输出此信息"</span>); //不想舍去放在父进程</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------new2.c----------------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	puts(<span class="string">"welcome to mrsoft"</span>);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">例子2：用execlp调用vi,打开了new2.c</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">	&#123;</span><br><span class="line">	 	 <span class="built_in">printf</span>(<span class="string">"vi的等效用法： %s filename\n"</span>,argv[0]);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line"> 	 &#125;</span><br><span class="line">	  execlp(<span class="string">"/bin/vi"</span>,<span class="string">"vi"</span>,argv[1],(char*)NULL);//文件路径+操作变量名+操作的文件+NULL</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">运行时输入命令：./execlp ./new2.c</span><br></pre></td></tr></table></figure>

<h5 id="wait等待函数"><a href="#wait等待函数" class="headerlink" title="wait等待函数"></a>wait等待函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	父进程没有调用等待函数，子进程会变成僵尸进程。</span><br><span class="line">	僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程。</span><br><span class="line">	孤儿进程：如果父亲进程先结束，子进程会托孤给1号进程</span><br><span class="line">-------------------</span><br><span class="line">    子进程结束，内核会向父进程发送SIGCHLD信号，子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）</span><br><span class="line">    如果存在子进程,进程时的结束状态有(status)如下两种可能: </span><br><span class="line">	进程正常结束：status和PID，status存在子进程退出码（子进程main返回参数或者exti返回参数）当中。</span><br><span class="line"></span><br><span class="line">   信号引起子进程结束：若发送的信号被进程捕获,就不会起到终止进程作用;若信号没有被进程捕误,则会使进程非正常结束。此时参数status返回的状态值为接收到的信号 ,存在最后一个字节中。</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line">void exit_s(int status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(WIFEXITED(status)) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"normal exit,status=%d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"signal exit!status=%d\n"</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid,pid1;</span><br><span class="line">	int status;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		pid1=getpid();</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,9);//结束   信号退出</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,17);//进入父进程  <span class="built_in">wait</span> erro</span><br><span class="line">		<span class="built_in">kill</span>(pid1,19);//终止   直接退出</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">扩展：</span><br><span class="line">宏定义</span><br><span class="line">WIFEXITED(status)	如果子进程正常结束，返回一个非零值</span><br><span class="line">WEXITSTATUS(status)	如果WIFEXITED非零，返回子进程退出码</span><br><span class="line">WIFSIGNALED(status)	子进程因为捕获信号而终止，返回非零值</span><br><span class="line">WTERMSIG(status)	如果WIFSIGNALED非零，返回信号代码</span><br><span class="line">WIFSTOPPED(status)	如果子进程被暂停，返回一个非零值</span><br><span class="line">WSTOPSIG(status)	如果WIFSTOPPED非零，返回一个信号代码</span><br><span class="line">waitip()也用于等待特定进程。调用<span class="built_in">wait</span>或者waitpid函数查询子进程退出状态，此方法父进程会被挂起。</span><br><span class="line">如果不想让父进程挂起，可以在父进程中加入一条语句：</span><br><span class="line">signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</span><br></pre></td></tr></table></figure>
<h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 与_exit()</span><br><span class="line">相同：无论调用成功与否，无返回信息。</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">1）_exit是一个系统调用，<span class="built_in">exit</span>是一个c库函数</span><br><span class="line">2）<span class="built_in">exit</span>会执行清除I/O缓存，可能会丢失临时文件，建议不用。（前面例子，不做说明）</span><br><span class="line">3）<span class="built_in">exit</span>会执行调用终止处理程序</span><br><span class="line"></span><br><span class="line">扩展：atexit（）</span><br><span class="line">代码:</span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello1...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void func2()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello2...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">atexit(func1);//输出func1</span><br><span class="line">atexit(func2);//输出func2</span><br><span class="line">puts(<span class="string">"hello...\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">运行：</span><br><span class="line">hello...</span><br><span class="line">hello2...</span><br><span class="line">hello1...</span><br></pre></td></tr></table></figure>


<h5 id="确保父进程退出的同时，子进程也退出？"><a href="#确保父进程退出的同时，子进程也退出？" class="headerlink" title="确保父进程退出的同时，子进程也退出？"></a>确保父进程退出的同时，子进程也退出？</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/prctl.h&gt;</span></span><br><span class="line">prctl(PR_SET_PDEATHSIG,SIGKILL);</span><br><span class="line">//最后不会看到它成为孤儿进程，被其他进程所收养。注意该函数并非所有系统都支持。</span><br><span class="line"></span><br><span class="line">``</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/Data-Structure-and-Algorithms-Lover/d/</url>
    <content><![CDATA[<h5 id="LeetCode-总结"><a href="#LeetCode-总结" class="headerlink" title="LeetCode 总结"></a>LeetCode 总结</h5><h5 id="二叉树最大路径和"><a href="#二叉树最大路径和" class="headerlink" title="二叉树最大路径和"></a>二叉树最大路径和</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">&#125;;</span><br><span class="line">int OneSideMax(TreeNode *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootroot-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;right);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        int a = OneSideMax(root-&gt;left);</span><br><span class="line">        int b = OneSideMax(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;     </span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + b;</span><br><span class="line">        &#125;</span><br><span class="line">  		  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*判断树是否为镜像,判断优先考虑递归QAQ*/</span><br><span class="line">bool isSym(struct TreeNode *root1 ,struct TreeNode *root2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == NULL &amp;&amp; root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==NULL || root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root1-&gt;left,root2-&gt;right)&amp;&amp;isSym(root1-&gt;right,root2-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetric(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">输出镜像树</span><br><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct TreeNode* Swap(struct TreeNode* root)</span><br><span class="line">&#123;   </span><br><span class="line">     <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(root-&gt;left);</span><br><span class="line">    Swap(root-&gt;right);</span><br><span class="line">    struct TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left  =  root-&gt;right ;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">return</span>  Swap(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>1、综合起来看是否能构成一棵二叉树；<br>2、设前序列abcdefg为进栈的顺序，符合出栈顺序的则可能是中序遍历的结果。</p>
<img src="/Data-Structure-and-Algorithms-Lover/d/%E6%A0%91.jpg" class="">



<h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><img src="/Data-Structure-and-Algorithms-Lover/d/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" class="">

]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构框架</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>记言：被华为的笔试题弄晕了，才发现自己的数据结构和算法是多么的苍白无力，但我会变强的QAQ。<br>2019-4-15 ming</p>
<p>资料学习：在Github上有份资料值得推荐。<br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/</a> 向dalao递茶.jpg</p>
<p>遍历框架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*数组遍历*/</span><br><span class="line">void traverse（int [] arr）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i ; i &lt;arr.length ; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		//迭代 arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*链表遍历*/</span><br><span class="line">class ListNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	<span class="keyword">for</span> (ListNode p = head ; p != null ; p = p.next)&#123;</span><br><span class="line">    	</span><br><span class="line">        //迭代访问p.data</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	//递归head.data;</span><br><span class="line">	traverse(head.next);</span><br><span class="line">&#125;</span><br><span class="line">/*二叉树遍历*/</span><br><span class="line">class TreeNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode left ,right;</span><br><span class="line">&#125;</span><br><span class="line">void traverse (TreeNode root)&#123;</span><br><span class="line">	//递归root.data  先序</span><br><span class="line">    //cout &lt;&lt; root.data &lt;&lt; endl;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*N叉树遍历*/</span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode [] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void traverse(TreeNode root)&#123;</span><br><span class="line">	//c++ 11 标准</span><br><span class="line">	<span class="keyword">for</span>(TreeNode clid : root.children)&#123;</span><br><span class="line">    	//cout &lt;&lt; child.data &lt;&lt; endl;</span><br><span class="line">    	traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB的基本常识</title>
    <url>/Circuit-Lover/PCB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h4 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">频率：10M-100M </span><br><span class="line">线框：10mile（0.254mm=10mil）</span><br><span class="line">电源：20-30v //电源线加粗抗干扰</span><br><span class="line">价钱：80-100元</span><br><span class="line">DIP 双直插式</span><br><span class="line">QFP 方扁封装</span><br><span class="line">孔的类型</span><br><span class="line">孔有三大类别：过孔（Vai）、 插件孔（Pad孔） 、无铜安装孔（Npth）</span><br><span class="line">过孔（via）：只是起电气导通作用不用插器件焊接，其表面可以做开窗（焊盘裸露）、盖油或者塞油。</span><br><span class="line">插件孔（Pad孔）：需要插器件焊接的引脚孔，焊盘表面必须裸露出来</span><br><span class="line">无铜安装孔（Npth）:螺丝孔或器件塑料固定脚，没有电气性能，起定位固定作用。</span><br></pre></td></tr></table></figure>
<h4 id="AD软件操作"><a href="#AD软件操作" class="headerlink" title="AD软件操作"></a>AD软件操作</h4><h6 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q  精度转化mile---mm</span><br><span class="line">1 电路规划（板子大小）</span><br><span class="line">快捷键TVT打安装孔（双击属性：Board cutout 板剪切块）copper镀铜  polygon cutout多边形剪切</span><br><span class="line">2 二维s</span><br><span class="line">3 三维</span><br><span class="line">shitf+右键旋转</span><br><span class="line">ctrl+中键  放大</span><br><span class="line">N +  S  +  A  显示预拉线</span><br><span class="line">N +  H +  A      隐藏预拉线（N键）</span><br><span class="line">shitf +F查找类似</span><br><span class="line">先按3切换到三维界面，然后按住SHIFT不放，按鼠标右键调整视图角度</span><br></pre></td></tr></table></figure>
<h5 id="一块PCB的生成基本过程"><a href="#一块PCB的生成基本过程" class="headerlink" title="一块PCB的生成基本过程"></a>一块PCB的生成基本过程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.原理图 （满足输入左边，输出右边）</span><br><span class="line">2.一键生成PCB</span><br><span class="line">3.自动布线</span><br><span class="line">4.手工布线</span><br><span class="line">5.规则检查</span><br><span class="line">6.泪滴</span><br><span class="line">7.敷铜（放置多边形敷铜（G键））</span><br><span class="line">8.规则检查</span><br><span class="line">9.信号检查</span><br><span class="line">10.生成物料清单</span><br><span class="line">11.联系淘宝卖家 （嘉立创）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>超声波传感器</title>
    <url>/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p><strong>超声波分类</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">振动在弹性介质内的传播称为波动，简称波。</span><br><span class="line">低于16 Hz的机械波，称为次声波；</span><br><span class="line">在16~2×10^4 Hz之间，称为声波；</span><br><span class="line">高于2×10^4 Hz的机械波，称为超声波,</span><br><span class="line">在3×10^8~3×10^11Hz之间的波，称为微波。</span><br><span class="line">波类型和传递介质</span><br><span class="line">① 纵波：质点振动方向与波的传播方向一致的波，它能在固体、液体和气体介质中传播；</span><br><span class="line">② 横波：质点振动方向垂直于传播方向的波，它只能在固体介质中传播； </span><br><span class="line">③ 表面波：质点的振动介于横波与纵波之间，沿着介质表面传播，其振幅随深度增加而迅速衰减的波，表面波只在固体的表面传播。</span><br></pre></td></tr></table></figure>
<p><strong>超声波应用</strong><br>(1)超声波用于高效清洗<br>当弱的声波信号作用于液体中时，会对液体产生一定的负压，即液体体积增加，液体中分子空隙加大，形成许多微小的气泡；而当强的声波信号作用于液体时，则会对液体产生一定的正压，即液体体积被压缩减小，液体中形成的微小气泡被压碎。经研究证明：超声波作用于液体中时，液体中每个气泡的破裂会产生能量极大的冲击波，相当于瞬间产生几百度的高温和高达上千个大气压的压力，这种现象被称之为“空化作用”，超声波清洗正是利用液体中气泡破裂所产生的冲击波来达到清洗和冲刷工件内外表面的作用。超声清洗多用于半导体、机械、玻璃、医疗仪器等行业。<br>(2)超声波焊接(主要三要素：时间、压力、振幅)<br>压电陶瓷或磁致伸缩材料在高电压窄脉冲作用下，可得到较大功率的超声波，可以被聚焦，能用于集成电路及塑料的焊接。<br>注：金属也行。<br>(3)超声波在医学检查中的应用<br>胎儿的B超影像…</p>
<p><strong>超声波传感器</strong><br>超声物位传感器：单换能器、双换能器<br>只要测得超声波脉冲从发射到接收的时间间隔，便可以求得待测的物位。 </p>
<p><strong>超声侧厚传感器</strong><br>双晶直探头中的压电晶片发射超声振动脉冲，超声脉冲到达试件底面时，被反射回来，并被另一只压电晶片所接收。</p>
<p><strong>超声波流量传感器</strong><br>目前应用较广的主要是超声波传播时间差法.超声波在流体中传播时，在静止流体和流动流体中的传播速度是不同的，利用这一特点可以求出流体的速度，再根据管道流体的截面积， 便可知道流体的流量。</p>
<img src="/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="超声波传感器">


<p><strong>超声波传感器的应用</strong><br>超声波流量计<br>超声波侧厚<br>超声波探伤<br>超声波报警器</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程常识</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h5 id="计算机常识QAQ"><a href="#计算机常识QAQ" class="headerlink" title="计算机常识QAQ"></a>计算机常识QAQ</h5><img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/1.jpg" class="" title="计算机系统硬件组成（linux王保明）">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽贯穿整个系统的一组电子管道称为总线</span><br><span class="line">片内总线</span><br><span class="line">系统总线：数据总线DB、地址总线CB、控制总线CB</span><br><span class="line">外部总线</span><br><span class="line"></span><br><span class="line">CPU：运算寄存器ALU、控制器、寄存器（状态寄存器、通用寄存器）</span><br><span class="line">取指、译码、执行、写回、跳转。pc指针多32位。</span><br><span class="line"></span><br><span class="line">什么是操作系统</span><br><span class="line">操作系统：有效地管理计算机系统中的资源，合理地管理计算机系统的工作流程，方便用户使用的程序的集合。</span><br><span class="line"></span><br><span class="line">操作系统五大任务</span><br><span class="line">(1)文件管理</span><br><span class="line">(2)处理器管理</span><br><span class="line">(3)内存管理</span><br><span class="line">(4)设备管理</span><br><span class="line">(5)作业管理</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/2.jpg" class="">

<h5 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">体系结构:linux内核被划分为多个子系统。基本服务都集成到内核中,例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。（收包和发包产生大量中断，放在内核最有效率）。</span><br><span class="line">主要子系统：</span><br><span class="line">（1）系统调用接口</span><br><span class="line">（2）进程管理</span><br><span class="line">（3）内存管理：其中，为每个子程序提供了一个2^32虚拟内存。</span><br><span class="line">为n个进程提供访问的物理空间、段式管理和页式管理就行了。linux进程并发模型.</span><br><span class="line">（4）虚拟文件系统（VFS）：虚拟文件系统 在 系统调用层接口（SCI ）和内核所支持的文件系统之间提供了一个交换层。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展： Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供MMU的处理器上运行。Linux 内核的uClinux移植提供了对非 MMU 的支持</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/3.jpg" class="">


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>联发科面试</title>
    <url>/My-interview-Lover/%E8%81%94%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>笔试题目：Q1<br>图形推理，请选择最合适的一项填入问号处，使之符合整个图像的变化规律。</p>
<img src="/My-interview-Lover/%E8%81%94%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/1.jpg" class="">

<p>Q2：<br>已知一组数字为2，3，9，21，（ ），93，根据规律，括号内的数字应该是？<br>A、25<br>B、35<br>C、45<br>D、55<br>C 45  </p>
<p>2x3+3=9<br>2x9+3=21<br>2x21+3=45<br>2x45+3=93?</p>
<p>Q3：<br>翻译下文：<br>We’ve announced the 5G Dimensity 1000+ to global media, bringing their attention to stand-out features and its flagship-grade status, elevating MediaTek’s position in the smartphone landscape. Higher refresh rate is better suited for playing games, reducing motion blur and jitters to provide a smooth visual experience. While this is not a complete architectural overhaul, its “+” suffix does bring with it some welcome enhancements over the standard Dimensity 1000. It focused on 144Hz displays, 5G power savings and MiraVision enhancements. As part of our global launch campaign, an online event was held in China with key media and social influencers in attendance. It generated a total of 317 articles, of which 250 were from invited media and KOL, plus 67 earned media.<br>我们已经向全球媒体宣布了5G维度1000+，让他们关注其突出的功能和旗舰级的地位，提升联发科在智能手机领域的地位。较高的刷新率更适合玩游戏，减少运动模糊和抖动，提供平滑的视觉体验。虽然这不是一个完整的架构大修，但它的“+”后缀确实带来了一些优于标准维度1000的受欢迎的增强。该公司专注于144Hz显示屏、节省5G电能和增强MiraVision功能。作为我们全球推广活动的一部分，我们在中国举办了一场有重要媒体和社会影响人士参加的在线活动。共产生317篇文章，其中250篇来自受邀媒体和KOL, 67篇来自earned media。<br>Q4：<br>对于函数Sum = a&amp;b&lt;&lt;c + a^c;<br>当a=3, b=5, c=4时，sum的输出结果是？B<br>A、0<br>B、4<br>C、16<br>D、7<br> a&amp;b =1<br>4+a^c=4+7 = 11?<br>1&lt;&lt;11?? </p>
<p>Q5：<br>下列哪些函数可能造成缓冲区溢出？多选 ABD<br>A、strcat<br>B、strncat<br>C、strcmp<br>D、strcpy<br>D</p>
<p>Q6：<br>以下表达式哪些为逻辑true？ABC<br>A、1<br>B、-1<br>C、!(10&amp;20)<br>D、!(10-20)<br> A<br>Q7：<br>下面说法正确的是<br>A、BSS段（bss segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域<br>B、栈（stack）是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减<br>C、代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域，这部分区域的大小在执行时是动态变化的<br>D、每一个线程都有一个栈，但是每一个应用程序通常只有一个堆<br>D</p>
<p>Q8：选择为真的表达式：CD<br>char str1[] = “abc”;<br>char str2[] = “abc”;<br>const char str3[] = “abc”;<br>const char str4[] = “abc”;<br>const char *str5 = “abc”;<br>const char *str6 = “abc”;<br>char *str7 = “abc”;<br>char *str8 = “abc”;<br>A、str1 == str2<br>B、str3 == str4<br>C、str5 == str6<br>D、str7 == str8<br>C、D?</p>
<p>Q9：<br>宣告以下变量<br>unsigned short int A = 0x00F0;<br>unsigned short int B = 0x00A5;<br>unsigned short int C = 0x0000;<br>unsigned short int X;<br>请计算下列表达式的值，填入括号内<br>（1）X = A&B; 0x00A0<br>（2）X = A^B;     0x0055<br>（3）X = A | B;   0x00F5</p>
<p>Q10：<br>如下结构体<br>struct A{<br>char a1;/<em>start add 0</em>/<br>char a2; ;/<em>start add 1</em>/<br>char a3; ;/<em>start add 2</em>/<br>long a4; /<em>start add 4</em>/<br>short a5; ;/<em>start add 8</em>/<br>char a6; ;/<em>start add 10</em>/<br>int <em>a7; ;/*start add 12</em>/<br>char a8; ;/<em>start add 16</em>/<br>}; /<em>17 +3 = 20</em>/<br>struct B{<br>char a1;<br>char a2;<br>char a3;<br>};<br>在32位编译器下用sizeof(struct A)计算出的大小是多少？<br>20<br>在32位编译器下用sizeof(struct B)计算出的大小是多少？<br>3<br>下面程序的运行结果是？2/1<em>3=6<br>main()<br>{<br>struct A{<br>    int x;int y;<br>}num[2]={1,2,3,4};<br>printf(“%d\n”,num[0].y/num[0].x</em>num[1].x);<br>}<br> 0<br>Q12：<br>计算sizeof<br>char str1[] = {’a’,’b’,’c’,’d’,’e’,’\0’,’f’};<br>char str2[] = “abcde”;<br>char str3[][80] = {“C++”,”JAVA”,”C”,”PYTHON”};<br>char *ptr = “abcde”;<br>printf(“%d,”,sizeof(str1));            //8  7<br>printf(“%d,”,sizeof(str2));           //6<br>printf(“%d,”,sizeof(str3));     //   4 x 80 = 320<br>printf(“%d”,sizeof(ptr));     //4<br>输出的结果是多少？</p>
<p>Q13：<br>计算strlen<br>char str1[] = {’a’,’b’,’c’,’d’,’e’,’\0’,’f’};<br>char str2[] = “abcde”;<br>char str3[][80] = {“C++”,”JAVA”,”C”,”PYTHON”};<br>char *ptr = “abcde”;<br>printf(“%d,”,strlen(str1));      //5<br>printf(“%d,”,strlen(str2));       //5</p>
<p>printf(“%d,”,strlen(str3));  //4 x 80 = 320  5<br>printf(“%d”,stelen(ptr));  //4<br>输出的结果是多少？</p>
<p>Q14：<br>下面结构体，在32bit的系统下使用sizeof(t_test)的结果是多少？<br>typedef struct test{<br>unit8_t a;   /<em>start addr    1</em>/<br>unit32_t b;  /<em>start addr    4</em>/<br>unit16_t c;  /<em>start addr    8</em>/<br>unit8_t d;   /<em>start addr    10</em>/<br>unit16_t e; /<em>start addr    12</em>/<br>}t_test;<br> 12+2 = 14   16  u32对齐4字节倍数</p>
<p>请指出下面代码的不合理之处和修改方法，假设传入的参数均为正常的指针，不为空//看不出QAQ，我也看出，当时没写，太乱了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PROPERTY_VALUE_MAX 30</span><br><span class="line">void test(int id, char *pName, char *pUpdateValue)&#123;</span><br><span class="line">#define MAX_NUM 10</span><br><span class="line">char newPropertyValue[PROPERTY_VALUE_MAX] &#x3D; &#123;0&#125;;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">for(i &#x3D; 0;i &lt; MAX_NUM; i++)&#123;</span><br><span class="line">    if(i &#x3D;&#x3D; id)&#123;</span><br><span class="line">        &#x2F;&#x2F; use new value</span><br><span class="line">strncat(newPropertyValue, pUpdateValue, PROPERTY_VALUE_MAX – strlen(newPropertyValue));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        strncat(newPropertyValue, pName, PROPERTY_VALUE_MAX – strlen(newPropertyValue));</span><br><span class="line">        &#125;</span><br><span class="line">        if(i !&#x3D; MAX_NUM -1)&#123;</span><br><span class="line">            strncat(newPropertyValue, “,”, 1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">下程式算法实现的功能是什么？2-99的质数个数？对</span><br><span class="line">void function(void)&#123;</span><br><span class="line">int I&#x3D;i,j,k&#x3D;0;</span><br><span class="line">for(i&#x3D;2;i&lt;100;i++)&#123;</span><br><span class="line">    for(j&#x3D;2;j&lt;I;j++)&#123;</span><br><span class="line">        if(i%j&#x3D;&#x3D;0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j&gt;&#x3D;i)&#123;</span><br><span class="line">        printf(“%d”,i);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(“\nTotal:%d”,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编程题目：<br> Q19<br>给出一个字符串，请编写函数按照指定的分割字符分割字符串。假定输入字符串为“aaaa;bbbb;cccc ;”//其中aaaa;bbbb;cccc为输入字符串，“;”为最后一个字符，则指定“;”为分隔符，注意分隔符和字符串间有个空格，得到的结果为<br>aaaa<br>bbbb<br>cccc</p>
 <img src="/My-interview-Lover/%E8%81%94%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/2.jpg" class="">


<p>要处理输入。搞到现在，有些网上笔试的编程题都是自己处理输入的<br>Q20：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一组数字，请分别完成以下操作：</span><br><span class="line">1、创建一个双向链表listA，链表节点依次存放数组中的元素，依次打印链表中的值，链表节点如下：</span><br><span class="line">struct list_node&#123;</span><br><span class="line">unsigned int val;</span><br><span class="line">struct list_node *pre, *next;</span><br><span class="line">&#125;;</span><br><span class="line">2、请找出listA中val的bit3~5不为0的节点，然后将bit3~5置0，打印出修改后的val，然后从listA中移除。</span><br><span class="line">3依次打印将listA中剩余的节点的val值。将listA中剩余节点倒序，并依次打印val值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码：#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">struct  list_node &#123;</span><br><span class="line"></span><br><span class="line">	unsigned int val;</span><br><span class="line">	list_node *pre, *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int buf[5] &#x3D; &#123; 58,2,4,56,3 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*创建*&#x2F;</span><br><span class="line">list_node * creatlist_node(unsigned int buf[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	list_node *phead, *pcur, *pm;</span><br><span class="line">	int count &#x3D; n;</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;%d&quot;,count);</span><br><span class="line">	phead &#x3D; (list_node*)malloc(sizeof(list_node));</span><br><span class="line">	phead-&gt;val &#x3D; 0;</span><br><span class="line">	pcur &#x3D; phead;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; count; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		pm &#x3D; (list_node*)malloc(sizeof(list_node));</span><br><span class="line">		pm-&gt;val &#x3D; buf[i];</span><br><span class="line"></span><br><span class="line">		pcur-&gt;next &#x3D; pm;</span><br><span class="line">		pm-&gt;next &#x3D; pcur;</span><br><span class="line"></span><br><span class="line">		pcur &#x3D; pm;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pcur-&gt;next &#x3D; NULL;</span><br><span class="line">	phead &#x3D; phead-&gt;next;</span><br><span class="line">	phead-&gt;pre &#x3D; NULL;</span><br><span class="line">	return phead;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*遍历*&#x2F;</span><br><span class="line">int traverseList_node(list_node * phead)</span><br><span class="line">&#123;</span><br><span class="line">	list_node * pcur &#x3D; phead;</span><br><span class="line">	if (pcur &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;%d &quot;, pcur-&gt;val);</span><br><span class="line">	traverseList_node(pcur-&gt;next);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*请找出listA中val的bit3~5不为0的节点，然后</span><br><span class="line">将bit3~5置0，打印出修改后的val，然后从listA中移除。</span><br><span class="line">0011 1000  </span><br><span class="line">  &amp; 0x38</span><br><span class="line">1100 0111 </span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;*查找函数*&#x2F;</span><br><span class="line"></span><br><span class="line">list_node * findlist_node(list_node *phead)</span><br><span class="line">&#123;</span><br><span class="line">	list_node * pcur &#x3D; phead;</span><br><span class="line">	list_node *ppre &#x3D; phead;</span><br><span class="line"></span><br><span class="line">	if (pcur &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;s2&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	while (pcur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		if ((pcur-&gt;val &amp; 0x38) &#x3D;&#x3D; 0x38)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;find_data: %d   &quot;, pcur-&gt;val);</span><br><span class="line">			printf(&quot;new_data: %d \n&quot;,  pcur-&gt;val &amp; 0xc7);</span><br><span class="line">		</span><br><span class="line">			if (pcur &#x3D;&#x3D; phead) &#123;</span><br><span class="line">				   ppre &#x3D;   ppre-&gt;next;</span><br><span class="line">				   </span><br><span class="line">				   free(pcur);</span><br><span class="line">					pcur &#x3D; ppre;</span><br><span class="line">				   phead &#x3D; ppre;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				ppre-&gt;next &#x3D; pcur-&gt;next;</span><br><span class="line">				free(pcur);</span><br><span class="line">				pcur &#x3D; ppre-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			ppre &#x3D; pcur;</span><br><span class="line">			pcur &#x3D; ppre-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;s3&quot;);</span><br><span class="line">	return phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*倒序*&#x2F;</span><br><span class="line">list_node * reverse(list_node *phead)</span><br><span class="line">&#123;</span><br><span class="line">	list_node *pPre, *pCur, *pNext;</span><br><span class="line">	if (phead &#x3D;&#x3D; NULL   || phead-&gt;next &#x3D;&#x3D;NULL )</span><br><span class="line">	&#123;</span><br><span class="line">		return phead;</span><br><span class="line">	&#125;</span><br><span class="line">	pCur &#x3D; phead;</span><br><span class="line">	pPre &#x3D; phead;</span><br><span class="line"></span><br><span class="line">	while (pCur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;*保存下一值*&#x2F;</span><br><span class="line">		pNext &#x3D; pCur-&gt;next;</span><br><span class="line">		</span><br><span class="line">		&#x2F;*交换*&#x2F;</span><br><span class="line"></span><br><span class="line">		pCur-&gt;next &#x3D; pPre;</span><br><span class="line">		pPre-&gt;pre &#x3D; pCur;</span><br><span class="line"></span><br><span class="line">		&#x2F;*移位*&#x2F;</span><br><span class="line">		pPre &#x3D; pCur;</span><br><span class="line">		pCur &#x3D; pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	phead-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	phead &#x3D; pPre;</span><br><span class="line">	phead-&gt;pre &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	return phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">	list_node *phead &#x3D; creatlist_node(buf,5);</span><br><span class="line">	traverseList_node(phead);</span><br><span class="line">	\</span><br><span class="line">	phead &#x3D; findlist_node(phead);</span><br><span class="line"></span><br><span class="line">	printf(&quot;逆序\n&quot;);</span><br><span class="line">	phead &#x3D; reverse(phead);</span><br><span class="line"></span><br><span class="line">	traverseList_node(phead);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/My-interview-Lover/%E8%81%94%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/3.jpg" class="">

<p> %}</p>
]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>容器使用应用场景小记🕵️</title>
    <url>/C-C-Lover/%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>vector与deque的比较：</p>
<p>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。</p>
<p>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p>
<p>三：deque支持头部的快速插入与快速移除，这是deque的优点。</p>
<p>四：list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>五：set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>六：map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/MySql-Lover/%E5%8A%A1/</url>
    <content><![CDATA[<h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</span><br><span class="line">事务的 ACID 特性：原子性、一致性、隔离性、持续性。</span><br><span class="line">事务是并发控制的基本单位。</span><br><span class="line">并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</span><br><span class="line">脏读：就是指当一个事务对数据进行了修改但还没有提交到数据库时，另一个事务访问并使用了这个数据。</span><br><span class="line">不可重复读：在一个事务内两次读数据之间，第二个事务访问该数据并进行了修改。</span><br><span class="line">丢失修改：两个事务读入同一数据并修改，T2提交的结果破坏了T1提交的结果。例如T1读A修改为A-1，T2也读A修改为A-1（实际上应该是读A-1，修改 为A-2）</span><br><span class="line">&lt;部分来源牛客网&gt;</span><br></pre></td></tr></table></figure>

<p>SHOW ENGINES;#开启事务<br>SET autocommit=0;<br>START TRANSACTION；<br>#处理<br>UPDATA account set  balance =100 where usename = ‘ming’;<br>ROLLBACK ;</p>
<p>__savepoint保存回滚</p>
<p>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点S<br>ELECT * FROM account;</p>
<p>扩展知识点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">恢复的实现技术:建立冗余数据,利用冗余数据实施数据库恢复。</span><br><span class="line">建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>少用全局变量</title>
    <url>/C-C-Lover/%E5%B0%91%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>全局变量</td>
<td>在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</td>
</tr>
<tr>
<td>局部变量</td>
<td>在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。</td>
</tr>
</tbody></table>
<p>__注意</p>
<p>全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。<br>滥用全局变量会造成不必要的常量频繁使用，特别当这个常量没有用宏定义“正名”时，代码阅读起来将万分吃力。</p>
<p>__有什么对策？</p>
<ol>
<li>能不用全局变量尽量不用。</li>
<li>如果不可避免需要用到，那能藏多深就藏多深。<br>1)如果只有某.c文件用，就static到该文件中，顺便把结构体定义也收进来；<br>2)如果只有一个函数用，那就static到函数里面去；<br>3)如果非要开放出去让人读取，那就用函数return出去，这样就是只读属性了；<br>4)如果非要遭人蹂躏赋值，好吧，我开放函数接口让你传参赋值<br>5)实在非要extern我，我还可以严格控制包含我.h档的对象，而不是放到公共的includes.h中被人围观，丢人现眼。<br>6）当一个模块里面的全局变量超过3个(含)时，就用结构体包起来吧。要归0便一起归0，省得丢三落四的。</li>
</ol>
<p>公众号：C/C++技术文章<br>参考资料：<br>【1】佚名. 全局变量、局部变量、静态全局变量、静态局部变量的区别<br>【2】佚名. 嵌入式C编程经验之全局变量猛于虎<br>【3】《C11标准文档》</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>华为面试</title>
    <url>/My-interview-Lover/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>自振荡产生正弦波、方波、三角波</title>
    <url>/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/</url>
    <content><![CDATA[<h4 id="振荡电路知识"><a href="#振荡电路知识" class="headerlink" title="振荡电路知识"></a>振荡电路知识</h4><h5 id="1、振荡条件"><a href="#1、振荡条件" class="headerlink" title="1、振荡条件"></a>1、振荡条件</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t1.jpg" class="">
<h5 id="2、起振、稳幅"><a href="#2、起振、稳幅" class="headerlink" title="2、起振、稳幅"></a>2、起振、稳幅</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t2.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(1)无输入源，起振信号源来自哪里？</span><br><span class="line">答：电器内部噪声以及电源接通扰动。</span><br><span class="line">(2)稳幅作用？</span><br><span class="line">答：信号输出幅度达到一定程度时，会失真。必须通过调幅限制，使得振幅平衡回到AF = 1。</span><br></pre></td></tr></table></figure>
<p>3、基本组成部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽放大电路</span><br><span class="line">▽反馈电路</span><br><span class="line">▽选频网络</span><br><span class="line">▽稳幅环节</span><br></pre></td></tr></table></figure>
<p>移相式正弦振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">扩展知识点：</span><br><span class="line">1. 电阻上的电压电流同相位</span><br><span class="line">2. 电感上的电流落后电压90°相位</span><br><span class="line">3. 电容上的电流超前电压90°相位</span><br></pre></td></tr></table></figure>
<p>RC振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注：Rf为热敏电阻。</span><br></pre></td></tr></table></figure>
<h4 id="课设设计：100Hz与5000Hz"><a href="#课设设计：100Hz与5000Hz" class="headerlink" title="课设设计：100Hz与5000Hz"></a>课设设计：100Hz与5000Hz</h4><h5 id="原理设计"><a href="#原理设计" class="headerlink" title="原理设计"></a>原理设计</h5><p>正弦波发生</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t6.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f0=1/(2π√R1R2C1C2)  </span><br><span class="line">①可以修改 R1 R2 C1 C2 来产生100Hz 和 5000Hz</span><br><span class="line">通过调节R1，R2，C1，C2的值，使得f0=100Hz。先取C1=100nF，C2=100nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=16K,R2=16K。</span><br><span class="line">为了方便调试，16k采用20k滑动变阻器。</span><br><span class="line">②通过调节R1，R2，C1，C2的值，使得f0=5000Hz。先取C1=1nF，C2=1nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=1K,R2≈640Ω。</span><br><span class="line">为了方便调试， 640Ω采用1k滑动变阻器</span><br></pre></td></tr></table></figure>
<p>正弦波转方波、三角波</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t7.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正弦波转方波：过零比较器</span><br><span class="line">方波转三角波: 积分放大器</span><br></pre></td></tr></table></figure>
<h5 id="proteus仿真"><a href="#proteus仿真" class="headerlink" title="proteus仿真"></a>proteus仿真</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t8.jpg" class="">

<h5 id="实物演示"><a href="#实物演示" class="headerlink" title="实物演示"></a>实物演示</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t9.jpg" class="">

<h5 id="课设总结"><a href="#课设总结" class="headerlink" title="课设总结"></a>课设总结</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我在这次课程设计中遇到，一直都调不出理想的波形，检查了很多东西，像接线问题、电路问题、电源问题、示波器问题地线问题等等，所以我总结出，对于要求精度很高的电路，一旦出现实际问题时，应该具备以下三个点：</span><br><span class="line">1.重新审查电路原理图，计算相关数据，运行仿真结果。</span><br><span class="line">2.元件器件的损坏或性能的影响，因为在这个放大电路中稍有偏差，结果就会相差很大，此次个人觉得时间较为紧迫，选择附近的元件卖家，结果性能远远达不到所需的要求。</span><br><span class="line">3.要有足够的耐心和冷静的思考，当图形出现差异时，冷静的思考是必不可少的。</span><br><span class="line">通过这次课程设计,我懂得了要完成一个电路的设计,理论基础是根基,实践操作是完成实物的重要部分,而创新能力则决定了一个电路的价值,因为设计一个电路,决不是简单地按课本的电路图进行焊接成型,我们要进行电路各个元件参数的计算,这个涉及我们所掌握的理论知识,元件的计算是设计中较为重要的一部分,计算准了,则设计出来的电路误差不大,否则,设计出来的电路性能指标跟要求相差甚远。</span><br><span class="line">最困难的是当电路出现错误是,如何检测出错误之处,如何排除错误,它考验了我们如何运用理论知识和实际的调试的能力, 这也是我大三这一年最需要注重和提高的地方。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>传感器的特点</title>
    <url>/Circuit-Lover/%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>1.什么叫传感器? </p>
<p>能够感受规定的被测量并按照一定规律转化成可用输出信号的器件或装置。</p>
<p>2、传感器共性是什么？<br>传感器的共性就是利用物理规律或物质的物理、生物、化学特性，将非电量信号（位移、速度、力等）输入转换成电量（电压、电流、电容等）输出。</p>
<p>3、传感器由哪些部分组成？<br>传感器一般是由敏感元件、转化元件和变换电路三部分组成。</p>
<p>4、改善传感器？<br>（1）差动技术<br>（2）平均技术<br>（3）补偿与修正<br>（4）干扰抑制<br>（5）稳定性处理</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>cvte面试</title>
    <url>/My-interview-Lover/te%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>文件夹系统目录</title>
    <url>/Linux-Lover/%E5%A4%B9%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><strong>文件夹系统目录</strong></p>
<table>
<thead>
<tr>
<th>文件目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。</td>
</tr>
<tr>
<td>/boot</td>
<td>Ubuntu内核和启动文件，比如vmlinuz-xxx。grub引导装载程序。</td>
</tr>
<tr>
<td>/cdrom</td>
<td>光盘</td>
</tr>
<tr>
<td>/dev</td>
<td>设备驱动文件  sda *磁盘驱动文件</td>
</tr>
<tr>
<td>/etc</td>
<td>存放一些系统配置文件，比如用户账号和密码文件，各种服务的起始地址。</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹，一般创建用户账户的时候，默认的用户主文件夹都会放到此目录下。</td>
</tr>
<tr>
<td>/lib</td>
<td>存放库文件</td>
</tr>
<tr>
<td>/media</td>
<td>此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到这个目录中。</td>
</tr>
<tr>
<td>/mnt</td>
<td>用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。</td>
</tr>
<tr>
<td>/opt</td>
<td>可选的文件和程序存放目录，给第三方软件放置的目录。</td>
</tr>
<tr>
<td>/root</td>
<td>root用户目录，也就是系统管理员目录。</td>
</tr>
<tr>
<td>/sbin</td>
<td>和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。</td>
</tr>
<tr>
<td>/run</td>
<td>运行有关的信息</td>
</tr>
<tr>
<td>/snap</td>
<td>包管理工具</td>
</tr>
<tr>
<td>/srv</td>
<td>服务相关目录。比如网络服务。</td>
</tr>
<tr>
<td>/sys</td>
<td>记录内核信息，虚拟文件系统。</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时目录</td>
</tr>
<tr>
<td>/var</td>
<td>存放一些变化的文件，比如日志文件</td>
</tr>
<tr>
<td>/usr</td>
<td>usr不是user的缩写，而是UNIX Software Resource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！  du -sh</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，数据放置到内存中，存放系统运行信息</td>
</tr>
</tbody></table>
<p>__ 其他:__<br> Cat /proc/cpuinfo   cpu信息<br> ls /sys/bus/platform  设备树（device 、 driver）<br>正常情况，应该是Owner可以读写，all可读，root可以修改可执行权限才对。<br>正常情况，对于目录，应该权限设定为744，对于文件默认权限应该设定为644。<br>用户私有文件，权限应该设定为600。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘文件、内存命令</title>
    <url>/Linux-Lover/%E5%86%85%E5%AD%98%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ls /dev/sd*</p>
<p>df：列出文件系统的整体磁盘使用量。主要查看个文件系统的使用量，<br>du:评估文件系统的磁盘使用量，主要查看单个文件的大小。<br>eg:du -h –max-depth=1  显示一层</p>
<p>磁盘的挂载和卸载mount和umount命令</p>
<p>sudo umount media/ming/MING    </p>
<p>mkdir udisk</p>
<p>sudo mount /dev/sdb1  /media/ming/udisk</p>
<p>sudo mount -o iocharset=utf8  /dev/sdb1 /media/ming/udisk //中文显示</p>
<p>分区挂载不能进行分区操作<br>sudo fdisk /dev/sdb</p>
<p>磁盘格式化<br>mkfs -t vfat /dev/sdx</p>
<p>3、磁盘格式化</p>
<p>   磁盘分区创建好以后就可以格式化磁盘，使用命令mkfs。如：<br>sudo mkfs -t vfat/dev/sdx<br>   把U盘拔了重插上去，防止报错</p>
<p>4、free  -h 查看内存 </p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>静态动态库的调用</title>
    <url>/C-C-Lover/%E6%80%81%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>动态库的调用？<br>GUC -T多轴运动控制器 dll。四轴参考手册<br>点位运动、Jog模式、电子齿轮运动（运动）、插补运动（联动）。<br>LIBS+=../lib/gts.dll<br>静态库、动态库存在于代码生成可执行文件的“链接”阶段。<br>.lib文件称作静态链接库，.dll文件称作动态链接库。（linux系统下对应的文件为.a文件及.so文件）<br>简单讲，静态库就是直接将需要的代码连接进可执行程序；<br>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。<br>做成静态库可执行文件本身比较大，但不必附带动态库；<br>做成动态库可执行文件本身比较小，但需要附带动态库。<br>LIBS += -LE:/project/QT/usbcan_info -lControlCAN   //通讯卡接口<br>LIBS  += ../lib/gts.dll<br>__declspec(dllexport)<br>Loadlibrary(“DllTestDll”)<br>SubFunc sub=(SubFunc)GetProcAddress(hDll“Sub”)<br>Freelibrary(hModule)</p>
<p>#ifdef __cplusplus<br>extern “C”<br>{<br>#endif<br>void func(void );</p>
<p>#ifdef __cplusplus<br>}<br>#endif</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C字符串常用函数</title>
    <url>/C-C-Lover/%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>字符串连接函数 strcat、strncat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char  a[10] = <span class="string">"123"</span>;</span><br><span class="line">char b[] = <span class="string">"456"</span>;</span><br><span class="line"></span><br><span class="line">strcat(a,b);//123456</span><br><span class="line">strncat(a,b,2);//1235</span><br></pre></td></tr></table></figure>

<p>字符串复制函数 strcpy、strncpy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strcpy(a,b);//123456</span><br><span class="line">strncpy(a,b,2);//1235</span><br></pre></td></tr></table></figure>
<p>字符串比较strcmp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcmp(str1,str2);</span><br></pre></td></tr></table></figure>
<p>字符长度strlen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strlen(str);</span><br></pre></td></tr></table></figure>
<p>字符分解strtok</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strtok函数的作用是把字符串以规定的字符分割开：</span><br><span class="line">p &#x3D; strtok(buf, &quot;@&quot;); </span><br><span class="line">p为指针，buf也是指针，这句代码的意思就是把buf中的字符串以&quot;@&quot;为分隔符分割保存到指针p中。</span><br><span class="line">再次调用strtok函数时，不需要再写buf。即：</span><br><span class="line">p &#x3D; strtok(NULL, &quot;@&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 操作随记</title>
    <url>/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令模式</span><br><span class="line"></span><br><span class="line">移动：首行gg 末行G</span><br><span class="line"></span><br><span class="line">复制：yy  粘贴p</span><br><span class="line"></span><br><span class="line">剪切：dd      留空剪切：D</span><br><span class="line"></span><br><span class="line">撤销：u   恢复：crtl +  r</span><br><span class="line"></span><br><span class="line">编辑模式（输入模式）</span><br><span class="line"></span><br><span class="line">i a     esc</span><br><span class="line"></span><br><span class="line">末行模式（尾行模式）。</span><br><span class="line"></span><br><span class="line">:w</span><br><span class="line"></span><br><span class="line">:q</span><br><span class="line"></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line">:q！</span><br><span class="line"></span><br><span class="line">：x   保存退出！！！！</span><br><span class="line"></span><br><span class="line">/ 查找</span><br><span class="line"></span><br><span class="line">：s/     g</span><br><span class="line"></span><br><span class="line">:%s/    g</span><br><span class="line"></span><br><span class="line">查看当前已经打开的文件名称：“:files”</span><br><span class="line">： esc    进入 退出</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/vim.jpg" class="">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随记命令(1)</title>
    <url>/Linux-Lover/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl +C    终止 <span class="built_in">cd</span> `</span><br><span class="line"></span><br><span class="line">df  -h      磁盘大小</span><br><span class="line"></span><br><span class="line">free -m     内存大小</span><br><span class="line"></span><br><span class="line">head -n  **.txt  文件头几行   默认10</span><br><span class="line"></span><br><span class="line">tail - n <span class="comment">##  ** .txt 文件末尾两行</span></span><br><span class="line"></span><br><span class="line">less 查看文件     ：q退出</span><br><span class="line"></span><br><span class="line"><span class="comment">#wc -lwc 统计文件内容信息（包含行数、单词数、字节数）</span></span><br><span class="line"></span><br><span class="line">         -l：表示lines，行数</span><br><span class="line"></span><br><span class="line">         -w：表示words，单词数  依照空格来判断单词数量</span><br><span class="line"></span><br><span class="line">         -c：表示bytes，字节数</span><br><span class="line"></span><br><span class="line">date 输出的形式：2018年3月24日星期六15:54:28</span><br><span class="line"></span><br><span class="line">date +%F 输出形式：2018-03-24</span><br><span class="line"></span><br><span class="line">date <span class="string">"+%F %T"</span>  ==输出的形式：2018-03-24 16:01:00</span><br><span class="line"></span><br><span class="line">==<span class="comment">#date “+%Y-%m-%d %H:%M:%S”</span></span><br><span class="line"></span><br><span class="line">date -d   <span class="string">"-1 day"</span>  <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"></span><br><span class="line">前天 -  后天 +</span><br><span class="line"></span><br><span class="line">cal  作用：用来操作日历的</span><br><span class="line"></span><br><span class="line">cal -1 本月</span><br><span class="line"></span><br><span class="line">cal -3 上 中 下</span><br><span class="line"></span><br><span class="line">cal   -y  2019 年份月历</span><br><span class="line"></span><br><span class="line">clear     / ctrl +L  清除终端</span><br><span class="line"></span><br><span class="line">ls   /  | wc<span class="_">-l</span>   管道的过滤使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls / |grep y</span></span><br><span class="line"></span><br><span class="line">hostname -f </span><br><span class="line"></span><br><span class="line">id  （包含用户id，用户组id，附加组id…）</span><br><span class="line"></span><br><span class="line">whoami   查看当前用户</span><br><span class="line"></span><br><span class="line">ps -ef 服务器进程   ps -ef  |grep http</span><br><span class="line"></span><br><span class="line">top 处理机资源占用情况</span><br><span class="line"></span><br><span class="line">du -sh 目录 查看目录大小</span><br><span class="line"></span><br><span class="line">service 服务名称  start stop  restart</span><br><span class="line"></span><br><span class="line">find  / -name      http    查找</span><br><span class="line"></span><br><span class="line">find  / -name      *.cof </span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 2986   killall 名称   杀死进程</span><br><span class="line"></span><br><span class="line">ifconfig      inet addr就是网卡的ip地址。</span><br><span class="line"></span><br><span class="line">reboot  启动</span><br><span class="line"></span><br><span class="line">shutdown   重启</span><br><span class="line"></span><br><span class="line">uptime 计算开机到现在的额时间</span><br><span class="line"></span><br><span class="line">uname  操作系统名称</span><br><span class="line"></span><br><span class="line">netstat -tnlp</span><br><span class="line"></span><br><span class="line">       -t：表示只列出tcp协议的连接；</span><br><span class="line"></span><br><span class="line">       -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</span><br><span class="line"></span><br><span class="line">       -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</span><br><span class="line"></span><br><span class="line">       -p：表示显示发起连接的进程pid和进程名称；</span><br><span class="line"></span><br><span class="line">man   cp 查看帮助文档</span><br><span class="line"></span><br><span class="line">软链接 （符号链接） ln -s   <span class="built_in">source</span>  target  </span><br><span class="line"></span><br><span class="line">硬链接 （实体链接）ln       <span class="built_in">source</span>  target</span><br><span class="line"></span><br><span class="line">Ctrl+s  阻止输入</span><br><span class="line"></span><br><span class="line">Ctrl+q  允许输入</span><br><span class="line"></span><br><span class="line">Ctrl + a/Home 切换到命令行开始</span><br><span class="line"></span><br><span class="line">Ctrl + e/End 切换到命令行末尾</span><br><span class="line"></span><br><span class="line"><span class="built_in">history</span> 显示你所有执行过的编号+历史命令</span><br><span class="line"></span><br><span class="line">!$ 显示系统最近的一条参数</span><br><span class="line">比如 cat /etc/sysconfig/network-scripts/ifconfig-eth0，想用 vim 编辑。</span><br><span class="line">一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命令。其实完全可以用 vim !$来代替</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>cron /crontab 计划任务</title>
    <url>/Linux-Lover/ron-crontab-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>分 时 日  月  星期</p>
<p>四个符号：</p>
<p>*：表示取值范围中的每一个数字</p>
<p>-：做连续区间表达式的，要想表示1~7，则可以写成：1-7</p>
<p>/：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：*/10</p>
<p>,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6</p>
<p>问题1：每月1、10、22日的4:45重启network服务</p>
<p>45 4  1,10,22  * *  service network restart</p>
<p>问题2：每周六、周日的1:10重启network服务</p>
<p>10 1  *  * 6,0   service network restart</p>
<p>问题3：每天18:00至23:00之间每隔30分钟重启network服务</p>
<p>*/30 18-23  *  * *   service network restart</p>
<p>问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启</p>
<p>3,15 8-11  */2  * *   reboot</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>解压磁盘</title>
    <url>/Linux-Lover/%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<p>bzip2</p>
<p>bzip2 -z xxx</p>
<p>bzip2 -d xxx.gz</p>
<p>tar</p>
<p>tar -vcjf xxx xxx   bz2</p>
<p>tar -vxjf xxxx</p>
<p>tar -vczf xxx xxx  压缩gz</p>
<p>tar -vxzf xxxx  解压</p>
<p>tar -vxzf xxxx（目录） -C xxx(路径)</p>
<p>rar</p>
<p>rar -a xxx.rar xxx   压缩</p>
<p>rar -x xxx.rar   解压</p>
<p>zip</p>
<p>zip -rv xxx.zip xxx   压缩</p>
<p>unzip -v xxx.zip   解压</p>
<p>unzip误解压使用以下命令补救：</p>
<p>zipinfo -1 ./(误解压文件) | xargs rm -rf<br>1<br>如果是tar误解则压使用以下命令补救：</p>
<p>tar -tf 误解压文件 | xargs rm -rf</p>
<p>格式.Z,文件名字为rr.Z<br>compress：压缩.Z文件<br>uncompress：解压缩.Z文件</p>
<p><strong>扩展硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">sudo fdisk - l</span><br><span class="line">sudo fdisk /dev/sda</span><br><span class="line">删除 分区：d</span><br><span class="line">新增 分区：n</span><br><span class="line">保存操作：w</span><br><span class="line">重启：reboot</span><br><span class="line">挂载磁盘</span><br><span class="line">在 home 下新建work作为这块磁盘挂载点</span><br><span class="line"><span class="comment"># mkdir  sda2</span></span><br><span class="line"><span class="comment"># sudo mount   /dev/sda2    /home/sda2</span></span><br><span class="line">设置开机磁盘自动挂载</span><br><span class="line"><span class="comment"># vi /etc/fstab</span></span><br><span class="line">添加行  /dev/sda2     /home/work   ext4   defaults, 0 1</span><br><span class="line">此时，磁盘已经挂好，查看挂好的磁盘</span><br></pre></td></tr></table></figure>
<p><strong>/dev/sda 磁盘不足</strong></p>
<p>#sudo apt-get autoclean<br> #sudo apt-get clean<br>#sudo apt-get autoremove<br>执行完后直接将/usr下释放了1G左右的空间。<br>整合碎片使用</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>工程师的修图工具——在线PS</title>
    <url>/Other-Lover/%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%BF%AE%E5%9B%BE%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E5%9C%A8%E7%BA%BFPS/</url>
    <content><![CDATA[<p><a href="https://www.photopea.com/" target="_blank" rel="noopener">https://www.photopea.com/</a></p>
<p>推荐<a href="https://ps.gaoding.com/#/" target="_blank" rel="noopener">https://ps.gaoding.com/#/</a></p>
<p>F键放大观看</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>基于MYSQL数据库的汽车销售管理应用——QT开发</title>
    <url>/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<hr>
<p>2020-1-26  ming   carmanage</p>
<hr>
<p>项目名称：基于MYSQL数据库的汽车销售管理应用。<br>项目介绍：安装Mysql将car.sql载入，通过界面控件的操作，文本显示汽车销售记录，<br>记录存在于demo.xml文件中，你可以可以通过安装notepad软件打开浏览。<br>同时，通过该项目学习调用并学习别人写好的类，显示条状统计图、扇形统计图等。<br>数据库格式：utf8 utf8_bin<br>github项目链接：<br>应用效果展示：</p>
<img src="/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/car%E6%95%B0%E6%8D%AE%E5%BA%93.png" class="">
<img src="/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/%E8%BD%A6%E8%BE%86%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2.png" class="">
<img src="/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/%E5%BD%93%E5%A4%A9%E9%94%80%E5%94%AE%E8%AE%B0%E5%BD%95%E6%98%BE%E7%A4%BA.png" class="">
<img src="/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/%E7%BB%9F%E8%AE%A1%E7%95%8C%E9%9D%A2.png" class="">
<img src="/MySql-Lover/%E5%9F%BA%E4%BA%8EMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B1%BD%E8%BD%A6%E9%94%80%E5%94%AE%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94QT%E5%BC%80%E5%8F%91/%E4%B8%AD%E8%8B%B1%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AF%95QvQ.png" class="">

<p>参考过网上资料，有幸能在黑马看到类似的开发，在此基础上自己又进一步了解使用QT语言家，中文翻译设置，基本功能的实现，打卡！QAQ班QAQ</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>设备地址</title>
    <url>/Linux-Lover/%E5%A4%87%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>电脑与板子连接路由（电脑连接Wifi）</p>
<p>192.168.0.128</p>
<p>192.168.0.255</p>
<p>255.255.255.0</p>
<p>00:0c:29:e3:61:25</p>
<p>板子</p>
<p>setenv ipaddr 192.168.0.50</p>
<p>setenv ethaddr 00:04:9f:04:d2:35</p>
<p>setenv gatewayip 192.168.0.1</p>
<p>setenv netmask 255.255.255.0</p>
<p>setenv serverip 192.168.0.128</p>
<p>saveenv</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>我的常用网站</title>
    <url>/Mechanic-Lover/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>米思米：<a href="https://www.misumi.com.cn/" target="_blank" rel="noopener">https://www.misumi.com.cn/</a></p>
<p>GABCAD:<a href="https://grabcad.com/" target="_blank" rel="noopener">https://grabcad.com/</a></p>
<p>论文：<a href="https://www.cn-ki.net/" target="_blank" rel="noopener">https://www.cn-ki.net/</a></p>
<p>ppt:<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a></p>
<p>音频下载：<a href="https://taira-komori.jpn.org/freesoundcn.html" target="_blank" rel="noopener">https://taira-komori.jpn.org/freesoundcn.html</a></p>
<p>壁纸：<a href="https://wallhaven.cc/w/mdzdok" target="_blank" rel="noopener">https://wallhaven.cc/w/mdzdok</a></p>
<p>在线PS:<a href="https://www.photopea.com/" target="_blank" rel="noopener">https://www.photopea.com/</a></p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>man手册</title>
    <url>/Linux-Lover/an%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h5 id="man"><a href="#man" class="headerlink" title="man"></a>man</h5><table>
<thead>
<tr>
<th align="center">代号</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Standard commands (标准命令)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">System calls (系统调用)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Libary functions （库函数）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Special device (设备说明)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">File formats (文件格式)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Game and toys (游戏娱乐)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">Miscellaneous (杂项)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Administrative commands(管理员命令)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">other  (存放内核文档)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32系统架构</title>
    <url>/MCU-Lover/m32%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>截图放博客，懒得翻文档 Q_Q</p>
<img src="/MCU-Lover/m32%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/stm32.jpg" class="">

<p>ICode 总线<br>DCode 总线：该总线将Cortex™-M3内核的DCode总线与闪存存储器的数据接口相连接(常量加载和调试访问)。<br>系统总线<br>DMA 总线<br>总线矩阵<br>AHB/APB 桥(APB)：两个AHB/APB桥在AHB和2个APB总线间提供同步连接。APB1操作速度限于36MHz，APB2操作于全速(最高72MHz)。</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32最小系统</title>
    <url>/MCU-Lover/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>值得参考：<a href="https://www.21ic.com/jichuzhishi/mcu/questions/2017-06-07/723582.html" target="_blank" rel="noopener">https://www.21ic.com/jichuzhishi/mcu/questions/2017-06-07/723582.html</a></p>
<img src="/MCU-Lover/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/stm32.jpg" class="">

<p>stm32低电平复位</p>
<p>PA9 PA10对应连接RXD TXD<br>烧录： 最小系统板boot0 置1 boot1置0<br>启动：最小系统板boot0 置0 boot1置0</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>555概念及使用</title>
    <url>/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="常见波形"><a href="#常见波形" class="headerlink" title="常见波形"></a>常见波形</h5><img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/555-2.jpg" class="">
<h5 id="单稳态触发器"><a href="#单稳态触发器" class="headerlink" title="单稳态触发器"></a>单稳态触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单稳态触发器----用于脉冲波形的变换和定时、延时 (74121、MC14528)</span><br><span class="line">Tw = 0.7 RC</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/3.jpg" class="" title="波形变换">
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/4.jpg" class="" title="定时">
<h5 id="多谐振荡器"><a href="#多谐振荡器" class="headerlink" title="多谐振荡器"></a>多谐振荡器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">多谐振荡器----用于产生脉冲，没有稳定状态，只有两个暂稳态，从而产生自激振荡，无需外触发。</span><br><span class="line">T=0.7(R1C1+R2C2)</span><br></pre></td></tr></table></figure>

<h5 id="施密特触发器"><a href="#施密特触发器" class="headerlink" title="施密特触发器"></a>施密特触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">施密特触发器----用于脉冲波形的变换，尤其是将模拟量转换成数字波形</span><br><span class="line">具有回差：有两个触发翻转电平。输入信号增加时，在VT+处翻转；输入信号减小时，在VT- 处翻转。VT+-VT-称为回差电压，用ΔVT表示，所以其传输特性呈回线状。</span><br><span class="line">无记忆功能：施密特触发器的稳态要靠外加触发电压维持，信号撤除会导致电路状态的改变。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/5.jpg" class="">
<h5 id="555定时器"><a href="#555定时器" class="headerlink" title="555定时器"></a>555定时器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以经过内部链接构成施密特触发器。</span><br><span class="line">它的作用可以整流，整幅，以及整波。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/1.jpg" class="">

<table>
<thead>
<tr>
<th align="center">引脚</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1脚</td>
<td align="left">外接电源负端VSS或接地，一般情况下接地。</td>
</tr>
<tr>
<td align="center">2脚</td>
<td align="left">低触发端TL，该脚电压小于1/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">3脚</td>
<td align="left">输出端OUT。</td>
</tr>
<tr>
<td align="center">4脚</td>
<td align="left">直接清零端RST。当此端接低电平时，则时基电路不工作</td>
</tr>
<tr>
<td align="center">5脚</td>
<td align="left">CO为控制电压端。若此脚外接电压，则可改变内部两个比较器的基准电压，当该脚不用时，应将该脚串入一只0.01μF（103）瓷片电容接地，以防引入高频干扰。</td>
</tr>
<tr>
<td align="center">6脚</td>
<td align="left">高触发端TH，该脚电压大于2/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">7脚</td>
<td align="left">放电端。该端与放电管T的集电极相连</td>
</tr>
<tr>
<td align="center">8脚</td>
<td align="left">双极型时基电路VCC的范围是4.5 -16V，CMOS型时基电路VCC的范围为3-18V，一般用5V。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>Solidworks与PCB的结合</title>
    <url>/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<p>偶然的一次发现QAQ</p>
<p>PCB电路板与solidworks的完美结合</p>
<img src="/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/solidworks.jpg" class="">


<p>转载[<a href="https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]" target="_blank" rel="noopener">https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]</a></p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数电概念</title>
    <url>/Circuit-Lover/%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机51、32、合泰芯片基本了解之后？以前觉得没怎么在意，为什么32芯片和合泰，使用时要使能相应的时钟？而51却不用？</span><br><span class="line"></span><br><span class="line">可是随着电子产品集成度越来越高，功耗和发热越来越严重</span><br><span class="line">芯片厂商非常无奈也在开始想办法避免这个问题，而最直接</span><br><span class="line">的思路当然就是用多少功能就使能多少功能，对每个外设的</span><br><span class="line">时钟都设置了开关，让用户可以精确地控制，关闭不需要的设备</span><br><span class="line">，达到节省供电的目的。</span><br><span class="line">其实这样还有一个好处就是，不是每个外设都需要系统时钟那么高的频率。</span><br><span class="line"></span><br><span class="line">仅仅理解为节省资源的方式感觉还不够，后来思考下，才发现答案就来自数电中的锁存器和触发器，然后，又开始复习了。。。QAQ</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>合泰杯项目-模仁自动化取放项目</title>
    <url>/Mechanic-Lover/%E6%B3%B0%E6%9D%AF%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E4%BB%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%96%E6%94%BE%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<img src="/Mechanic-Lover/%E6%B3%B0%E6%9D%AF%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E4%BB%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%96%E6%94%BE%E9%A1%B9%E7%9B%AE/%E5%90%88%E6%B3%B0%E6%9D%AF%E9%A1%B9%E7%9B%AE.jpg" class="">]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>继SolidWorks之后另一款3D软件的preo简单的学习</title>
    <url>/Mechanic-Lover/%E7%BB%A7SolidWorks%E4%B9%8B%E5%90%8E%E5%8F%A6%E4%B8%80%E6%AC%BE3D%E8%BD%AF%E4%BB%B6%E7%9A%84preo%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>1.组件中零件激活了之后要取消，直接ctrl+A即可。</p>
<p>2.颜色RGB</p>
<p>255  0  0  红色</p>
<p>248  255  247  白色</p>
<p>0     0    0  黑色</p>
<p>银白色  红(192) 绿(192) 蓝(192)。</p>
<p>染色过程中，高级的层次会覆盖掉低级的颜色</p>
<p>例如：总装配体&gt;子装配体&gt;零件</p>
<p>3.通过不定向，横截面的设置获取“正视于的效果”，配合参考选取视图。</p>
<p>4.仿真看着很单调，不过可以通过数据或者数学方程式驱动运动的轨迹，存在一个数据文档里；</p>
<p>钣金加工工艺（综合冷加工工艺）</p>
<p>下料 、成型、压铆，攻牙、焊接等</p>
<p>表面处理：喷粉，电镀等；</p>
<p>机床的知识<br>NC：数字控制，简称数控。<br>CNC：计算机数字控制，简称也是数控。NC是以前的数控，CNC是目前的数控，NC已经淘汰。另外，人们经常把加工中心叫做CNC。<br>DNC：在线加工。也就是一边传输程序，一边加工，用电脑控制数控机床在线加工。<br>2019-1-9 ming</p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统分类</title>
    <url>/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="Linux系统分类"><a href="#Linux系统分类" class="headerlink" title="Linux系统分类"></a>Linux系统分类</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一般来说，linux系统基本分为两大类</span><br><span class="line">Redhat系列:Redhat、Centos、Fedora等</span><br><span class="line">Debian系列:Debian、Ubuntu等</span><br></pre></td></tr></table></figure>

<h5 id="Redhat系列"><a href="#Redhat系列" class="headerlink" title="Redhat系列"></a>Redhat系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">商业用途，企业版，一般付费。</span><br><span class="line">rmp:包安装工具</span><br><span class="line">yum:程序与程序之间存在非常复杂的依赖关系。RPM无法解决软件包的依赖关系。</span><br></pre></td></tr></table></figure>

<h5 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">社区维护，桌面版，一般免费。</span><br><span class="line">dpkg:包安装工具</span><br><span class="line">apt-get:会解决和安装模块的依赖问题</span><br></pre></td></tr></table></figure>
<h5 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h5><img src="/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/example.jpg" class="">


<p>了解RTOS<br>实时操作系统，实时性。</p>
<p>“硬实时”操作系统任务必须在确定的时间完成。<br>“软实时”操作系统能让绝大多数任务在确定时间完成。</p>
<p>操作需求</p>
<p>连接需求：不同协议<br>组网需求：自发现自连接<br>管理需求：不同传感器接入和算法管理。</p>
<p>参考Huawei LiteOS</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>模电概念</title>
    <url>/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h6 id="放大电路"><a href="#放大电路" class="headerlink" title="放大电路"></a>放大电路</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">放大电路模型:电压放大电路、电流放大电路</span><br><span class="line">放大电路的性能：输入电阻、输出电阻、增益、频率响应及带宽。</span><br></pre></td></tr></table></figure>
<h6 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同相电路</span><br><span class="line">反相电路</span><br><span class="line">求和电路</span><br><span class="line">求差电路</span><br><span class="line">差分电路</span><br><span class="line">积分电路</span><br><span class="line">微分电路</span><br><span class="line">·····</span><br></pre></td></tr></table></figure>
<h5 id="晶体三极管及其基本放大电路（BJT）"><a href="#晶体三极管及其基本放大电路（BJT）" class="headerlink" title="晶体三极管及其基本放大电路（BJT）"></a>晶体三极管及其基本放大电路（BJT）</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">外部条件：发射结正偏，集电结反偏</span><br><span class="line">共发射极、共基极、共集电极</span><br></pre></td></tr></table></figure>
<h5 id="场效应三极管及其放大电路"><a href="#场效应三极管及其放大电路" class="headerlink" title="场效应三极管及其放大电路"></a>场效应三极管及其放大电路</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">沟道中只有一种类型的载流子参与导电，所以场效应管也称为单极型三极管。</span><br><span class="line">共源极、共栅极、共源极</span><br></pre></td></tr></table></figure>
<h4 id="模拟开关与多路复用器区别"><a href="#模拟开关与多路复用器区别" class="headerlink" title="模拟开关与多路复用器区别"></a>模拟开关与多路复用器区别</h4><p>对信号通路进行选择，或者档位切换，想问模拟通道开关和多路复用器有什么区别？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">模拟开关和多路复用器件其实在电气上，或者架构上，原理上没什么区别。</span><br><span class="line">多路复用的话主要用在通道数比较多的场合，例如：4输入1输出，16输入1输出。</span><br><span class="line">模拟/数字开关主要用于通道数目比较小的。低导通电阻，根据应用需求不同；模拟开关可以分为音频模拟开关、视频模拟开关。</span><br></pre></td></tr></table></figure>
<h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><h5 id="MOS、NMOS、PMOS、COMS概念"><a href="#MOS、NMOS、PMOS、COMS概念" class="headerlink" title="MOS、NMOS、PMOS、COMS概念"></a>MOS、NMOS、PMOS、COMS概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MOS管导通特性，相当于开关闭合。</span><br><span class="line">NMOS的特性，Vgs大于一定的值就会导通，适合用于源极接地时的情况，只要栅极电压达到4V或10V就可以了。导通电阻小，且容易制造，市场广泛应用。</span><br><span class="line">PMOS的特性，Vgs小于一定的值就会导通，适合用于源极接VCC时的情况。导通电阻大，价格贵，替换种类少，通常还是使用NMOS。</span><br><span class="line">CMOS的产生？</span><br><span class="line">一、阈值损</span><br><span class="line">NMOS 传输高电平有阈值损（Vtn），低电平则没有；</span><br><span class="line">PMOS 传输低电平有阈值损（Vtp），高电平则没有。</span><br><span class="line">CMOS 互补结构则利用了上述“互补”特性，传输高低电平时都没有阈值损。</span><br><span class="line">二、线性</span><br><span class="line">NMOS 或 PMOS 单管。</span><br><span class="line">利用两管导通电流的“互补”特性，使得导通电流特性呈“高线性”。</span><br><span class="line">三、功耗</span><br><span class="line">主要差别在功耗上，NMOS和PMOS工作时至少有一个导通，而CMOS导通的时间很短，功耗明显降低</span><br></pre></td></tr></table></figure>
<h4 id="CMOS-与-TTL"><a href="#CMOS-与-TTL" class="headerlink" title="CMOS 与 TTL"></a>CMOS 与 TTL</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMOS是场效应晶体管，TTL是双极晶体管2。</span><br><span class="line">COMS具有较宽的逻辑电平范围（5-15V），TTL只能在5V下工作。</span><br><span class="line">CMOS的高低电平差异较大，抗干扰能力强，TTL差小，抗干扰能力差。</span><br><span class="line">CMOS功耗很小，TTL功耗大（1-5mA/门）</span><br><span class="line">CMOS的工作频率略低于TTL，但其高速CMOS几乎与TTL相同。</span><br><span class="line">TTL高电平3.6~5V，低电平0V~2.4V_</span><br><span class="line">CMOS电平VCC可达到12V_</span><br><span class="line">CMOS电路的高电平输出约为0.9VCC，低电平输出约为0.1VCC。</span><br><span class="line">CMOS电路不使用的输入端不能挂起，会引起逻辑混乱。</span><br><span class="line">TTL电路不使用的输入端空旷为高电平_</span><br><span class="line">另外，由于CMOS集成电路的电源电压变化范围大，对电源的要求不如TTL集成电路严格。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
</search>
