<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+gitee</title>
    <url>/Other-Lover/xo-gitee/</url>
    <content><![CDATA[<p>github网速不够快，换成gitees试试？</p>
<p><a href="https://gitee.com/hsm0409/hsm0409.git" target="_blank" rel="noopener">https://gitee.com/hsm0409/hsm0409.git</a><br>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p>如果同时部署：</p>
<p>先关联GitHub的远程库：<br>git remote rm origin<br>git remote add github <a href="mailto:git@github.com">git@github.com</a>:hsm0409/hsm0409.github.io.git<br>接着，再关联Gitee的远程库：<br>git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p>如果要推送到GitHub，使用命令：<br>git push github master<br>如果要推送到Gitee，使用命令：<br>git push gitee master</p>
<p> git push -u origin master</p>
<p>不错的参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712</a></p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+github</title>
    <url>/Other-Lover/hexo-github/</url>
    <content><![CDATA[<p>换电脑或者换系统重新部署hexo</p>
<p>ssh-keygen -t rsa -C “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>   </p>
<p>git config –global user.name “hsm0409”  </p>
<p>//有时候系统没.ssh/id_rsa.pub，输入命令ssh-keygen -o<br>//生成新的密钥</p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a>      //ssh密钥</p>
<p>yes</p>
<p> git config –global user.email “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>“</p>
<p> git config –global user.name “hsm0409”</p>
<p> 就可以了。</p>
<p> //详细参考<a href="https://blog.annieyu.com/posts/207737771.html" target="_blank" rel="noopener">https://blog.annieyu.com/posts/207737771.html</a></p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>使用PE系统重装win10QvQ</title>
    <url>/uncategorized/%E7%94%A8PE%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85win10QvQ/</url>
    <content><![CDATA[<p><strong>1、工具：U盘+白菜PE系统</strong>   </p>
<p><strong>2、系统：win10 解压放在U盘 GHO 目录下。</strong></p>
<p><strong>3、电脑关机，开机启动按住“esc”,选择进入U盘，进入PE系统，我们可以先备份好C盘的资料到其他U盘中，然后点击C盘，还原分区，选择U盘中GHO目录下的镜像文件.gho,点击确定即可。</strong></p>
<p><strong>4、拔出U盘，重启电脑。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>ioctl函数</title>
    <url>/Linux-Lover/ctl%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>ioctl 系统调用主要用于增加系统调用的硬件控制能力，它可以构建自己的命令，也能接受参数.<br>应用程序 ioctl 函数<br>int ioctl (int fd, unsigned long cmd, arg)<br>fd 是被打开的设备文件， cmd 是操作设备的命令，“ …”代表可变数目的参数表，通常用 char *argp 来定义，如果 cmd 命令不需要参数，则传入 NULL 即可。</p>
<p>内核空间 iotcl 函数<br>int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);</p>
<p>ioctl 操作与硬件平台相关，使用 ioctl 的驱动需要包含&lt;linux/ioctl.h&gt;文件。每个 ioctl 命令cmd实际上都是一个 32 位整型数，各字段和含义如下表所示。<br>已经被使用的幻数列表详见内核源码目录Documentation/ioctl/ioctl-number.txt文件。</p>
<p>|一般形式<br>|-|-|<br>|_IO(type,nr) 构造无参数的命令编号<br>|_IOW(type,nr,size) 构造往驱动写入数据的命令编号<br>|_IOR(type,nr,size) 构造从驱动中读取数据的命令编号<br>|_IOWR(type,nr,size)构造双向传输的命令编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line">/*0XFE---幻数，1.2.3.---功能号*/</span><br><span class="line">/*IOctrl 命令*/</span><br><span class="line"><span class="comment">#define CLOSE_CMD (_IO(0XEF, 0x1)) /* 关闭定时器 */</span></span><br><span class="line"><span class="comment">#define OPEN_CMD (_IO(0XEF, 0x2)) /* 打开定时器 */</span></span><br><span class="line"><span class="comment">#define SETPERIOD_CMD (_IO(0XEF, 0x3)) /* 设置定时器周期命令 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TIMER_NAME  "timer"</span></span><br><span class="line"><span class="comment">#define TIMER_CNT  1</span></span><br><span class="line">struct timer_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid;</span><br><span class="line"></span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct device_node *nd;</span><br><span class="line">    struct class * class;</span><br><span class="line">    struct device * device;</span><br><span class="line"></span><br><span class="line">    int led_gpio;</span><br><span class="line">    int timeperiod;</span><br><span class="line">    struct timer_list timer;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct timer_dev timer;</span><br><span class="line"></span><br><span class="line">static int led_init (struct timer_dev * dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    dev-&gt;nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;nd == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;led_gpio = of_get_named_gpio(dev-&gt;nd,<span class="string">"led-gpios"</span>,0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;led_gpio &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't get led \r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*申请注册IO*/</span><br><span class="line"></span><br><span class="line">    gpio_request(dev-&gt;led_gpio,<span class="string">"led"</span>);</span><br><span class="line"></span><br><span class="line">    ret = gpio_direction_output(dev-&gt;led_gpio,1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't set gpion\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int timer_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;timer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static long timer_unlocked_ioctl(struct file *filp, unsigned int cmd,</span><br><span class="line">						unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        struct timer_dev *dev = (struct timer_dev *)filp-&gt;private_data;</span><br><span class="line">        int ret  = 0;</span><br><span class="line">        int timeperiod ;</span><br><span class="line">        unsigned long flags;</span><br><span class="line">        switch (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CLOSE_CMD:</span><br><span class="line">                del_timer(&amp;dev-&gt;timer);</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> OPEN_CMD:</span><br><span class="line">                spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">                timeperiod = dev-&gt;timeperiod;</span><br><span class="line">                spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line">                mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> SETPERIOD_CMD:</span><br><span class="line">            dev-&gt;timeperiod = arg;</span><br><span class="line">            mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg));</span><br><span class="line">            <span class="built_in">break</span> ;     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int timer_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct file_operations timer_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">    .open  = timer_open ,</span><br><span class="line">    .release = timer_release,</span><br><span class="line">	.unlocked_ioctl	= timer_unlocked_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void  timer_function(unsigned long arg )</span><br><span class="line">&#123;</span><br><span class="line">    struct timer_dev *dev = (struct timer_dev*)arg;</span><br><span class="line">    static int sta = 1 ;</span><br><span class="line">    int timeperiod;</span><br><span class="line">     unsigned long flags;</span><br><span class="line">    sta = !sta ;</span><br><span class="line">    gpio_set_value(dev-&gt;led_gpio,sta);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">     timeperiod = dev-&gt;timeperiod;</span><br><span class="line">     spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line"></span><br><span class="line">   mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init timer_init(void )</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    </span><br><span class="line">    spin_lock_init(&amp;timer.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer.major)</span><br><span class="line">    &#123;</span><br><span class="line">    timer.devid = MKDEV(timer.devid,0);</span><br><span class="line">    register_chrdev_region(timer.devid,TIMER_CNT,TIMER_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;timer.devid, 0, TIMER_CNT,TIMER_NAME);</span><br><span class="line">        timer.major = MAJOR(timer.devid);</span><br><span class="line">        timer.minor = MINOR(timer.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    timer.cdev.owner = THIS_MODULE ;</span><br><span class="line">	cdev_init(&amp;timer.cdev, &amp;timer_fops);</span><br><span class="line">    cdev_add(&amp;timer.cdev, timer.devid,TIMER_CNT);</span><br><span class="line">	</span><br><span class="line">    /*自动设备节点*/</span><br><span class="line">    timer.class = class_create(THIS_MODULE, TIMER_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.class))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.class);</span><br><span class="line"></span><br><span class="line">    timer.device = device_create(timer.class, NULL, timer.devid, NULL, TIMER_NAME);</span><br><span class="line">				  </span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.device))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.device);</span><br><span class="line"></span><br><span class="line">        ret  = led_init(&amp;timer);</span><br><span class="line">        <span class="keyword">if</span>(ret  &lt;  0)</span><br><span class="line">        &#123;</span><br><span class="line">            goto fail_ledinit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    init_timer(&amp;timer.timer);</span><br><span class="line">    timer.timer.function = timer_function;</span><br><span class="line">    timer.timer.data = (unsigned long ) &amp; timer;</span><br><span class="line">    timer.timer.expires = jiffies + msecs_to_jiffies(5000);/*500ms*/</span><br><span class="line">    add_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0 ;</span><br><span class="line"></span><br><span class="line">    fail_ledinit:</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit timer_exit(void )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    gpio_set_value(timer.led_gpio,1);</span><br><span class="line">    del_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;timer.cdev);</span><br><span class="line">    unregister_chrdev_region(timer.devid,TIMER_CNT);</span><br><span class="line">    device_destroy(timer.class,timer.devid);</span><br><span class="line">    class_destroy(timer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ioctl(fd,cmd,arg);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核定时器</title>
    <url>/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p><strong>节拍率</strong><br>中断周期性产生的频率就是系统频率，<br>也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz<br>高节拍率和低节<br>拍率的优缺点：<br>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。<br>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz的系统节拍率相比，中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率，本教程我们全部采用默认的 100Hz 系统节拍率。<br>方法一：make menuconfig<br>-&gt; Kernel Features<br>-&gt; Timer frequency (<choice> [=y])<br>方法二： param.h文件 # define USER_HZ    100    </p>
<p><strong>节拍数 jiffies</strong></p>
<p>extern u64 __jiffy_data jiffies_64; /<em>64系统</em>/<br>extern unsigned long volatile __jiffy_data jiffies;/<em>32系统</em>/</p>
<p>不管是 32 位还是 64 位的 jiffies，都有溢出的风险<br>假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 为的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。</p>
<p> HZ 表示一秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies/HZ 就<br>是系统运行时间，单位为秒。</p>
<img src="/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E8%8A%82%E6%8B%8D%E5%87%BD%E6%95%B0.jpg" class="">


<p>timer.h总结构体 timer_list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">struct list_head entry;</span><br><span class="line">unsigned long expires; /* 定时器超时时间，单位是节拍数 */</span><br><span class="line">struct tvec_base *base;</span><br><span class="line">void (*<span class="keyword">function</span>)(unsigned long); /* 定时处理函数 */</span><br><span class="line">unsigned long data; /* 要传递给 <span class="keyword">function</span> 函数的参数 */</span><br><span class="line">int slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list timer; /* 定义定时器 */</span><br><span class="line">/* 定时器回调函数 */</span><br><span class="line"> void <span class="keyword">function</span>(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">* 定时器处理代码</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* 如果需要定时器周期性运行的话就使用 mod_timer</span><br><span class="line"> * 函数重新设置超时值并且启动定时器。</span><br><span class="line"> */</span><br><span class="line"> mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(2000));</span><br><span class="line"> &#125;</span><br><span class="line"> /* 初始化函数 */</span><br><span class="line"> void init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> init_timer(&amp;timer); /* 初始化定时器 */</span><br><span class="line"></span><br><span class="line"> timer.function = <span class="keyword">function</span>; /* 设置定时处理函数 */</span><br><span class="line"> timer.expires=jffies + msecs_to_jiffies(2000);/* 超时时间 2 秒 */</span><br><span class="line"> timer.data = (unsigned long)&amp;dev; /* 将设备结构体作为参数 */</span><br><span class="line"></span><br><span class="line">add_timer(&amp;timer); /* 启动定时器 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 退出函数 */</span><br><span class="line"> void <span class="built_in">exit</span>(void)</span><br><span class="line"> &#123;</span><br><span class="line"> del_timer(&amp;timer); /* 删除定时器 */</span><br><span class="line"> /* 或者使用 */</span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">参考正点原子</span><br></pre></td></tr></table></figure>
<p><strong>纳秒、微秒和毫秒延时函数</strong><br>void ndelay(unsigned long nsecs)<br>void udelay(unsigned long usecs)<br>void mdelay(unsigned long mseces)</p>
]]></content>
  </entry>
  <entry>
    <title>Uboot常用命令</title>
    <url>/Linux-Lover/oot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>2.1、help命令</strong></p>
<p>查看某一个命令帮助信息，？命令名</p>
<p><strong>2.2、信息查询</strong></p>
<p>1、bdinfo 板子信息<br>2、printenv命令 重要</p>
<p><strong>2.3、setenv命令</strong></p>
<p>设置环境变量，也可以自定义环境变量，也可以删除环境变量<br>setenv xx = 空<br><strong>2.4、saveenv命令 重点</strong><br> 保存环境变量。</p>
<p> <strong>2.5、内存操作命令</strong></p>
<p> （.b 一个字节,.w两个字节，.l四个字节）<br>1、md命令   显示<br>2、nm命令  写入<br>3、mm命令  持续写入<br>4、mw命令   填充写入 mw.l 0a0a0a0a 10(0x10即为16个)<br>5、cp命令   复制<br>6、cmp命令   只输出一样与否</p>
<p><strong>2.8、网络操作命令</strong><br>网线插如到ENET2上，保证开发板和电脑处于同一个网段内。</p>
<p>1、ping命令 重点</p>
<p>2、dhcp命令</p>
<p>3、nfs命令 重点</p>
<p>4、tftp命令 重点</p>
<p><strong>2.9 EMMC/SD卡操作命</strong></p>
<p>1、mmc命令</p>
<p>2、mmc info命令</p>
<p>3、mmc rescan命令</p>
<p>4、mmc list命令</p>
<p>5、mmc dev命令</p>
<p>6、mmc part命令</p>
<p>7、mmc read命令</p>
<p>8、mmc write命令</p>
<p>9、mmc erase命令最好不要使用！！</p>
<p><strong>2.10 FAT格式文件系统操作命令</strong></p>
<p> 对于I.MX6U来说，SD/EMMC分为三个分区：<br>第一个：存放uboot<br>第二个:存放Linux zImage，.dtb。FAT<br>第三个：系统的根文件系统，EXT4</p>
<p>1、fatinfo命令</p>
<p>2、fatls命令</p>
<p>3、fstype命令</p>
<p>4、fatload命令</p>
<p>5、fatwrite命令</p>
<p><strong>2.11 EXT格式文件系统操作命令</strong></p>
<p>1、ext4ls命令(略)</p>
<p>2.13 BOOT操作命令</p>
<p>1、booz命令<br>要启动Linux必须将zImage，dtb放到DRAM。</p>
<p>2、bootm命令</p>
<p>3、boot命令</p>
<p>2.14 其他命令</p>
<p>1、reset命令</p>
<p>2、go命令</p>
<p>3、run命令</p>
<p>setenv mybooyemmc</p>
<p>run mybootemmc</p>
<p>4、mtest命令</p>
<h4 id="IMX6ULL-我的常用小记"><a href="#IMX6ULL-我的常用小记" class="headerlink" title="IMX6ULL 我的常用小记"></a>IMX6ULL 我的常用小记</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bootcmd 的 默 认 值 就 是 CONFIG_BOOTCOMMAND </span><br><span class="line">bootargs 的 默 认 值 就 是CONFIG_BOOTARGS</span><br><span class="line"></span><br><span class="line">4.1 从EMMC启动</span><br><span class="line"></span><br><span class="line">1、首先查看EMMC里面是否有系统，linux镜像zImage和.dtb文件。先将当前设备切换到EMMC：</span><br><span class="line"></span><br><span class="line">mmc dev 1     &#x2F;&#x2F;切换到EMMC  mmc dev 0 SD 卡</span><br><span class="line"></span><br><span class="line">fatls mmc 1:1  &#x2F;&#x2F;查看EMMC分区1里面的文件</span><br><span class="line">fatload mmc 1:1 80800000 zImage &#x2F;&#x2F;将zimage下载到DDR的0x80800000处</span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;将dtb读取到0X83000000</span><br><span class="line">bootz 80800000 – 83000000 &#x2F;&#x2F;启动内核</span><br><span class="line"></span><br><span class="line">如果内核启动成功，说明uboot支持emmc启动，验证成功。</span><br><span class="line"></span><br><span class="line">4.2 从网络启动</span><br><span class="line"></span><br><span class="line"> tftp 80800000 zImage         &#x2F;&#x2F;从tftp服务器下载zimage</span><br><span class="line"> tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;从tftp服务器下载.dtb     </span><br><span class="line"> bootz 80800000 – 83000000 &#x2F;&#x2F;启动系统</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;系统烧写</span><br><span class="line">tftp   确保开启！！！！不要从外不复制粘贴，会乱码</span><br><span class="line"></span><br><span class="line">set bootcmd  &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-ming-emmc.dtb;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">tftp 80800000 zImage</span><br><span class="line"></span><br><span class="line">tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 80800000 zImage</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dt;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">saveenv</span><br><span class="line"></span><br><span class="line">boot</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">tftp 87800000 uart.bin</span><br><span class="line"></span><br><span class="line">go 87800000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">grep -nr  xxxx</span><br><span class="line"></span><br><span class="line">查找当前目录下包含关键字“NEON”的所有文件，并列出行号。</span><br><span class="line"></span><br><span class="line">QAQ--------&#x2F;修改bootargs进入根系统&#x2F;----------</span><br><span class="line"></span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.0.128:&#x2F;home&#x2F;ming&#x2F;linux&#x2F;nfs&#x2F;rootfs ip&#x3D;192.168.0.50:192.168.0.128:192.168.0.1:255.255.255.0::eth0:off&#39;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统根目录空间不足</title>
    <url>/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/1.jpg" class="">


<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/2.jpg" class="">





<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/4.jpg" class="">

<p>参考<br><a href="https://blog.csdn.net/daemon_2017/article/details/80660372" target="_blank" rel="noopener">https://blog.csdn.net/daemon_2017/article/details/80660372</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库完整性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<p><strong>数据库的完整性</strong></p>
<p>数据库的正确性和相容性。</p>
<p>注：数据的完整性和安全性是两个不同概念<br>数据的完整性<br>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据<br>防范对象：不合语义的、不正确的数据<br>数据的安全性<br>保护数据库防止恶意的破坏和非法的存取<br>防范对象：非法用户和非法操作</p>
<p>为维护数据库的完整性，DBMS必须：<br>1.提供定义完整性约束条件的机制<br>2.提供完整性检查的方法<br>3.违约处理</p>
<p><strong>实体完整性</strong></p>
<p>定义为列级约束条件     (Sno  CHAR(9)  PRIMARY KEY<br>定义为表级约束条件     PRIMARY KEY (Sno)</p>
<p><strong>参照完整性</strong></p>
<p> FOREIGN KEY (Cno) REFERENCES Course(Cno)    </p>
<p><strong>用户定义的完整性</strong></p>
<p>列值非空（NOT NULL）<br>列值唯一（UNIQUE）<br>检查列值是否满足一个布尔表达式（CHECK）<br> CHECK (Ssex=’女’ OR Sname NOT LIKE ‘Ms.%’)</p>
<p><em>_完整性约束命名字句</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONSTRAINT &lt;完整性约束条件名&gt;</span><br><span class="line">［PRIMARY KEY短语</span><br><span class="line">   |FOREIGN KEY短语</span><br><span class="line">   |CHECK短语］</span><br><span class="line"></span><br><span class="line">可以先删除原来的约束条件，再增加新的约束条件</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999)，</span><br></pre></td></tr></table></figure>
<p><strong>域中的完整性限制</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">［例15］建立一个性别域GenderDomain，并对其中的限制命名</span><br><span class="line">           CREATE DOMAIN GenderDomain CHAR(2)</span><br><span class="line">           CONSTRAINT GD CHECK ( VALUE IN (<span class="string">'男'</span>，<span class="string">'女'</span>) );</span><br><span class="line"></span><br><span class="line">在域GenderDomain上增加限制条件GDD。</span><br><span class="line">          ALTER  DOMAIN  GenderDomain  </span><br><span class="line">         ADD CONSTRAINT GDD CHECK (VALUE IN ( <span class="string">'1'</span>，<span class="string">'0'</span>) ); </span><br><span class="line">	就把性别的取值范围由(<span class="string">'男'</span>，<span class="string">'女'</span>)改为 ( <span class="string">'1'</span>，<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>触发器</strong></p>
<p>定义触发器 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER语法格式</span><br><span class="line">	   </span><br><span class="line">	  CREATE TRIGGER &lt;触发器名&gt;  </span><br><span class="line">       &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">        FOR EACH  &#123;ROW | STATEMENT&#125;</span><br><span class="line">      ［WHEN &lt;触发条件&gt;］</span><br><span class="line">        &lt;触发动作体&gt;</span><br><span class="line"></span><br><span class="line">［例18］  定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</span><br><span class="line">    CREATE TRIGGER Insert_Or_Update_Sal </span><br><span class="line">         BEFORE INSERT OR UPDATE ON Teacher  </span><br><span class="line">        /*触发事件是插入或更新操作*/</span><br><span class="line">         FOR EACH ROW                      /*行级触发器*/</span><br><span class="line">        AS BEGIN                                  /*定义触发动作体，是PL/SQL过程块*/</span><br><span class="line">              IF (new.Job=<span class="string">'教授'</span>) AND (new.Sal &lt; 4000) THEN   </span><br><span class="line">              new.Sal :=4000;                </span><br><span class="line">              END IF;</span><br><span class="line">        END;</span><br></pre></td></tr></table></figure>


<p>激活触发器<br>同一个表上的多个触发器激活时遵循如下的执行顺序：<br>（1） 执行该表上的BEFORE触发器；<br>（2） 激活触发器的SQL语句；<br>（3） 执行该表上的AFTER触发器。</p>
<p>删除触发器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">DROP TRIGGER Insert_Sal ON Teacher;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>union的用法及应用场景</title>
    <url>/C-C-Lover/nion%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>union的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">大小一块内存选最大的那个声明。</span><br><span class="line">struct&#123;</span><br><span class="line">	char name[20];</span><br><span class="line">    int num ;</span><br><span class="line">    char sex;</span><br><span class="line">    char profession;</span><br><span class="line">    union &#123;</span><br><span class="line">    <span class="built_in">float</span> score;</span><br><span class="line">    char course[20];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>共用体还真是贴切——完全就是共用一个内存首地址。<br>nion成员共享同一块大小的内存，一次只能使用其中的一个成员；<br>应用场景：</p>
<p>1、一个学生与老师的数据表中，有一项共用的（老师所教课程与学生课程分数）<br>2、union量的存放顺序是所有成员都从低地址开始存放的，可以用来判断大端和小端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int checkCPU()</span><br><span class="line">&#123;</span><br><span class="line">     union cpu</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        char b;</span><br><span class="line">     &#125;c;</span><br><span class="line">    c.a = 1;</span><br><span class="line">    <span class="built_in">return</span> ( c.b == 1 );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器算法小结</title>
    <url>/C-C-Lover/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>头文件</strong><br>#include <algorithm> //算法<br>#include <numeric> //数学<br>#include <functional>//模板<br>#include <memory>//智能指针 auto_ptr</p>
<p><strong>概念</strong><br>一元函数对象：函数参数1个；<br>二元函数对象：函数参数2个；<br>一元谓词对象：函数参数1个,返回bool；<br>二元谓词对象：函数参数2个,返回bool；</p>
<p>遍历算法 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">for_each(v1.begin(),v1.end(), show)   //容器为int</span><br><span class="line"></span><br><span class="line">void show(const int &amp;iItem)  </span><br><span class="line"></span><br><span class="line">&#123;         cout&lt;&lt; iItem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">transform() //转移容器，用于合并，函数返回值</span><br><span class="line">transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase);      </span><br><span class="line">int increase (int i) </span><br><span class="line"></span><br><span class="line">&#123;     <span class="built_in">return</span> i+1;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找算法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adjacent_find()；查找相邻重复元素，返回指向这对元素的第一个元素的迭代器。</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt;::iterator it = adjacent_find(v.begin(),vend());</span><br><span class="line"></span><br><span class="line">binary_search（）;在有序序列中查找value,无序不可</span><br><span class="line"></span><br><span class="line">bool bFind = binary_search(setInt.begin(),setInt.end(),5);</span><br><span class="line"></span><br><span class="line">count（）；计算个数</span><br><span class="line"></span><br><span class="line">intiCount = count(vecInt.begin(),vecInt.end(),2);  </span><br><span class="line"></span><br><span class="line">count_if()；</span><br><span class="line"></span><br><span class="line">bool GreaterThree(int iNum)</span><br><span class="line"></span><br><span class="line">&#123;  <span class="keyword">if</span>(iNum&gt;=3)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int iCount = count_if(vecIntA.begin(),vecIntA.end(), GreaterThree);</span><br><span class="line"></span><br><span class="line">find()；find顺序查找O(n)</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5);</span><br><span class="line"></span><br><span class="line">find_if()；</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree);</span><br></pre></td></tr></table></figure>
<p>排序算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">merge();合并排序</span><br><span class="line"></span><br><span class="line">merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin();</span><br><span class="line"></span><br><span class="line">sort();内省排序O(n*log2n)</span><br><span class="line"></span><br><span class="line">sort(vecStu.begin(),vecStu.end(),Compare);//bool()函数</span><br><span class="line"></span><br><span class="line">random_shuffle();随机排序</span><br><span class="line"></span><br><span class="line">random_shuffle(str.begin(),str.end());   </span><br><span class="line"></span><br><span class="line">reverse()；反序</span><br><span class="line"></span><br><span class="line">拷贝和替换算法</span><br><span class="line"></span><br><span class="line">copy()；</span><br><span class="line"></span><br><span class="line">replace()；</span><br><span class="line"></span><br><span class="line">replace(vecIntA.begin(), vecIntA.end(), 3,8);          //（1,3，5,3,9）&#123;1,8,5,8,9&#125;</span><br><span class="line"></span><br><span class="line">replace_if(vecIntA.begin(),vecIntA.end(), GreaterThree, 8);           </span><br><span class="line"></span><br><span class="line">swap();</span><br><span class="line"></span><br><span class="line">swap(vecIntA,vecIntB);</span><br></pre></td></tr></table></figure>

<p>算术和生成算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accumulate()；</span><br><span class="line"></span><br><span class="line">int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100);</span><br><span class="line"></span><br><span class="line">fill()；</span><br><span class="line"></span><br><span class="line"> fill(vecIntA.begin(), vecIntA.end(),8);</span><br></pre></td></tr></table></figure>
<p>集合算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">set_union()  并集有序</span><br><span class="line"></span><br><span class="line">set_intersection()交集有序</span><br><span class="line"></span><br><span class="line">set_difference()第一个有第二个没有的差集</span><br><span class="line"></span><br><span class="line">set_difference(vecIntA.begin(), vecIntA.end(),vecIntB.begin(), vecIntB.end(), vecIntC.begin());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器结构小结</title>
    <url>/C-C-Lover/%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>vector 单端，尾插</p>
<p>deque 双端，首部尾部插</p>
<p>stack  先进后出（deques首部闭合）  pop push</p>
<p>quece 队列，先进先出          </p>
<p>list   链表，随时插入</p>
<p>set 唯一值，数值顺序排顺序</p>
<p>map/multimap    关联式map&lt;T1,T2&gt; map TT;</p>
<p>map.insert(map&lt;int,string&gt;::value_type(1,”小李”)）</p>
<p>map.insert(pair &lt;int , string &gt;(3,”小张”))；</p>
<p>map.insert(make_pair(-1,”小张-1”))；</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多核处理器概念</title>
    <url>/Linux-Lover/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>这种架构在并发程序设计中，大致会引来两个问题。<br>一个是内存可见性，一个是Cache一致性流量。<br>内存可见性属于并发安全的问题，Cache一致性流量引起的是性能上的问题。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux并发与竞争</title>
    <url>/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<p><strong>Linux 系统并发产生的原因</strong><br>①、多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。<br>②、抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以<br>在任意时刻抢占正在运行的线程，从而运行其他的线程。<br>③、中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可<br>是很大的。<br>④、SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并<br>发访问。</p>
<p>临界区就是共享数据段<br>一般在编写驱动的时候就要考虑到并发与竞争，而不是驱动都编写完了然后再处理并发与竞争。</p>
<p><strong>原子操作</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/atomic.h&gt;</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line"> int counter;</span><br><span class="line">&#125; atomic_t;/*32位*/</span><br><span class="line">atomic_t v = ATOMIC_INIT(0); /* 定义并初始化原子变零 v=0 */</span><br><span class="line">atomic_set(10); /* 设置 v=10 */</span><br><span class="line">atomic_read(&amp;v); /* 读取 v 的值，肯定是 10 */</span><br><span class="line">atomic_inc(&amp;v); /*++v*/</span><br><span class="line">特点：原子操作只能对整形变量或者位进行保护</span><br><span class="line"></span><br><span class="line">操作一个atomic lock ; </span><br><span class="line">初始赋值为1，打开时判断， 0 错误返回 ， 1 atomic_dec(lock)，同时减1为0 ，（故一个时刻只能打开一次）</span><br><span class="line">关闭 atomic_inc(lock) +1 </span><br><span class="line">操作过程打不开，需等待第一个驱动任务完成，关闭函数atomic_inc(lock) +1 ，然后再次打开</span><br></pre></td></tr></table></figure>
<p><strong>自旋锁</strong><br>#include &lt;linux/atomic.h&gt;<br>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以<br>用，可以访问共享资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct spinlock &#123;</span><br><span class="line"> union &#123;</span><br><span class="line"> struct raw_spinlock rlock;</span><br><span class="line"> <span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"> <span class="comment"># define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"> struct &#123;</span><br><span class="line"> u8 __padding[LOCK_PADSIZE];</span><br><span class="line"> struct lockdep_map dep_map;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"> &#125; spinlock_t;</span><br><span class="line">特点：自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了</span><br><span class="line"></span><br><span class="line">死锁：</span><br><span class="line">被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数。自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，导致死锁现象的发生</span><br><span class="line"></span><br><span class="line">中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生</span><br><span class="line"></span><br><span class="line"> DEFINE_SPINLOCK(lock) /* 定义并初始化一个锁 */</span><br><span class="line"></span><br><span class="line">/* 线程 A */</span><br><span class="line">void <span class="function"><span class="title">functionA</span></span> ()&#123;</span><br><span class="line">unsigned long flags; /* 中断状态 */</span><br><span class="line">spin_lock_irqsave(&amp;lock, flags) /* 获取锁 推荐用这个*/</span><br><span class="line">/* 临界区 */</span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags)  /* 释放锁推荐用这个 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/* 中断服务函数 */ </span><br><span class="line">void <span class="function"><span class="title">irq</span></span>() &#123;</span><br><span class="line">spin_lock(&amp;lock) /* 获取锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line">spin_unlock(&amp;lock) /* 释放锁 */</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> 其他锁：</span><br><span class="line"> 读写锁》》》顺序锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E8%87%AA%E6%97%8B%E9%94%81.jpg" class="" title="自旋锁">


<p><strong>信号量</strong></p>
<p>（1）自旋锁，<strong>信号量可以使线程进入休眠状态</strong>，但信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。<br>（2）如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换<br>线程引起的开销要远大于信号量带来的那点优势<br>(3)计数型信号量不能用于互斥访问，因为它允许多个线程同时访问共享资源。(二值信号值)<br>自动唤醒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line">struct semaphore &#123;</span><br><span class="line">raw_spinlock_t lock;</span><br><span class="line">unsigned int count;</span><br><span class="line">struct list_head wait_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct semaphore sem; /* 定义信号量 */</span><br><span class="line">sema_init(&amp;sem, 1)； /* 初始化信号量 */</span><br><span class="line">down(&amp;sem); /* 申请信号量 */</span><br><span class="line">/* 临界区 */</span><br><span class="line">up(&amp;sem);</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" class="" title="信号量">



<p><strong>互斥体-mutex</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct mutex &#123;</span><br><span class="line">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span><br><span class="line">atomic_t count;</span><br><span class="line">spinlock_t wait_lock;</span><br><span class="line">&#125;;</span><br><span class="line"> struct mutex lock; /* 定义一个互斥体 */</span><br><span class="line">mutex_init(&amp;lock); /* 初始化互斥体 */</span><br><span class="line"></span><br><span class="line"> mutex_lock(&amp;lock); /* 上锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line"> mutex_unlock(&amp;lock); /* 解锁 *</span><br><span class="line">①、mutex 可以导致休眠，因此不能在中断中使用 mutex，__中断中只能使用自旋锁__。</span><br><span class="line">②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</span><br><span class="line">③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并</span><br><span class="line">且 mutex 不能递归上锁和解锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BA%92%E6%96%A5%E4%BD%93.jpg" class="" title="互斥体">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>gpioled 基本框架</title>
    <url>/Linux-Lover/pioled-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>用来复习QvQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define GPIOLED_CNT   1       /*数量*/</span></span><br><span class="line"><span class="comment">#define GPIOLED_NAME  "gpioled"    /*名字*/</span></span><br><span class="line"><span class="comment">#define LEDOFF       0       /*关闭*/ </span></span><br><span class="line"><span class="comment">#define LEDON       1         /*开启*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct gpioled_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid ;</span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    struct device_node * nd;</span><br><span class="line">    int led_gpio;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct gpioled_dev gpioled;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled; /*传递结构*/</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">			 size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    int ret ;</span><br><span class="line">    unsigned char databuf[1];</span><br><span class="line">    struct gpioled_dev *dev = filp-&gt;private_data;</span><br><span class="line">    ret = __copy_from_user(databuf,buf,count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(databuf[0] == LEDON)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_value(dev-&gt;led_gpio,0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (databuf[0] == LEDOFF)</span><br><span class="line">    &#123;</span><br><span class="line">       gpio_set_value(dev-&gt;led_gpio, 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 操作集 */</span><br><span class="line">static const struct file_operations led_fops = &#123;</span><br><span class="line">    .owner		=	THIS_MODULE,</span><br><span class="line">	.write		=	led_write,</span><br><span class="line">	.open		=	led_open,</span><br><span class="line">	.release	=	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init led_init(void )</span><br><span class="line">&#123;</span><br><span class="line">int ret  ;</span><br><span class="line">    gpioled.major = 0;</span><br><span class="line">    <span class="keyword">if</span> (gpioled.major)</span><br><span class="line">    &#123;</span><br><span class="line">        gpioled.devid = MKDEV(gpioled.major,0);</span><br><span class="line">        register_chrdev_region(gpioled.devid,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alloc_chrdev_region(&amp;gpioled.devid,0,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">        gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">        gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"gpioled.major = %d ,gpioled.minor = %d\r\n"</span>,gpioled.major,gpioled.minor);</span><br><span class="line"></span><br><span class="line">*初始化cdev*/</span><br><span class="line">    gpioled.cdev.owner = THIS_MODULE ;</span><br><span class="line">    /*初始化*/</span><br><span class="line">    cdev_init(&amp;gpioled.cdev,&amp;led_fops);</span><br><span class="line">    </span><br><span class="line">  ret = cdev_add(&amp;gpioled.cdev,gpioled.devid,GPIOLED_CNT);</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; 0) </span><br><span class="line">        goto fail_cdev;  </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    /*创建class*/</span><br><span class="line">    gpioled.class = class_create(THIS_MODULE,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.class))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*创建device*/</span><br><span class="line">   gpioled.device = device_create(gpioled.class,NULL,gpioled.devid,NULL,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.device))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   /* 1，获取设备节点 */</span><br><span class="line">    gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    /* 2, 获取LED所对应的GPIO */</span><br><span class="line">    gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">        printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">    /* 3,申请IO */</span><br><span class="line">    ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpio"</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 4,使用IO，设置为输出 */</span><br><span class="line">    ret = gpio_direction_output(gpioled.led_gpio, 1);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		goto fail_setoutput;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 0);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">    fail_setoutput:</span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line">    fail_findnode:</span><br><span class="line">    fail_cdev:</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">static void __exit led_exit(void )</span><br><span class="line">&#123;</span><br><span class="line">      /* 关灯 */</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 1);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;gpioled.cdev);</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">    device_destroy(gpioled.class,gpioled.devid);</span><br><span class="line">    class_destroy(gpioled.class);</span><br><span class="line"></span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树</title>
    <url>/Linux-Lover/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<p>Linux 内核中 ARM 架构下有太多的冗余的垃圾板</p>
<p>级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树</p>
<p>dts、dtbs、dtc、dtsi<br>设备树包括DTC（device tree compiler）,DTS(device tree source和DTB（device tree blob）。DTC为编译工具，它可以将.dts文件编译成.dtb文件。</p>
<p><strong>of 查找设备节点</strong></p>
<p>of_find_node_by_name 函数通过节点名字查找指定的节点</p>
<p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点</p>
<p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点</p>
<p>of_find_node_by_path 函数通过路径来查找指定的节点</p>
<p><strong>查找父/ 子节点的 OF 函数</strong></p>
<p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)</p>
<p>of_get_next_child 函数用迭代的查找子节点</p>
<p><strong>提取属的 性值的 OF 函数</strong></p>
<p>of_find_property 函数用于查找指定的属性</p>
<p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，</p>
<p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值</p>
<p>of_property_read_u8_array 函数</p>
<p>of_property_read_u16_array  函数</p>
<p>of_property_read_u32_array  函数</p>
<p>of_property_read_u64_array</p>
<p>of_property_read_string 函数用于读取属性中字符串值</p>
<p>of_n_addr_cells 函数用于获取#address-cells 属性值</p>
<p>of_size_cells 函数用于获取#size-cells 属性值</p>
<p>其他常用的 OF</p>
<p>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性</p>
<p>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性</p>
<p>值，函数属性如下</p>
<p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址</p>
<p>of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型</p>
<p>of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。</p>
<p>因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>yocto 根文件命令小记</title>
    <url>/Linux-Lover/octo-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>cat /proc/devices  设备</p>
<p>/lib/module</p>
<p>depmod //第一次加载驱动的时候需要运行此命令</p>
<p>modprobe chrdevbase</p>
<p>//可以看到“chrdevbase init！” chrdevbase_init 输出的信息，说明模块加载成功！</p>
<p>cat /proc/devices  //查看设备信息</p>
<p>mknod /dev/chrdevbase c 200 0//设备节点</p>
<p>原因如下<br>（注意：这里不要有后缀.ko，不然会找不到，如：ko文件名是chrdevbase.ko，那么modprobe chrdevbase） 就可以了。具体步骤：</p>
<p>rmmod beep.ko</p>
<p>···<br>cd /proc/device-tree  设备树信息</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动开发准备知识</title>
    <url>/Linux-Lover/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>学习 Linux驱动开发</strong></p>
<p>linaro（利纳罗） 5.4.0   交叉编译器<br>ubuntu 16.04.9<br>flash EMMC NAND——–ROM 8g<br>DDR3 ——RAM 512m<br>Linux 内核版本为 4.1.15，其支持设备树(Device tree)<br> Linux 中的三大类驱动：字符设备驱动（简单）、块设备驱动（储存有关）和网络设备驱动（上网功能）（过于复杂开发商写好）。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl +gpio系统</title>
    <url>/Linux-Lover/nctrl-gpio%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>pinctl子系统 设置GPIO复用电气属性</strong><br>imx6ull.dtsi文件</p>
<p>IO分类：<br>IOMUXC SNVS控制器<br>IOMUXC控制器<br>gpr控制器</p>
<p>添加一个PIN的信息 打开imx6ul-pinfunc.h</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pinctrl_hog_1: hoggrp-1 &#123;</span><br><span class="line">			fsl,pins = &lt;</span><br><span class="line">				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 </span><br><span class="line">			&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19  0x0090 0x031C 0x0000 0x5 0x0</span><br><span class="line">&lt;mux_reg 	conf_reg	 input_reg	 mux_mode	 input_val&gt;</span><br><span class="line">0x0090 		0x031C 	 0x0000 	  0x5 		 0x0</span><br></pre></td></tr></table></figure>
<p>mux_reg：IOMUXC父节点首地址0x020e0000，因此UART1_RTS_B这个PIN的mux寄存器地址 就是：0x020e0000+0x0090=0x020e 0090。<br>conf_reg：0x020e0000+0x031C=0x020e 031C，这个寄存器就是UART1_RTS_B的电气属性配置寄存器。<br>input_reg，为0，表示UART1_RTS_B这个PIN没有input功能。<br>mux_mode： 5表示复用为GPIO1_IO19，将其写入0x020e 0090<br>input_val：就是写入input_reg寄存器的值。</p>
<p><strong>pincrtl驱动原理？</strong><br>    全局搜索，设备节点里面的compatible属性的值，看看在哪个.c文件里面有，那么此.c文件就是驱动文件。<br>    找到pinctrl-imx6ul.c文件，那么此文件就是6UL/6ULL的pinctrl驱动文件。当驱动和设备匹配以后执行，probe函数。也就是imx6ul_pinctrl_probea函数，其中<br>imx_pinconf_set函数设置PIN的电气属性<br>imx_pmx_set函数设置PIN的复用</p>
<p><strong>gpio子系统 设置引脚属性</strong></p>
<p>文件devicetree\bindings\gpio<br>用法：<br>cd-gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_LOW&gt;;</p>
<p>设备数函数常用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 2, 获取LED所对应的GPIO */</span><br><span class="line">   gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">       printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">   /* 3,申请IO */</span><br><span class="line">   ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpios"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   /* 4,使用IO，设置为输出 */</span><br><span class="line">   ret = gpio_direction_output(gpioled.led_gpios, 1);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	goto fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">   gpio_set_value(gpioled.led_gpio, 0);</span><br></pre></td></tr></table></figure>





<p><strong>gpio驱动原理</strong><br>1、gpiolib<br>两部分，给原厂编写GPIO底层驱动的，给驱动开发人员使用GPIO操作函数的。<br>使用gpiochip_add向系统添加gpio_chip，这些都是半导体原厂做的，这部分就是最底层的GPIO驱动。<br>2、gpio驱动<br>在drivers/gpio目录下，gpio-xxx.c文件为具体芯片的驱动文件，</p>
<p>申请IO的时候失败，大部分原因是这个IO被其他外设占用了。检查设备树，查找有哪些使用同一IO的设备。<br>    1，检查复用，也就是pinctl设置。<br>    2，gpio使用</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>信号高级用法(sigaction与sigqueue)</title>
    <url>/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><strong>信号的高级用法</strong></p>
<p>sigaction函数注册信号处理函数<br>int  sigaction(int signum,const struct sigaction *act,const struct sigaction *old);</p>
<p>第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一 个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。<br>第二个参数是指向结构sigaction的一个实例的指针，在结构 sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理<br>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。<br>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigaction 结构体</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_sigaction &#x3D; myhandle;</span><br><span class="line">act.sa_flags &#x3D;SA_SIGINFO;&#x2F;&#x2F;表示能接受数据</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;recv a sig&#x3D;%d\n&quot;, sig);	</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;         </span><br><span class="line">	struct sigaction act;</span><br><span class="line">	sigset_t sa_mask;</span><br><span class="line">	act.sa_handler &#x3D; handler;</span><br><span class="line">	act.sa_flags &#x3D; 0;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	&#x2F;&#x2F;测试信号安装函数</span><br><span class="line">	sigaction(SIGINT, &amp;act, NULL);</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">	pause();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装my_signal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define ERR_EXIT(m) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        perror(m); \</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">    &#125; <span class="keyword">while</span>(0)void handler(int sig);/* 系统调用signal()实际上调用了sigaction() */</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler);int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    my_signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">for</span> (; ;)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler)</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    struct sigaction oldact;</span><br><span class="line">    act.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;act, &amp;oldact) &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> SIG_ERR;</span><br><span class="line">    <span class="built_in">return</span> oldact.sa_handler; // 返回先前的处理函数指针&#125;void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rev sig=%d\n"</span>, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/mysignal.jpg" class="" title="5s阻塞后到达">

<p>typedef union sigval<br>{<br>int sival_int;<br>void *sival_ptr;<br>}sigval_t; </p>
<p>sigqueue新的信号发送函数<br>原型:int sigqueue(pid_t pid, int sig, const union sigval value);<br> 第一个参数是指定接收信号的进程id<br> 第二个参数确定即将发送的信号<br> 第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line">pid_t pid_Array[10]; //pid 数组</span><br><span class="line">void myhandle(int sig,siginfo_t*st, void *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sig == SIGRTMIN)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子1收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[1] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">if</span>(sig == SIGRTMIN+1)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子2收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[3] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sig == SIGRTMIN+2)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：父亲收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"pid[0]:%d  pid[1]%d \n"</span>,pid_Array[0],pid_Array[1]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid;</span><br><span class="line">	</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_sigaction = myhandle;</span><br><span class="line">	act.sa_flags =SA_SIGINFO; //可传递数据</span><br><span class="line">	int i=0;</span><br><span class="line">	/*注册信号*/</span><br><span class="line">     <span class="keyword">if</span>(sigaction(SIGRTMIN, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+1, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+2, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*fork两个进程*/</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid_Array[i] = pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">			perror(<span class="string">"fork fail"</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(pid&gt;0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"fork %d \n"</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid ==  0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"i:%d\n"</span>,i);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*两个进程处理函数*/</span><br><span class="line">	<span class="keyword">if</span>( pid==0 &amp;&amp; i == 0)  //第一个子进程</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程1运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程1醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = getpid()*2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子1给子2发信号  %d \n"</span>,getpid()*2);</span><br><span class="line">		sigqueue(pid_Array[1],SIGRTMIN+1,value);     </span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid==0 &amp;&amp; i==1)//第二个子进程</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程2运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程2醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[3];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子2给父进程发 %d \n"</span>,pid_Array[3]);</span><br><span class="line">		sigqueue(getppid(),SIGRTMIN+2,value);     //父进程pid</span><br><span class="line">			<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//父进程</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[1]; //传递进程2 pid   给进程 1 </span><br><span class="line">		sigqueue(pid_Array[0],SIGRTMIN,value);    </span><br><span class="line"></span><br><span class="line">		sleep(10);</span><br><span class="line">		int mypid =0;</span><br><span class="line">		int  pidnum = 1 ;</span><br><span class="line">		<span class="keyword">while</span>((mypid = waitpid(-1,NULL,WNOHANG))&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"子进程：%d 退出%d\n"</span>,pidnum++,mypid); </span><br><span class="line">		&#125;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"父进程退出\n"</span>);</span><br><span class="line">	     <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> ---------------------------</span><br><span class="line"> ming@ubuntu:~/Day6/22$ ./3</span><br><span class="line">fork 0 </span><br><span class="line">i:0</span><br><span class="line">子进程1运行然后睡眠</span><br><span class="line">fork 1 </span><br><span class="line">i:1</span><br><span class="line">子进程2运行然后睡眠</span><br><span class="line">处理函数：孩子1收到信号5135</span><br><span class="line">信号，子进程1醒来</span><br><span class="line">子1给子2发信号  10268 </span><br><span class="line">处理函数：孩子2收到信号10268</span><br><span class="line">信号，子进程2醒来</span><br><span class="line">子2给父进程发 10268 </span><br><span class="line">处理函数：父亲收到信号10268</span><br><span class="line">pid[0]:5134  pid[1]5135 </span><br><span class="line">子进程：1 退出5134</span><br><span class="line">父进程退出</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>和kill函数相比Int kill(pid_t pid, int siq)多了参数<br>但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket-Api编程</title>
    <url>/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>多并发？</strong></p>
<p>每来一个客户，创建一个进程的思路。</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91.jpg" class="" title="基本框架">

<p><strong>流协议与粘包</strong></p>
<p>tcp    字节流 无边界<br>udp    消息、数据报 有边界<br>对等方，一次读操作，不能保证完全把消息读完。<br>对方接受数据包的个数是不确定的。</p>
<hr>
<p><strong>TCP/IP协议的11种状态</strong></p>
<p>两端同时关闭    将产生closing状态，最后双方都进入TIME_WAIT状态。<br>执行主动关闭的那一端，进入TIME_WAIT状态</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/11.jpg" class="" title="11种">


<p><strong>为什么TCP/IP要三次握手，和四次断开？</strong></p>
<p>全双工协议。（客户收发、服务收发确认）</p>
<p><em>_TIME_WAIT 时间是多长2MSL （2倍的最大生命期时间）</em></p>
<p>原因：（ACK y+1）如果发送失败可以重发。 最后 一个确认包的确认完成。<br>服务器端处于closed状态，不等于客户端也处于closed状态。。</p>
<p><strong>SIGPIPE</strong></p>
<p>如果对方socket已关闭，对等方再发写数据，则会产生SIGPIPE信号<br>常做忽略处理：<br>signal(SIGPIPE, SIG_IGN); </p>
<p><strong>close与shutdown区别</strong><br>refcnt 引用计数</p>
<p>close终止了数据传送的两个方向。<br>shutdown可以有选择的终止某个方向的数据传送或者终止数据传送的两个方向。<br>shutdown how=1就可以保证对等方接收到一个EOF字符，而不管其他进程是否已经打开了套接字（引用计数!）。而close不能保证，直到套接字引用计数减为0时才发送。也就是说直到所有的进程都关闭了套接字。</p>
<p><em>了解5种IO模型_</em></p>
<p>阻塞IO<br>非阻塞IO<br>复用IO<br>信号驱动IO<br>异步IO</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统移植问题</title>
    <url>/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>工具区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bootmgr  RAM空间  选择  windows下</span><br><span class="line">Grub  引导不同的内核启动 RAM空间  选择  支持多操作系统</span><br><span class="line">BIOS  初始化硬件不能引导OS内核   ROM芯片上的程序 开启时运行的第一个程序</span><br><span class="line">Bootloader 引导内核程序运行 RAM空间 内核运行前的程序 Bootloader =BIOS+Grub/Bootmgr </span><br><span class="line">U-boot  通用Bootloader</span><br><span class="line">U-Boot，全称为Universal Boot Loader，即通用Bootloader</span><br></pre></td></tr></table></figure>
<p><strong>ARM U-boot 内核传递参数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">•	U-boot引导程序，在启动的时候会给给Linux Kernel传递很多参数</span><br><span class="line">•	串口波特率，RAM大小，视频fb，MAC地址等</span><br><span class="line">•	设备树的入口地址</span><br><span class="line">•	u-boot如何进行传递的？</span><br><span class="line">•	U-boot把要传递给kernel的东西：保存在struct tag数据结构中</span><br><span class="line">•	启动kernel时，把这个结构体的物理地址传给kernel</span><br><span class="line">•	kernel解析传递的参数？</span><br><span class="line">•	Linux内核通过这个地址，用parse_tags分析出传递过来的参数</span><br><span class="line"></span><br><span class="line">1、内核引导程 arch/arm/lib/vectors.S   用完释放 kernel_entry()</span><br><span class="line">2、内核启动</span><br><span class="line">执行head-armv.S     关闭中断、关闭 MMU。②、关闭 </span><br><span class="line">ENTERY(stxet)      arch/arm/kernel/head.S</span><br><span class="line">Start_kernel();</span><br><span class="line"></span><br><span class="line">ARM架构上，u-boot向Linux内核传递参数利用了R0，R1和R2三个寄存器</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/linux.jpg" class="">


<p>Linux驱动开发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主设备号</span><br><span class="line">•	主设备号标识设备对应的驱动程序。</span><br><span class="line">次设备号</span><br><span class="line">•	次设备号由内核使用，用于正确确定设备文件所指的设备。</span><br><span class="line">字符设备的两种注册方式</span><br><span class="line">void cdev_init(struct cdev *cdev, struct file_operations *fops)</span><br><span class="line">int register_chrdev(unsigned int major, const char *namem , struct file_operations *fopen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：insomd加载一个驱动模块，会执行模块中的那个函数？rmmod呢？这两个函数在设计上要注意什么？遇到过卸载驱动出现异常没？是什么问题引起的？</span><br><span class="line">$ insmod  hello.ko  // 模块加载函数 , 只加载hello.ko模块;</span><br><span class="line">$ modprobe  -r hello.ko	// 模块加载函数,  将加载hello.ko 依赖的所有模块;</span><br><span class="line">（1）insmod调用初始函数，rmmod调用退出函数；</span><br><span class="line">（2）卸载模块时曾出现卸载失败的原因：原因是存在进行中的使用模块，检查代码后发现产生了死锁的问题。</span><br><span class="line">（3）初始化函数中申请的资源在出口函数中要释放：也就是一个模块注册进内核，退出内核时要清理所带来的影响，带走一切不留下一点痕迹。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/Other-Lover/xo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>hexo new”postName” #新建文章</p>
<p>hexo new page”pageName” #新建页面</p>
<p>hexo new page categories 分类页面</p>
<p>hexo new page tags 分类页面</p>
<p>hexo new page about  关于页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #将.deploy目录部署到指定空间</p>
<p>hexo help # 查看帮助</p>
<p>hexo version #查看Hexo的版本</p>
<p>hexo server 本地</p>
<p>hexo deploy 部署</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>序号</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>5</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td></td>
<td>192</td>
</tr>
</tbody></table>
<p><strong>着重号</strong></p>
<p><em>这是斜体</em> 或 <em>这也是斜体</em></p>
<p><strong>这是粗体</strong></p>
<p><strong><em>这是加粗斜体</em></strong></p>
<p><del>这是删除线</del></p>
<p>内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>推荐链接：<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>背景清晰度：<a href="https://www.zhihu.com/question/268140594/answer/335335120" target="_blank" rel="noopener">https://www.zhihu.com/question/268140594/answer/335335120</a></p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6>]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>架构概念</title>
    <url>/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<img src="/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84.jpg" class="" title="架构概念">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>变量知识点</title>
    <url>/C-C-Lover/%E5%8F%98%E9%87%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>i.    预编译: 处理#开头的指令，比如拷贝 #include 包含的文件代码,#define 宏定义的替换 , 条件编译等,就是为编译做的预备工作的阶段。<br>ii.    编译: 分析代码的语法和语义, 将变量和关键字 翻译成中间代码或者汇编代码;<br>iii.    汇编: 将汇编语言翻译为机器可识别的二进制代码.o 是二进制文件<br>iv.    链接:将目标文件所需的库, 文件进行链接</p>
<p>volatile应该是在编译阶段，extern在链接阶段。<br>volatile：告诉编译器，修饰的变量不能优化，每次读取需要从内存中读取；</p>
<p>Static</p>
<ol>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>extern “C”<br>•    被 extern 限定的函数或变量是 extern 类型的<br>•    被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的<br>•    extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
</ol>
<p>#define dPS struct s *             // 宏定义 dPS 表示 struct s*<br>typedef struct s * tPS;            // typedef 表示，将struct *s 重命名为tPS</p>
<p>#define是一个预处理器令牌：编译器本身将永远看不到它。<br>typedef是一个编译器令牌：预处理器不关心它。</p>
<p>•    typedef以分号结尾，而#define不以分号结尾。<br>•    typedef用于为现有类型赋予新的符号名称，而#define用于创建任何类型和值的别名。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>串口、COM、RS232、RS485</title>
    <url>/MCU-Lover/%E5%8F%A3%E3%80%81COM%E3%80%81RS232%E3%80%81RS485/</url>
    <content><![CDATA[<p><strong>uart</strong> （Universal Asynchronous Receiver／Transmitter）<br><strong>usart</strong> （Universal Synchronous Asynchronous Receiver Transmitter）</p>
<p>Uart  异步。（预先知道波特率的大小,传输效率比同步通信要低。）  全双工方式<br>Usart <strong>同步多条时钟线</strong>，也可当做uart使用。</p>
<p>COM异步通信口，被USB取代</p>
<p>COM/USB -&gt; MAX232-&gt; 单片机UART/USART<br>COM/USB -&gt; CH340-&gt; 单片机UART/USART</p>
<p>需要注意的是,串口、UART/USART通常指的是硬件接口。</p>
<p>RS-232指的是属于物理层范畴的串行通信接口标准,RS-232就是个标准。<br>三种接口都是属于串口通信,主要有几个方面的区别。<br>1、通讯距离, RS232接口通讯距离为15米,而RS422/485最大通讯距离可以达到1200米。<br>2、所连设备数, RS232只能连接一个设备,而RS485可以同时连接多个设备。<br>3、端口定义, RS232为标准接口,一般为D型9针的DB9头,接口信号一般为标准默认的。而RS422/RS485为非标准接口,一般为15针串口接口(也可以做9针接口) ,每个设备的接口定义也不太一样, RS422一般为4线制全双工模式,而RS485为两线制,<strong>半双工模式</strong>。</p>
<table>
<thead>
<tr>
<th>SPI与IIC区别</th>
</tr>
</thead>
<tbody><tr>
<td>SPI 是同步串行接口，是一种高速、全双工的同步通信总线</td>
</tr>
<tr>
<td>IIC 是多主设备的总线 , 只有一根数据线，所以是半双工通信</td>
</tr>
<tr>
<td>1. SPI适合数据流应用，而IIC更适合“字节设备”的多主设备应用。</td>
</tr>
<tr>
<td>2. IIC 只需两根信号线，而标准SPI至少四根信号。</td>
</tr>
<tr>
<td>3. 数据吞吐/传输速度   SPI &gt; IIC 8M &gt; 400K</td>
</tr>
<tr>
<td>4、7位I2C总线可以挂接127个不同地址的I2C设备,0号”设备”作为群呼地址.</td>
</tr>
<tr>
<td>5、SPI接口的一个缺点：没有指定的流控制,没有应答机制确认是否接收到数据</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
  </entry>
  <entry>
    <title>怎么说你了解过IIC</title>
    <url>/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
  </entry>
  <entry>
    <title>怎么说你了解过SPI</title>
    <url>/MCU-Lover/%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
  </entry>
  <entry>
    <title>MySql常见报错</title>
    <url>/MySql-Lover/MySql%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>外键约束报错？</p>
<p>SET foreign_key_checks = 0;<br>······<br>SET foreign_key_checks = 1;</p>
<p>update 修改报错？<br>这是因为MySql运行在safe-updates模式下，该模式会导致非主键条件下无法执行update或者delete命令，执行命令SET SQL_SAFE_UPDATES = 0;</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql+qt基本命令</title>
    <url>/MySql-Lover/mysql-qt%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>– 创建一个名称为info的数据库。</p>
<p>create database info;</p>
<p>– 删除数据库info</p>
<p>– drop database info;</p>
<p>– 使用数据库 info</p>
<p>use info;</p>
<p>– 创建表</p>
<p>– create table student(id int primary key auto_increment, name varchar(255), age int, score int);</p>
<p>create table student(id int primary key, name varchar(255), age int, score int);</p>
<p>– 删除student表</p>
<p>– drop table student;</p>
<p>– 插入数据</p>
<p>insert into student(id, name, age) values(1, ‘mike’, 18);</p>
<p>insert into student(id, name, age, score) values(2, ‘lucy’, 22, 90);</p>
<p>insert into student(id, name, age, score) values(3, ‘Tom’, 20, 78);</p>
<p>– 更新数据</p>
<p>update student set score = 90 where id = 3;</p>
<p>– 查找数据</p>
<p>select * from student;</p>
<p>select score from student where name = ‘mike’;</p>
<p>– 删除数据库</p>
<p>delete from student where name = ‘mike’;</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>原始套接字</title>
    <url>/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>对于一个自定义的IP包，或者一个ICMP协议包，又是如何实现传送的呢？<br>原始套接字就允许对这些较底层次的协议（IP、ICMP、IGMP）进行直接访问。</p>
<p><strong>原始套接字定义</strong></p>
<p>原始套接字编程是一种非面向连接的、C/S传输方式的网络编程，使用原始套接字编程进行服务器端与客户端的通信前，首先要创建各自的套接字，然后对相应的套接字进行数据传输，在数据传输过程中，需要使用sendto()函数和recvfrom()函数进行发送与接收，在发送与接收函数中设置相应的IP地址。</p>
<p>扩展：原始套接字往往应用于高级网络编程，如比较流行的网络嗅探器（sniffer）、拒绝服务攻击（DOS）、IP欺骗等等都可以实现，并且还可以通过原始套接字来模拟IP的一些实用工具，如Ping命令。</p>
<p>1.创建函数<br>，如TCP套接字编程选择的是SOCK_STREAM类型的套接字，UDP套接字编程选择的是SOCK_DGRAM类型的套接字，而原始套接字编程则需要选择SOCK_RAW类型的套接字。<br>上述代码创建了一个AF_INET协议族中的原始套接字，协议类型为protocol。<br>协议类型protocol通常设置0，可以取值还包括如下四种：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>IPPROTO_IP、IPPROTO_ICMP、IPPROTO_TCP、IPPROTO_UDP</td>
</tr>
</tbody></table>
<p>说明：创建完原始套接字后，可以通过向网络中定义自己的IP数据包，但是在Linux系统中，为了保护网络系统的安全，规定只有超级用户才有创建原始套接口的权限。</p>
<p>2.设置套接字选项<br>函数setsockopt()主要用于实现对套接字相关的选项设置当前值。</p>
<p>int setsockopt(int s, int  level,  int  optname,  const  void  *optval, socklen_t optlen);</p>
<p>|参数解释<br>|-|-|<br>|参数s表示套接字描述符；<br>|参数level代表的是选项定义的层次，如IPPROTO_IP；<br>|参数optname代表套接字选项的名称，例如IP_HDRINCL表示要构造IP头部；<br>|参数optval表示指向存放选项数据的缓冲区的指针；<br>|参数optlen表示optval参数指向的缓冲区的长度。</p>
<p>当使用套接字选项IP_HDRINCL设置套接字后，接收和发送数据的时候，接收到的数据包含IP数据的，包含IP的头部。用户之后需要对IP层相关的数据段进行处理，例如IP头部数据的设置和分析，校验和的计算等。设置方法如下：<br>int set = 1;<br>if(setsockopt(rawsock, IPPROTO_IP, IP_HDRINCL, &amp;set, sizeof(set))&lt;0)<br>{<br>/<em>错误信息提示</em>/<br>}</p>
<p><strong>了解报文</strong></p>
<img src="/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="报文结构">








]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/Linux-Lover/%E9%94%81/</url>
    <content><![CDATA[<p>产生死锁的必要条件是什么？解决死锁有几种方法？</p>
<p>安全状态与不安全状态：安全状态指系统能按某种进程顺序来为每个进程分配其所需资源，直 至最大需求，使每个进程都可顺利完成。若系统不存在这样一个， 则称系统处于不安全状态。</p>
<p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再 向前推进。<br>产生死锁的原因：（1）竞争系统资源 （2）进程的推进顺序不当<br>满足四个条件：</p>
<ol>
<li>互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</li>
<li>占有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；</li>
<li>不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</li>
<li>循环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</li>
</ol>
<p>解决死锁的基本方法：</p>
<p>预防死锁：<br>（1）资源一次性分配：（破坏请求和保持条件）<br>（2）可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）<br>（3）资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<p>避免死锁:最具有代表性的避免死锁算法是银行家算法。</p>
<p>解除死锁:<br>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
<p>检测死锁<br>有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:<br>1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来<br>2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求<br> 如果第二步返回真,表示出现了死锁</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/Linux-Lover/UDP/</url>
    <content><![CDATA[<p><strong>基于UDP的网络编程</strong></p>
<p>主要用到的函数有socket()、bind()、sendto()、recvfrom()和close()。<br>UDP是面向无连接的网络通信，并不需要像TCP套接字编程那样需要通过connect()与服务器建立连接，然后调用listen()函数使服务器处于监听状态，在通过accept()函数接收客户端的连接请求。</p>
<p>UDP套接字编程，只需要创建用于通信的套接字，然后在服务器端绑定端口，然后就可以实现数据的传输。<br>在绑定了地址信息之后，进行数据传输时，服务器会阻塞recvfrom()函数，等待客户端调用sendto()函数发送数据，同时客户端的recvfrom()被阻塞，然后，服务器会调用recvfrom()函数接收数据，接着向客户端作出应答，同时，服务端的recvfrom()被阻塞，接着，客户端调用recvfrom()接收数据。</p>
<p>1.发送数据、函数sendto()<br>ssize_t  sendto(int  s,  const  void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf用于指向发送信息的缓冲区的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len是发送的信息的长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>to</td>
<td>参数to为存放接收处的信息的指针</td>
</tr>
<tr>
<td>tolen</td>
<td>参数tolen是接收方地址的大小</td>
</tr>
</tbody></table>
<p>说明：如果sendto()函数用于面向连接的网络通信时，套接字类型为SOCK_STREAM或SOCK_SEQPACKET。此时参数to指向NULL，参数tolen为0，若不为此值，就会出现错误信息提示。</p>
<p>2.接收数据、函数recvfrom()</p>
<p>ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf指向接收信息的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len代表缓冲区的最大长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>from</td>
<td>参数from表示发送此信息处的地址指针</td>
</tr>
<tr>
<td>fromlen</td>
<td>参数fromlen指向发送处地址大小的指针。</td>
</tr>
</tbody></table>
<p>字节序转换函数 </p>
<p>    uint32_t htonl(uint32_t hostlong);<br>    uint16_t htons(uint16_t hostshort);<br>    uint32_t ntohl(uint32_t netlong);<br>    uint16_t ntohs(uint16_t netshort);<br>    说明：在上述的函数中，h代表host；<br>    n代表network s代表short；l代表long</p>
<p>地址转换函数 </p>
<p>    #include &lt;netinet/in.h&gt;<br>    #include &lt;arpa/inet.h&gt;<br>    int inet_aton(const char *cp, struct in_addr *inp);<br>    in_addr_t inet_addr(const char *cp);<br>    char *inet_ntoa(struct in_addr in);</p>
<p>serv.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*服务器端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in s_addr;	//服务器地址结构</span><br><span class="line">	struct sockaddr_in c_addr;	//客户端地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	socklen_t addr_len;		//地址结构长度</span><br><span class="line">	int len;			//接收到的消息字节数</span><br><span class="line">	char buff[128];			//存放接收消息的缓冲区</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/*清空地址结构*/</span><br><span class="line">	memset(&amp;s_addr, 0, sizeof(struct sockaddr_in));</span><br><span class="line">/* 设置地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET;</span><br><span class="line">	s_addr.sin_port = htons(PORT);</span><br><span class="line">	s_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">/* 绑定地址和端口信息 */</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">bind</span>(sock, (struct sockaddr *) &amp;s_addr, sizeof(s_addr))) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"bind error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind address to socket successfuly.\n\r"</span>);</span><br><span class="line">/* 循环接收数据 */</span><br><span class="line">	addr_len = sizeof(c_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		len = recvfrom(sock, buff, sizeof(buff) - 1, 0,(struct sockaddr *) &amp;c_addr, &amp;addr_len);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; 0) &#123;//接收失败</span><br><span class="line">			perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(errno);</span><br><span class="line">		&#125;</span><br><span class="line">		buff[len] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"收到来自远端计算机%s，端口号为%d的消息:\n%s\n\r"</span>,inet_ntoa(c_addr.sin_addr), ntohs(c_addr.sin_port), buff);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*客户端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;//定义变量</span><br><span class="line">	struct sockaddr_in s_addr;	//套接字地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	int addr_len;			//地址结构长度</span><br><span class="line">	int len;			//发送字节长度</span><br><span class="line">	char buff[]=<span class="string">"Hello everyone,Merry Christmas!"</span>;	//发送的消息</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/* 设置对方地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET; 	//地址族</span><br><span class="line"></span><br><span class="line">		s_addr.sin_port = htons(PORT);</span><br><span class="line">	<span class="keyword">if</span> (argv[1])</span><br><span class="line">		s_addr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"没有输入消息的接受者！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	addr_len = sizeof(s_addr);	//地址结构长度</span><br><span class="line">/*从客户端的buff缓冲区中发送消息到地址结构为s_addr的远端机器*/</span><br><span class="line">	len = sendto(sock, buff, sizeof(buff), 0,(struct sockaddr *) &amp;s_addr, addr_len);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; 0) &#123;			//如果发送失败</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\rsend error.\n\r"</span>);</span><br><span class="line">		<span class="built_in">return</span> 3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"send success.\n\r"</span>);	//发送成功</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/Linux-Lover/UDP/%E7%BB%93%E6%9E%9C.jpg" class="" title="结果">

]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/Linux-Lover/TCP/</url>
    <content><![CDATA[<p>__TCP三次握手，包头中的标志变化</p>
<img src="/Linux-Lover/TCP/TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class="" title="TCP3次握手">


<p>第一次握手：建立连接时，客户端发送 syn 包(tcp协议中syn位置1，序号为X)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p>
<p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN，同时自己也发送一个 SYN 包，即 SYN+ACK包（tcp协议中syn位置1，ack位置1，序号K，确定序号为X+1），此时服务器进入 SYN_RECV 状态；</p>
<p>第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(tcp协议中ack位置1，确认序号Y+1), 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手</p>
<img src="/Linux-Lover/TCP/%E5%8C%85.jpg" class="" title="TCP3次握手">

<p>seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。 </p>
<img src="/Linux-Lover/TCP/TCP.jpg" class="" title="accetp()一直阻塞到客户端连接">

<p>serv.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;netinet/in.h&gt;  // 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include&lt;arpa/inet.h&gt; // 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char sendbuf[256]=<span class="string">"ok"</span>;</span><br><span class="line">   char buf[256] ;</span><br><span class="line">   int s_fd,c_fd;// 服务器和客户套接字标识符</span><br><span class="line">   int s_len,c_len;// 服务器和客户消息长度</span><br><span class="line">   </span><br><span class="line">   struct sockaddr_in s_addr; // 服务器套接字地址</span><br><span class="line">   struct sockaddr_in c_addr;// 客户套接字地址</span><br><span class="line">   </span><br><span class="line">   s_fd = socket(AF_INET,SOCK_STREAM,0); //创建套接字</span><br><span class="line">   </span><br><span class="line">   s_addr.sin_family = AF_INET;//套接字的域</span><br><span class="line">   s_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">   s_addr.sin_port = PORT ;//定义服务器套接字端口</span><br><span class="line">   s_len = sizepf(s_addr);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">bind</span>(s_fd,(struct sockaddr *) &amp;s_addr,s_len);//绑定套接字 </span><br><span class="line">   </span><br><span class="line">   listen(s_fd,10); // 监听状态，守候进程,允许等待队列请求数10 </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"请稍后，等待客户端的发送数据\n"</span>);</span><br><span class="line">   </span><br><span class="line">   /*接收客户端请求*/</span><br><span class="line">   c_len = sizeof(c_addr);</span><br><span class="line">   c_fd = accetp(s_fd,(struct sockaddr*)&amp; c_addr,c_len); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">   &#123;</span><br><span class="line">    	<span class="keyword">if</span>(recv(c_fd,buf,256,0) &gt; 0) //收到客户   </span><br><span class="line">        &#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"收到客户端消息：\n %s\n"</span>,buf);</span><br><span class="line">         send(c_fd,sendbuf,sizeof(sendbuf),0);//回复客户</span><br><span class="line">   		 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	close(c_fd);// 关闭连接</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;		   // 包含套接字函数库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;			// 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;			// 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   int sockfd;								// 客户套接字标识符</span><br><span class="line">   int len;									// 客户消息长度</span><br><span class="line">   struct sockaddr_in addr;				// 客户套接字地址</span><br><span class="line">   int newsockfd;</span><br><span class="line">   char buf[256]=<span class="string">"come on!"</span>;//要发送的消息</span><br><span class="line">   int len2;							</span><br><span class="line">   char rebuf[256];  </span><br><span class="line">  </span><br><span class="line">	sockfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">   addr.sin_family = AF_INET;  // 客户端套接字地址中的域</span><br><span class="line">   addr.sin_addr.s_addr=htonl(INADDR_ANY);   </span><br><span class="line">   addr.sin_port = PORT;		// 客户端套接字端口</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   len = sizeof(addr);</span><br><span class="line">  	newsockfd = connect(sockfd,(struct sockaddr *)&amp;addr ,len);//发送连接服务器的请求</span><br><span class="line">  <span class="keyword">if</span> (newsockfd == -1)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">"连接诶失败\n"</span>);</span><br><span class="line">  <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">  len2 = sizeof(buf);</span><br><span class="line">  <span class="keyword">while</span>(1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要发送的数据:"</span>);</span><br><span class="line">    scanf(<span class="string">"%s"</span>,buf);</span><br><span class="line">    send(sockfd,buf,len2,0); //发送消息</span><br><span class="line">  <span class="keyword">if</span>(recv(sockfd,rebuf,256,0) &gt; 0)  //接收到</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"收到服务器消息:\n%s\n"</span>,rebuf);//输出到终端	</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  close(sockfd);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<img src="/Linux-Lover/TCP/%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="基本套接字">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>美的面试</title>
    <url>/My-interview-Lover/%E7%BE%8E%E7%9A%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>四大业务：数字化业务、消费者家电、空调业务、机器人自动化</p>
]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Linux-Lover/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>1.计算机网络定义<br>所谓的计算机网络，就是一些互相连接的、自治的计算机的集合。计算机网络有很多种类别。<br>（1）根据不同的作用范围可以将计算机网络理解为广域网（WAN）、城域网（MAN）、局域网（LAN）、个人区域网（PAN）。<br>（2）根据不同的使用者，可以将计算机网络分为公用网和专用网。</p>
<p>2.计算机网络的通信模式<br>计算机网络的通信模式有两种，一种是线路交换，另一种是包交换。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>线路交换</td>
<td>就是我们家家最开始用的电话的网络连接技术，是通过在发送端和接受端之间建立一条特定的线路，进行数据的传输。</td>
</tr>
<tr>
<td>包交换</td>
<td>就是我们现在常用到的计算机的网络通信模式，是通过将所有的计算机放到一个共同的网络连接中，数据的发送端将要传输的数据分割成几份，然后将每一份数据封装成一个包，包中含有接收端的属性信息等，且每个包都是单独传输的。</td>
</tr>
</tbody></table>
<p>OSI 7层协议模型 和各个层次的 关系 </p>


<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
</tr>
<tr>
<td>数据链路层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>传输层</td>
</tr>
<tr>
<td>应用层</td>
</tr>
</tbody></table>
<p>TCP/IP通信协议采用了4层的层级结构，这4层分别为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。</td>
</tr>
<tr>
<td>传输层</td>
<td>在此层中提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据包协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中。这一层负责传送数据，并且确定数据已被送达并接收。</td>
</tr>
<tr>
<td>互联网络层</td>
<td>负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协（IP）。</td>
</tr>
<tr>
<td>网络接口层</td>
<td>对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。</td>
</tr>
</tbody></table>
<p><strong>拥塞控制、流量控制</strong></p>
<p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。<br>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。窗口控制机制</p>
<p>TCP和UDP协议的区别，谈谈增强UDP传输安全性的策略<br>共同点：都是传输层的协议<br>不同点：TCP面向连接（通信前要建立通信的通路），可靠性高<br>      UDP无连接，不可靠（可增加校验机制增加可靠性）</p>
<p>（*）组播的优点： </p>
<ol>
<li>需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。 </li>
<li>由于组播协议是根据接受者的需要，对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。IP协议允许有2亿6千多万个（268435456）组播，所以其提供的服务可以非常丰富。 </li>
<li>此协议和单播协议一样允许在Internet宽带网上传输。</li>
</ol>
<p>对于一个没有设置任何套接口选项的阻塞套接口，调用recv接收对方的数据，对方发送数据前突然断电，recv永远不会返回。</p>
<p><strong>TCP/IP层IP协议的服务是无连接数据报</strong></p>
<p>一台主机从一个网络移到另一个网络.IP地址需要改变，MAC地址不需要改变</p>
<p>经典题目：某公司申请到一个C类的IP地址，但要连接6个子公司，最大的一个子公司有26台计算机，每个子公司在一个网段中，则子网掩码应该为多少？<br>因为有六个子公司，所以必须有三位1，有26台，必须有五个0，所以二进制位11100000，转换为十进制是224</p>
<p>DNS是域名服务器，用来解析域名的（域名与IP之间的解析），如果没有这东西，你必须输入网站的IP地址，有了DNS，你就可以直接输入网址。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉传感器</title>
    <url>/Circuit-Lover/%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p><strong>定义</strong><br>光学图像转化为数字信号的传感器。//非接触检测方法</p>
<p><strong>了解器件</strong><br>CCD -电荷耦合器(Charge-Coupled Device)-新型固体器件<br>CCD结构组成：MOS光敏阵列(金属-氧化物-半导体)+读出移位寄存器=一个MOS光敏元或一个像素</p>
<p><strong>整个过程信号</strong> ：物理-光学-电气-视频<br><strong>CCD</strong> 作用信号转化 :光学-电气</p>
<p><strong>电荷耦合器工作原理</strong></p>
<p>CCD产生（内光电效应）<br>CCD存chu（存储在势井）<br>CCD传输（电荷的定向移动（势井的移动））<br>CDD检测或输出（电流输出、电压输出—浮置栅放大器、浮置扩散放大器）</p>
<p>常见：面型图像传感器组成：感光区+存储+视频输出（串行输出）<br>外形结构和驱动时序不同，原理基本相同，向厂家拿资料。<br>常用：几何量（外加光源工件尺寸或缺陷）、文字、图像识别。</p>
<p>扩展：mark点又叫光学定位点和反光点，如果没有 mark点，对位就不会不准。</p>
<p>CMOS - （Complementary  Metal  Oxide  Semiconductor），互补金属氧化物半导体，电压控制的一种放大器件。是组成CMOS数字集成电路的基本单元。</p>
<p>CCD与CMOS的对比</p>
<p>|项目|CCD|CMOS<br>|-|-|<br>|成像原理|当光线与图像从镜头透过、投射到CCD表面时，CCD就会产生电流，将感应到的内容转换成数码资料储存起来。CCD像素数目越多、单一像素尺寸越大，收集到的图像就会越清晰|利用硅和锗这两种元素所做成的半导体，使其在CMOS上共存着带负电的N级和带正电的P级半导体，这两个互补效应所产生的电流即可被处理芯片记录和解读成影像。<br>|成像质量|高|低于CCD<br>|结构|以行为单位的电流信号|以点为单位的电荷信号<br>|制造成本|高|低<br>|电源消耗|较高|低于CCD</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻式传感器</title>
    <url>/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>应变式 （丝式、箔式和薄膜式三种）</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%85%AC%E5%BC%8F.jpg" class="" title="应变式">

<p>要把电阻的变化转换为电压或电流的变化，需要转换电路来实现。转换电路常采用直流电桥或交流电桥。</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<p><strong>压阻式传感器是基于半导体材料的压阻效应来工作的传感器</strong></p>
<p>__分为半导体应变式压阻传感器 、扩散型压阻传感器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">与金属电阻应变片相比，半导体应变式具有：体积小、横向效应小、灵敏度高等特点。</span><br><span class="line">将P型杂质扩散到N型硅底层上，形成一层极薄的导电P型层，装上引线接点后，即形成扩散型半导体应变片。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>电阻式传感器应用</th>
</tr>
</thead>
<tbody><tr>
<td>（1）应变式测力与荷重传感器</td>
</tr>
<tr>
<td>（2）应变式压力传感器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机</title>
    <url>/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机构造:</span><br><span class="line">40引脚双列直插DIP封装, PO, P1, P2, P3,其中P0不仅作为普通的1/0口使用,还可以作为地址/数据线使用【双向口】总共32个输入输出引脚, 2个电源接地, 2个管教接晶振,复位和控制4个: EA 【内外存储选择引脚,EA 为低电平,只访问外部程序存储器】</span><br><span class="line"></span><br><span class="line">工作方式:复位位方式【RST引脚输入高电平有效】,单步执行方式【通过外来脉冲控制,来一个脉冲执行一条指令,借助外部中断功能】,程序执行方式【主要方式,复位后PC指向地址0000H,从此执行复制导址方式:立即寻址,直接寻址,寄存器寻址,寄存器间接寻址,变址寻址,相对寻址,位寻址</span><br><span class="line"></span><br><span class="line">512字节RAM 8字节ROM（EEPROM）</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/51.jpg" class="" width="51">




<p>__晶体与晶振</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">晶体（crystal）也叫做无缘晶体。它是石英晶片，镀上电极，装在支架上，放在外壳里，就是石英晶体振荡器，简称晶体。常见的有两只脚。</span><br><span class="line">晶振（crystal oscillator）也叫做有源晶振。在晶体的基础上，再加上振荡、放大或者整形电路，然后封装到壳子里，就是晶振。常见的有四只脚。</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%99%B6%E4%BD%93%E4%B8%8E%E6%99%B6%E6%8C%AF.jpg" class="" title="晶体与晶振">


<p>常见问题 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、单片机中的程序计数器PC是16位的寻址范围是64KB怎么来的呀</span><br><span class="line">2 ^ 16，保存指示下一个指令地址</span><br><span class="line"></span><br><span class="line">2、三个周期</span><br><span class="line">时钟周期是单片机的基本时间单位。</span><br><span class="line">机器周期，它是CPU完成一个基本操作所需的时间。</span><br><span class="line">指令周期，是指CPU执行一条指令需要花费的时间。</span><br><span class="line">外接11.0592MHZ晶体，</span><br><span class="line">时钟周期=1/11.0592M</span><br><span class="line">机器周期=12/11.0592M ≈1.085us</span><br><span class="line">指令周期=1个，2个或4个机器周期</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>51</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32单片机</title>
    <url>/MCU-Lover/M32%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习</title>
    <url>/uncategorized/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>bash</strong><br>大多数Linux系统默认使用的shell，bash shell 是shell 的一个免费版本，它是最早的 Unix shell，bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。</p>
<p>注意：windows 下 powershell QAQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">编写：test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello world '</span></span><br><span class="line">运行 ./test.sh</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>数据库SQL语言</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>很棒的一个链接：<a href="https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql" target="_blank" rel="noopener">https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql</a><br>不会就打开看看QvQ</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>1、<strong>数据库由几个部分组成，这个结构有什么好处。</strong><br>答:①数据库、数据库管理系统（及其开发工具）、数据库管理员、应用系统。<br>三级模式:模式、外模式、内模式<br>两层映像结构:外模式模式映像,模式内模式映像<br>好处：保证了数据与程序的逻辑独立性和物理独立性</p>
<p>2、<strong>数据模型</strong></p>
<p>概念模型：实体、属性、码、实体型、实体集、联系</p>
<p>数据模型由数据结构、数据操纵、数据约束规则三个部分组成。</p>
<p>3、<strong>常见模型</strong><br>层次模型：<br>网状模型：<br>（重点）关系模型：<br>面向对象模型：<br>对象关系模型：<br>半结构化模型：</p>
<p>重点：<br>关系模型数据结构:二维表（关系、元组（行）、属性（列）码、域、分组、关系模式）<br>关系模型数据操纵:插入、删除、更新、查询。<br>关系模型数据完整性约束规则:实体完整性、参照完整性、用户自定义完整性。</p>
<p>4、<strong>关系模型</strong></p>
<p>（1）关系：域、笛卡尔积、关系..<br>扩展：<br>候选码(Candidate Key)：一个或者多个属性的集合，可以唯一确定实体的一个实例；<br>主码(Primary Key):从候选码中，选中用来作为唯一标识的属性或者属性组被称为主码；<br>可选码(Alternative Key):候选码中没有选中的其他码，称为可选码；</p>
<p>（2）关系操作：查询分一类，插入、删除、修改一类</p>
<p>关系数据库语言：关系代数与关系演算(SQL 两者的结合)<br>（3）关系代数</p>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.jpg" class="" title="关系代数">

<p>专门关系运算：选择、投射、连接、除运算。</p>


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%96%E8%BF%9E%E6%8E%A5.jpg" class="" title="外连接是自然连接">

<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E9%99%A4%E6%B3%95.jpg" class="" title="除运算">

<p>（4）关系演算（*）</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>微波传感器</title>
    <url>/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<h5 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h5><p>微波是0.1m-1m的电磁波，波长相对较长的电磁波。对应的波段频率范围为300 MHz～3000 GHz。 </p>
<h5 id="微波特点"><a href="#微波特点" class="headerlink" title="微波特点"></a>微波特点</h5><p>(1)似光性和似声性<br>(2)分析方法的独特性<br>低频电路不适用<br>(3)共度性<br>电子在真空管内的渡越时间（10-9秒左右）与微波的振荡周期（ 10-9 ～10-15秒）相当的这一特性称共度性，利用该特性可以做成各种微波电真空器件，得到微波振荡源。<br>(4)穿透性<br>(5)信息性<br>(6)非电离性</p>
<h5 id="微波传感器"><a href="#微波传感器" class="headerlink" title="微波传感器"></a>微波传感器</h5><p><strong>原理</strong><br>微波传感器是利用微波特性来检测某些物理量的器件或装置。由发射天线发出微波，此波遇到被测物体时将被吸收或反射，使微波功率发生变化。若利用接收天线，接收到通过被测物体或由被测物体反射回来的微波，并将它转换为电信号，再经过信号调理电路，即可以显示出被测量，实现了微波检测。<br><strong>分类</strong><br>根据微波传感器的原理，微波传感器可以分为反射式和遮断式两类。<br><strong>组成</strong><br>微波传感器通常由微波发射器（即微波振荡器）、 微波天线及微波检测器三部分组成。<br><strong>微波振荡器</strong> 的器件有调速管、磁控管或某些固态器件，小型微波振荡器也可以采用体效应管<br><strong>微波天线</strong> 为了使发射的微波具有尖锐的方向性，天线要具有特殊的结构。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E5%A4%A9%E7%BA%BF.jpg" class="" title="微波天线">
<p><strong>微波检测器</strong><br>一种是将微波变化为电流的视频变化方式<br>一种是与本机振荡器并用而变化为频率比微波低的外差法。（差分方式）</p>
<h5 id="微波传感器应用"><a href="#微波传感器应用" class="headerlink" title="微波传感器应用"></a>微波传感器应用</h5><p><strong>微波液位计</strong></p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E4%BE%A7%E4%BD%8D%E8%AE%A1.jpg" class="" title="微波侧位计">

<p><strong>微波湿度传感器</strong></p>
<p>扩展：<br>一般干燥的物体，如木材、皮革、谷物、 纸张、 塑料等，其ε′在1～5范围内， 而水的ε′则高达64， 因此如果材料中含有少量水分子时，其复合ε′将显著上升， ε″也有类似性质。 使用微波传感器，测量干燥物体与含一定水分的潮湿物体所引起的微波信号的相移与衰减量， 就可以换算出物体的含水量。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="微波湿度传感器">

<p><strong>微波测厚仪</strong><br>利用微波在传播过程中遇到被测物体金属表面被反射，且反射波的波长与速度都不变的特性进行测厚的。<br>基本原理：<br>（1）在被测金属物体上下两表面各安装一个终端器。微波信号源发出的微波，经过环行器A、 上传输波导管传输到上终端器，由上终端器发射到被测物体上表面上，微波在被测物体上表面全反射后又回到上终端器，再经过传输导管、环行器A、下传输波导管传输到下终端器。</p>
<p>（2）由下终端器发射到被测物体下表面的微波，经全反射后又回到下终端<br>器，再经过传输导管回到环行器A。因此被测物体的厚度与微波传输过<br>程中的行程长度有密切关系，当被测物体厚度增加时，微波传输的行程<br>长度便减小。 </p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B5%8B%E5%8E%9A%E4%BB%AA.jpg" class="" title="微波测厚仪">


<p><strong>微波辐射计（温度传感器）</strong>(*)</p>
<p><strong>微波测定移动物体的速度和距离</strong>(*)</p>
<p><strong>微波无损检测</strong>(*)</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程了解</title>
    <url>/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>1)socket可以看成是用户进程与内核网络协议栈的编程接口。<br>1)socket不仅可以用于本机的进程间通信，还可以用于网络上不同主机的进程间通信。</p>
<img src="/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/1.jpg" class="">

<h5 id="大端、小端"><a href="#大端、小端" class="headerlink" title="大端、小端"></a>大端、小端</h5><p>0x 12 34 56 78<br>低字节78放高位地址，大端；高字节12放低位位地址<br>低字节78放低位地址，小端；高字节12放高位地址</p>
<p>大端：0x12345678<br>小端：0x87654321<br>#include <iostream><br>using namespace std;<br>int main ()<br>{<br>int i =0x12345678 ;<br>if (<em>(char</em>)&amp;i == 0x12) //地址转化再访问<br>{<br>cout &lt;&lt; “大端” &lt;&lt;endl;<br>}<br>else<br>{<br>cout &lt;&lt; “小端” &lt;&lt;endl;<br>}<br>}</p>
<h5 id="Socket-API基本用法"><a href="#Socket-API基本用法" class="headerlink" title="Socket API基本用法"></a>Socket API基本用法</h5><p>#include &lt;sys/socket.h&gt;</p>
<p><strong>socket函数</strong></p>
<p>int socket(int domain, int type, int protocol);<br>创建一个套接字用于通信</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>domain</td>
<td>指定通信协议族（protocol family）</td>
<td>AF_INET</td>
</tr>
<tr>
<td>type</td>
<td>指定socket类型</td>
<td>流式套接字SOCK_STREAM，数据报套接字SOCK_DGRAM，原始套接字SOCK_RAW</td>
</tr>
<tr>
<td>protocol</td>
<td>协议类型</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>bind函数</strong></p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>绑定一个本地地址到套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要绑定的地址</td>
</tr>
<tr>
<td>len</td>
<td>地址长度</td>
</tr>
</tbody></table>
<p><strong>listen函数</strong></p>
<p>一般来说，listen函数应该在调用socket和bind函数之后，调用函数accept之前调用。<br>int listen(int sockfd, int backlog);<br>参数sockfd 是socket()函数返回的套接字描述符；<br>参数backlog指定在请求队列中允许的最大请求数，</p>
<p>对于给定的监听套接口，内核要维护两个队列：<br>1、已由客户发出并到达服务器，服务器正在等待完成相应的TCP三路握手过程<br>2、已完成连接的队列</p>
<p><strong>accept函数</strong></p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<br>从已完成连接队列返回第一个连接，如果已完成连接队列为空，则阻塞。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>将返回对等方的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>返回对等方的套接字地址长度</td>
</tr>
</tbody></table>
<p><strong>connect函数</strong></p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>建立一个连接至addr所指定的套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>未连接套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要连接的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>地址长度</td>
</tr>
</tbody></table>
<h5 id="Socket-API地址复用"><a href="#Socket-API地址复用" class="headerlink" title="Socket API地址复用"></a>Socket API地址复用</h5><p>SO_REUSEADDR：服务器端尽可能使用SO_REUSEADDR，在绑定之前尽可能调用setsockopt来设置SO_REUSEADDR套接字选项。</p>
<p>作用：使用SO_REUSEADDR选项可以使得不必等待TIME_WAIT状态消失就可以重启服务器</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int optval = 1;</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setsockopt bind\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Socket多客户端连接"><a href="#Socket多客户端连接" class="headerlink" title="Socket多客户端连接"></a>Socket多客户端连接</h5>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/Linux-Lover/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h5 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">中断分类</span><br><span class="line">	硬件中断（外部中断）</span><br><span class="line">	外部中断是指由外部设备通过硬件请求的方式产生的中断，也称为硬件中断</span><br><span class="line">	软件中断（内部中断）</span><br><span class="line">	内部中断是由CPU运行程序错误或执行内部程序调用引起的一种中断，也称为软件中断。</span><br></pre></td></tr></table></figure>
<h5 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号是UNIX系统响应某些状况而产生的事件，进程在接收到信号时会采取相应的行动。</span><br><span class="line">信号是因为某些错误条件而产生的，比如内存段冲突、浮点处理器错误或者非法指令等</span><br><span class="line">信号是在软件层次上对中断的一种模拟，所以通常把它称为是软中断</span><br></pre></td></tr></table></figure>
<h5 id="信号和中断的区别"><a href="#信号和中断的区别" class="headerlink" title="信号和中断的区别"></a>信号和中断的区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号与中断的相似点：</span><br><span class="line">（1）采用了相同的异步通信方式；</span><br><span class="line">（2）当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序；</span><br><span class="line">（3）都在处理完毕后返回到原来的断点；</span><br><span class="line">（4）对信号或中断都可进行屏蔽。</span><br><span class="line">信号与中断的区别：</span><br><span class="line">（1）中断有优先级，而信号没有优先级，所有的信号都是平等的；</span><br><span class="line">（2）信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行；</span><br><span class="line">（3）中断响应是及时的，而信号响应通常都有较大的时间延迟。</span><br></pre></td></tr></table></figure>
<h5 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIGABRT	进程停止运行 6</span><br><span class="line">SIGHUP	系统挂断</span><br><span class="line">SIGINT	终端中断  2</span><br><span class="line">SIGPIPE	向没有读者的管道写入数据</span><br><span class="line">SIGQUIT	终端退出   3</span><br><span class="line">SIGTERM	终止 </span><br><span class="line">SIGUSR1	用户定义信号1</span><br><span class="line">SIGUSR2	用户定义信号2</span><br><span class="line">SIGCHLD	子进程已经停止或退出  </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h4 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)忽略信号  </span><br><span class="line">	不采取任何操作、有两个信号不能被忽略：SIGKILL（9号信号）和SIGSTOP。如果应用程序可以忽略这2个信号，系统管理无法杀死、暂停进程，无法对系统进行管理。）。SIGKILL（9号信号）和SIGSTOP信号是不能被捕获的。</span><br><span class="line">2)捕获并处理信号   </span><br><span class="line">	内核中断正在执行的代码，转去执行先前注册过的处理程序。</span><br><span class="line">3)执行默认操作   </span><br><span class="line">	默认操作通常是终止进程，这取决于被发送的信号。</span><br></pre></td></tr></table></figure>

<h5 id="了解常见信号signal函数"><a href="#了解常见信号signal函数" class="headerlink" title="了解常见信号signal函数"></a>了解常见信号signal函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIG_IGN	屏蔽该信号</span><br><span class="line"> signal(2,SIG_IGN);</span><br><span class="line"> //ctrl+c 被屏蔽</span><br><span class="line">SIG_DFL	恢复默认行为</span><br><span class="line"> signal(2,SIG_DFL);</span><br></pre></td></tr></table></figure>
<h5 id="信号发送函数"><a href="#信号发送函数" class="headerlink" title="信号发送函数"></a>信号发送函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）int <span class="built_in">kill</span>(pid_t pid, int siq)</span><br><span class="line">	pid&gt;0 将信号sig发给pid进程</span><br><span class="line">	pid=0 将信号sig发给同组进程</span><br><span class="line">	pid=-1 将信号sig发送给所有进程，调用者进程有权限发送的每一个进程（除了1号、自身）</span><br><span class="line">	pid&lt;-1 将信号sig发送给进程组是pid（绝对值）的每一个进程</span><br><span class="line">    </span><br><span class="line">（2）raise(sig)等价于<span class="built_in">kill</span>(getpid(), sig);</span><br><span class="line"></span><br><span class="line">（3）killpg(pgrp, sig)等价于<span class="built_in">kill</span>(-pgrp, sig);</span><br><span class="line"></span><br><span class="line">（4）pause()函数将进程置为可中断睡眠状态。然后它调用内核函数schedule()，使linux进程调度器找到另一个进程来运行。调用者进程挂起，直到一个信号被捕获</span><br><span class="line"></span><br><span class="line">（5）alarm函数，设置一个闹钟延迟发送信号告诉linux内核n秒中以后，发送SIGALRM信号//alarm(1)</span><br><span class="line"></span><br><span class="line">搭配使用：	</span><br><span class="line">void  myhandle(int num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"recv signal id num : %d \n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGALRM, myhandle) == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"func signal err\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">alarm(1);//调用myhandle</span><br></pre></td></tr></table></figure>
<h5 id="可睡眠中断与不可睡眠中断"><a href="#可睡眠中断与不可睡眠中断" class="headerlink" title="可睡眠中断与不可睡眠中断"></a>可睡眠中断与不可睡眠中断</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sleep(100);//可以中断睡眠，内核让进程睡眠，可以被别的信号唤醒，继续往下运行。</span><br><span class="line">要不可中断睡眠，醒来继续运行sleep。根据sleep会返回剩余秒数。</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">  n = sleep (100);</span><br><span class="line">&#125;<span class="keyword">while</span>(n &gt; 0)；</span><br><span class="line">醒来继续睡。。。</span><br><span class="line">pause();//可中断睡眠</span><br></pre></td></tr></table></figure>
<h5 id="不可重入与可重入函数"><a href="#不可重入与可重入函数" class="headerlink" title="不可重入与可重入函数"></a>不可重入与可重入函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可重入函数每次可能调用效果不一样。</span><br><span class="line">全局变量、mallco函数调用（重新覆盖很恐怖）。</span><br><span class="line"></span><br><span class="line">所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</span><br><span class="line"></span><br><span class="line">启示：尽量不使用全局变量和静态变量的函数。特别是这个变量在程序中随时读写。</span><br></pre></td></tr></table></figure>

<h5 id="信号阻塞、未决、忽略"><a href="#信号阻塞、未决、忽略" class="headerlink" title="信号阻塞、未决、忽略"></a>信号阻塞、未决、忽略</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号屏蔽状态字（block）、信号未决状态字（pending）、忽略标志。</span><br><span class="line">注：阻塞和忽略是不同，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">向进程发送SIGINT，内核首先判断信号屏蔽状态字是否阻塞，信号未决状态字（pending相应位制成1；若阻塞解除，信号未决状态字（pending）相应位制成0；表示信号可以抵达了。</span><br><span class="line">block状态字、pending状态字 64bit；</span><br><span class="line">block状态字用户可以读写，pending状态字用户只能读；这是信号设计机制。</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E4%BF%A1%E5%8F%B7/1.jpg" class="" title="来源：linux编程王保明">


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigset_t pset; //用来打印的信号集</span><br><span class="line">sigset_t bset; //用来设置阻塞的信号集</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;bset);</span><br><span class="line">sigaddset(&amp;bset, SIGINT);</span><br><span class="line"></span><br><span class="line">sigprocmask()读取或更改进程的信号屏蔽状态（block） </span><br><span class="line">eg:</span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;bsetbset,NUU);//阻塞</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;bset,NULL);//解除阻塞</span><br><span class="line">sigpending(&amp;pset);//获取未决字信息</span><br></pre></td></tr></table></figure>

<h5 id="可靠信号、不可靠信号"><a href="#可靠信号、不可靠信号" class="headerlink" title="可靠信号、不可靠信号"></a>可靠信号、不可靠信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可靠信号</span><br><span class="line">unix系统，进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理</span><br><span class="line">可靠信号</span><br><span class="line">linux优化，信号的发送和安装也出现了新版本：信号发送函数sigqueue()及信号安装函数sigaction()</span><br><span class="line">扩展：</span><br><span class="line">非实时信号都不支持排队，都是不可靠信号</span><br><span class="line">实时信号都支持排队，都是可靠信号</span><br></pre></td></tr></table></figure>
<h5 id="信号的高级用法"><a href="#信号的高级用法" class="headerlink" title="信号的高级用法"></a>信号的高级用法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigaction函数注册信号处理函数</span><br><span class="line"></span><br><span class="line">sigqueue新的信号发送函数</span><br><span class="line">原型:int sigqueue(pid_t pid, int sig, const union sigval value);</span><br><span class="line"></span><br><span class="line">和<span class="built_in">kill</span>函数相比Int <span class="built_in">kill</span>(pid_t pid, int siq)多了参数</span><br><span class="line">但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解守护进程</title>
    <url>/Linux-Lover/%E8%A7%A3%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">守护进程是在后台运行不受控端控制的进程，通常情况下守护进程在系统启动时自动运行。</span><br><span class="line">守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</span><br></pre></td></tr></table></figure>
<h5 id="了解会话期"><a href="#了解会话期" class="headerlink" title="了解会话期"></a>了解会话期</h5> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 远程登录服务器，登录成功之后，linux服务器和终端之间建立一个会话期，会话期默认启动shell程序。</span><br><span class="line">注：</span><br><span class="line">shell是进程组， ps -ef | grep xx 也是进程组。。。都在终端中，如果想脱离终端，必须建立子进程代替父进程，该子进程为未来守护进程，调用setsid创建新的会话期。</span><br></pre></td></tr></table></figure>
<h5 id="手动创建守护进程步骤"><a href="#手动创建守护进程步骤" class="headerlink" title="手动创建守护进程步骤"></a>手动创建守护进程步骤</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)调用fork(),创建新进程，它会是将来的守护进程</span><br><span class="line">2)在父进程中调用<span class="built_in">exit</span>，保证子进程不是进程组组长</span><br><span class="line">3)调用setsid创建新的会话期</span><br><span class="line">4)将当前目录改为根目录 （如果把当前目录作为守护进程的目录，当前目录不能被卸载，它作为守护进程的工作目录了。</span><br><span class="line">5）将标准输入、标准输出、标准错误重定向到/dev/null</span><br></pre></td></tr></table></figure>
<h5 id="调用api创建守护进程"><a href="#调用api创建守护进程" class="headerlink" title="调用api创建守护进程"></a>调用api创建守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line">nochdir：=0将当前目录更改至“/”</span><br><span class="line">noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”</span><br><span class="line">例子:</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">int setup_daemon(int nochdir, int noclose);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    mydaemon(1, 1);</span><br><span class="line">    //man daemon 可以看到</span><br><span class="line">    //0表示改变重定向   1表示不改变</span><br><span class="line">    //daemon(1, 1);  //调用函数</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test ...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) ;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mydaemon(int nochdir, int noclose) //自建函数</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == -1)</span><br><span class="line">        ERR_EXIT(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; 0)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    setsid();</span><br><span class="line">    <span class="keyword">if</span> (nochdir == 0)</span><br><span class="line">        <span class="built_in">chdir</span>(<span class="string">"/"</span>);//系统调用函数改变当前路径 </span><br><span class="line">		<span class="keyword">if</span> (noclose == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        <span class="keyword">for</span> (i=0; i&lt;3; ++i)</span><br><span class="line">            close(i);</span><br><span class="line">        open(<span class="string">"/dev/null"</span>, O_RDWR);  </span><br><span class="line">        dup(0); //标准输出 也指向/dev/null  //    dup2(0, 1);</span><br><span class="line">        dup(0); //标准错误输出，也指向/dev/null //    dup2(0, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>来源：Linux应用编程王保明</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程概念</title>
    <url>/Linux-Lover/%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程是操作系统分配的内存、CPU时间片等资源的基本单位,是资源分配的最小单位(线程是CPU执行单位)。</span><br><span class="line">进程是操作系统对资源的一种抽象，一个进程由三部分组成:</span><br><span class="line">1）进程控制块PCB：用于描述进程情况及控制进程运行所需的全部信息。</span><br><span class="line">2）代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</span><br><span class="line">3）数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</span><br><span class="line">分式操作系统 </span><br><span class="line">基于时间片轮转，每一个进程有自己的地址空间和执行状态。</span><br></pre></td></tr></table></figure>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作系统经典三态:就绪	等待、（阻塞）、运行等</span><br><span class="line">还有其他挂起、僵尸进程等。。。</span><br><span class="line">Linux内核中的进程状态：</span><br><span class="line">▽	运行状态</span><br><span class="line">▽	可中断睡眠状态7</span><br><span class="line">▽	不可中断睡眠状态</span><br><span class="line">▽	暂停状态</span><br><span class="line">▽	僵死状态</span><br></pre></td></tr></table></figure>
<h5 id="进程调度及调度算法"><a href="#进程调度及调度算法" class="headerlink" title="进程调度及调度算法"></a>进程调度及调度算法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先来先服务调度算法</span><br><span class="line">短进程优先调度算法</span><br><span class="line">高优先级优先调度算法</span><br><span class="line">时间片轮转法（公平）</span><br></pre></td></tr></table></figure>

<h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程描述信息（进程标识符）</span><br><span class="line">进程控制信息（进程当前状态等）</span><br><span class="line">资源信息（I/O设备号、缓冲、内存等）</span><br><span class="line">现场保护信息（寄存器、PC、PSW、栈指针）</span><br></pre></td></tr></table></figure>
<h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、分配一个内部标识，在内核中建立进程结构.</span><br><span class="line">复制父进程的环境。</span><br><span class="line">2、为进程分配资源，包括所有元素（程序、数据、用户栈等，复制父进程地址空间的内容到该进程地址空间中。</span><br><span class="line">3、置该进程的状态为就绪，插入就绪队列。</span><br></pre></td></tr></table></figure>
<h5 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关闭软中断:因为进程即将终止而不再处理任何软中断信号；</span><br><span class="line">回收资源：释放进程分配的所有资源，如关闭所有已打开文件，释放进程相应的数据结构等；</span><br><span class="line">写记帐信息：将进程在运行过程中所产生的记帐数据（其中包括进程运行时的各种统计信息）记录到一个全局记帐文件中；</span><br><span class="line">置该进程为僵死状态:向父进程发送子进程死的软中断信号，将终止信息status送到指定的存储单元中；</span><br><span class="line">转进程调度:因为此时CPU已经被释放，需要由进程调度进行CPU再分配。</span><br></pre></td></tr></table></figure>
<h5 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">避免僵尸进程</span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line">signal(SIGCHLD, SIG_IGN);//子进程信号，忽略</span><br></pre></td></tr></table></figure>

<h5 id="1：n-的机制"><a href="#1：n-的机制" class="headerlink" title="1：n 的机制"></a>1：n 的机制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、从子进程获得父进程id容易。</span><br><span class="line">2、把子进程id返回给父进程，以便控制</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程获取标识</title>
    <url>/Linux-Lover/%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程ID</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"UID=%ld\n"</span>,(long)getuid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"EUID=%ld\n"</span>,(long)geteuid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">用户ID  创建者信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int flag1,flag2;</span><br><span class="line">flag1=setuid(0);</span><br><span class="line">flag2=setgid(500);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag1=%d\n,flag2=%d\n"</span>,flag1,flag2);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">用户组ID  用户组信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"group ID=%d\n"</span>,(long)getgid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"effective group ID=%d\n"</span>,(long)getegid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/Linux-Lover/%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>void *</title>
    <url>/C-C-Lover/id/</url>
    <content><![CDATA[<p>C语言中void *为不确定类型指针.</p>
<p>void* 可以用来声明指针。<br>例如: void <em>a;<br>(1) void</em>可以接受任何的t值:void *a= NULL；<br>   int  *b=NULL；<br>   a= b; 任何类型的指针都可以直接赋值给它,无需进行强制类型转换</p>
<p>(2) void<em>可以赋值给任何类型的变量但是需要进行强制转换:<br>例如：int a = NULL;void*b;a = (int</em>) b:</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件</title>
    <url>/Linux-Lover/%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="文件自身信息"><a href="#文件自身信息" class="headerlink" title="文件自身信息"></a>文件自身信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//索引节点所包含信息存在结构体<span class="built_in">stat</span></span><br><span class="line">struct <span class="built_in">stat</span></span><br><span class="line">&#123;</span><br><span class="line">dev_t stdev; /*文件使用设备号*/</span><br><span class="line">ino_t st_ino;  /*索引节点*/</span><br><span class="line">mode_t st_mode; /*访问模式*/</span><br><span class="line">nlink_t st_nlink;/*硬链接*/</span><br><span class="line">uidt st_uid; /*所有者用户ID*/</span><br><span class="line">gid_t st_gid; /*用户组ID*/</span><br><span class="line">dev_t st_rdev;/*设备文件设备号 */</span><br><span class="line">off_t st_size; /*文件大小 字节单位/</span><br><span class="line">blksize_t st_blksize; /*系统磁盘块大小*/</span><br><span class="line">blkcnt_t st blocks; /*文件磁盘块大小*/</span><br><span class="line">time_t st_atime; /*最后一次访问时间*/</span><br><span class="line">time_t st_mtime; /*最后一次修改时间*/</span><br><span class="line">time_t st_ctime; /*最后一次修改文件状态时间*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">根据处理的不同：</span><br><span class="line">缓冲区文件、非缓冲区文件（系统I/O，二进制文件）</span><br><span class="line"></span><br><span class="line">缓冲：缓冲区的大小由各个具体的C 版本确定，一般为512 字节。</span><br><span class="line">全缓冲(文件把缓冲区写满才写到文件里)</span><br><span class="line">行缓冲（<span class="built_in">printf</span>）</span><br><span class="line">无缓冲（内核调用函数）</span><br><span class="line">根据其存放数据的作用的不同：</span><br><span class="line">其分为普通文件、目录文件、链接文件、设备文件和管道文件</span><br></pre></td></tr></table></figure>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IO操作分两类</span><br><span class="line">基于文件描述符的IO操作、基于数据流的IO操作</span><br><span class="line"></span><br><span class="line">文件描述符</span><br><span class="line">打开磁盘文件一次，内核创建一个文件表项，文件表项包含文件状态信息、存储内容缓存、当前文件路径等。</span><br><span class="line">例如：table[0]=a、table[1]=b、table[3]=c</span><br><span class="line">a,b,c文件表项，描述符为0,1，2 。可以用des[3] = &#123;0,1,2&#125;保存访问磁盘文件。</span><br><span class="line">头文件<span class="comment">#include&lt;unistd.h&gt;。linux系统提供，open（）、close、read（）、write（）、lseek（）等</span></span><br><span class="line">eg:ssize_t <span class="built_in">read</span>(int fp,char *buf,size_t count)</span><br><span class="line">off_t lseek(int fildes,off_t,int <span class="built_in">whence</span>)</span><br><span class="line">参数<span class="built_in">whence</span>:</span><br><span class="line">SEEK_SET:文件开头</span><br><span class="line">SEEK_CUR:文件偏移量</span><br><span class="line">SEEK_END:文件结尾</span><br><span class="line"></span><br><span class="line">数据流概述</span><br><span class="line">标准I/O库函数，stdio.h头文件</span><br><span class="line">fopen()、fread()、fclose()、fgetc(0）、fscanf()等</span><br><span class="line">eg: FILE open （const char * path ,const char *mode）</span><br><span class="line">char *fgets(char *s ,int size,FILE *stream);</span><br><span class="line">int fputs(char *s FILE *stream);</span><br><span class="line"></span><br><span class="line">size_t fread(void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">size_t fwrite(const void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库安全性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h5 id="数据库安全概述"><a href="#数据库安全概述" class="headerlink" title="数据库安全概述"></a>数据库安全概述</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据库安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</span><br><span class="line">数据库不安全因素:</span><br><span class="line">(1)非授权用户对数据库进行破坏</span><br><span class="line">(2)数据库重要或者敏感数据泄露</span><br><span class="line">(3)安全环境的脆弱性</span><br></pre></td></tr></table></figure>
<h5 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安全标准：TCSEC标准、CC标准(TCSEC相互总结互补发展而来)</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/1.jpg" class="" title="TCSEC标准">


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/2.jpg" class="" title="CC标准">

<h5 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）用户身份鉴别</span><br><span class="line">	静态鉴别、动态鉴别、生物鉴别、智能卡鉴别。</span><br><span class="line">（2）存取控制 （自主存取控制和强制存取控制，定义用户权限和合法权限检查机制）</span><br><span class="line">	授权:授予和收回</span><br><span class="line">    </span><br><span class="line">	GRANT  &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	TO &lt;用户&gt;</span><br><span class="line">	WITH GRANT OPTION ;（能传递权限，但不能形成循环传递）</span><br><span class="line"></span><br><span class="line">	REVOKE &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	FROM &lt;用户&gt;</span><br><span class="line"></span><br><span class="line">（3）视图机制</span><br><span class="line"></span><br><span class="line">（4）审计</span><br><span class="line">审计功能把用户对数据库的所有操作自动记录下来放入审计日志(auditlog)中。</span><br><span class="line">审计员可以利用审计日志监控数据库中的各种行为,重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。</span><br><span class="line">AUDIT ALTER，PDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line">NOAUDIT ALTER ,UPDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（5）数据加密：传输加密、存储加密</span><br><span class="line">其他安全性保护：推理控制、隐蔽信道、数据隐私保护。</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/3.jpg" class="" title="视图例子">]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>进程创建、等待、结束</title>
    <url>/Linux-Lover/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork 系统调用"></a>fork 系统调用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一次调用，二次返回？</span><br><span class="line">答：如果成功创建一个子进程，对于父进程来说返回子进程ID</span><br><span class="line">如果成功创建一个子进程，对于子进程来说返回值为0</span><br><span class="line">问题的本质是：两次返回，是在各自的进程空间中返回的。</span><br><span class="line">子进程和父进程各有自己的内存空间 （fork：代码段、数据段、堆栈段、PCB进程控制块的copy）。</span><br><span class="line">fork返回值大于零的是父进程，为什么这样设计:？</span><br><span class="line">答：因为父进程求子进程的pid比较困难，子进程求父进程的id比较容易</span><br></pre></td></tr></table></figure>
<h5 id="fork-c"><a href="#fork-c" class="headerlink" title="fork.c"></a>fork.c</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">    //子进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the child process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">    //父进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the parent process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="vfork-与fork区别"><a href="#vfork-与fork区别" class="headerlink" title="vfork 与fork区别"></a>vfork 与fork区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vfork函数vfork函数与fork函数相同,都是系统调用函数,两者的区别是在创建子进程时, fork函数会复制所有的父送源,包括进程环境、内荐资源等。而vfork函数在创建子进程时,不会复制父进程的所有资源,父子进程共享空间，可以修改父进程内存空间中的值。</span><br><span class="line">注意：在使用vfork函数时,父进程会被阻塞,需要学进程调用_exit函数退出子进程,不能使用<span class="built_in">exit</span>退出.</span><br></pre></td></tr></table></figure>
<h5 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int gvar=2;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int var=5;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"process id:%ld\n"</span>,(long)getpid());//getpid 获取当前进程id</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"gvar=%d var=%d\n"</span>,gvar,var);</span><br><span class="line">	<span class="keyword">if</span>((pid=vfork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"error!"</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		gvar--;</span><br><span class="line">		var++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		_exit(0);//退出子程序</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the parent process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行简要结果 ： //当前</span><br><span class="line">	process id:2825</span><br><span class="line">	gvar=2 var=5</span><br><span class="line">	the child process id:2826</span><br><span class="line">	gvar=1 var=6//子进程  共享变量的修改</span><br><span class="line">	the parent process id:2825//父进程</span><br><span class="line">	gvar=1 var=6</span><br></pre></td></tr></table></figure>
<h5 id="exec调用函数"><a href="#exec调用函数" class="headerlink" title="exec调用函数"></a>exec调用函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       <span class="comment">#include &lt;unistd.h&gt; </span></span><br><span class="line">       extern char **environ;</span><br><span class="line">       int execl(const char *path, const char *arg, ...); </span><br><span class="line">       int execlp(const char *file, const char *arg, ...); </span><br><span class="line">       int execle(const char *path, const char *arg,</span><br><span class="line">                  ..., char * const envp[]);    </span><br><span class="line">       int execv(const char *path, char *const argv[]);</span><br><span class="line">       int execvp(const char *file, char *const argv[]);</span><br><span class="line">参数说明：</span><br><span class="line">	path参数表示你要启动程序的名称包括路径名</span><br><span class="line">	arg参数表示启动程序所带的参数</span><br><span class="line">	返回值:成功返回0,失败返回-1</span><br><span class="line">函数名说明： </span><br><span class="line">    l代表可变参数列表，p代表在path环境变量中搜索file文件。envp代表环境变量。</span><br><span class="line">例子1：</span><br><span class="line">----------------execve.c-----------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">/*	execve(<span class="string">"new"</span>,argv,environ);</span><br><span class="line">	puts(<span class="string">"正常情况下无法输出此信息"</span>);</span><br><span class="line">*/</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create child process failed!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	       execve(<span class="string">"new"</span>,argv,environ);//文件名字+当前路径+环境变量</span><br><span class="line">           // execve(<span class="string">"./new"</span>,NULL,NULL);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		puts(<span class="string">"正常情况下输出此信息"</span>); //不想舍去放在父进程</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------new2.c----------------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	puts(<span class="string">"welcome to mrsoft"</span>);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">例子2：用execlp调用vi,打开了new2.c</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">	&#123;</span><br><span class="line">	 	 <span class="built_in">printf</span>(<span class="string">"vi的等效用法： %s filename\n"</span>,argv[0]);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line"> 	 &#125;</span><br><span class="line">	  execlp(<span class="string">"/bin/vi"</span>,<span class="string">"vi"</span>,argv[1],(char*)NULL);//文件路径+操作变量名+操作的文件+NULL</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">运行时输入命令：./execlp ./new2.c</span><br></pre></td></tr></table></figure>

<h5 id="wait等待函数"><a href="#wait等待函数" class="headerlink" title="wait等待函数"></a>wait等待函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	父进程没有调用等待函数，子进程会变成僵尸进程。</span><br><span class="line">	僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程。</span><br><span class="line">	孤儿进程：如果父亲进程先结束，子进程会托孤给1号进程</span><br><span class="line">-------------------</span><br><span class="line">    子进程结束，内核会向父进程发送SIGCHLD信号，子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）</span><br><span class="line">    如果存在子进程,进程时的结束状态有(status)如下两种可能: </span><br><span class="line">	进程正常结束：status和PID，status存在子进程退出码（子进程main返回参数或者exti返回参数）当中。</span><br><span class="line"></span><br><span class="line">   信号引起子进程结束：若发送的信号被进程捕获,就不会起到终止进程作用;若信号没有被进程捕误,则会使进程非正常结束。此时参数status返回的状态值为接收到的信号 ,存在最后一个字节中。</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line">void exit_s(int status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(WIFEXITED(status)) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"normal exit,status=%d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"signal exit!status=%d\n"</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid,pid1;</span><br><span class="line">	int status;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		pid1=getpid();</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,9);//结束   信号退出</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,17);//进入父进程  <span class="built_in">wait</span> erro</span><br><span class="line">		<span class="built_in">kill</span>(pid1,19);//终止   直接退出</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">扩展：</span><br><span class="line">宏定义</span><br><span class="line">WIFEXITED(status)	如果子进程正常结束，返回一个非零值</span><br><span class="line">WEXITSTATUS(status)	如果WIFEXITED非零，返回子进程退出码</span><br><span class="line">WIFSIGNALED(status)	子进程因为捕获信号而终止，返回非零值</span><br><span class="line">WTERMSIG(status)	如果WIFSIGNALED非零，返回信号代码</span><br><span class="line">WIFSTOPPED(status)	如果子进程被暂停，返回一个非零值</span><br><span class="line">WSTOPSIG(status)	如果WIFSTOPPED非零，返回一个信号代码</span><br><span class="line">waitip()也用于等待特定进程。调用<span class="built_in">wait</span>或者waitpid函数查询子进程退出状态，此方法父进程会被挂起。</span><br><span class="line">如果不想让父进程挂起，可以在父进程中加入一条语句：</span><br><span class="line">signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</span><br></pre></td></tr></table></figure>
<h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 与_exit()</span><br><span class="line">相同：无论调用成功与否，无返回信息。</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">1）_exit是一个系统调用，<span class="built_in">exit</span>是一个c库函数</span><br><span class="line">2）<span class="built_in">exit</span>会执行清除I/O缓存，可能会丢失临时文件，建议不用。（前面例子，不做说明）</span><br><span class="line">3）<span class="built_in">exit</span>会执行调用终止处理程序</span><br><span class="line"></span><br><span class="line">扩展：atexit（）</span><br><span class="line">代码:</span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello1...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void func2()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello2...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">atexit(func1);//输出func1</span><br><span class="line">atexit(func2);//输出func2</span><br><span class="line">puts(<span class="string">"hello...\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">运行：</span><br><span class="line">hello...</span><br><span class="line">hello2...</span><br><span class="line">hello1...</span><br></pre></td></tr></table></figure>


<h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程终止的5种方式</span><br><span class="line">正常退出</span><br><span class="line">1)从main函数返回</span><br><span class="line">2)调用<span class="built_in">exit</span></span><br><span class="line">3)调用_exit</span><br><span class="line">异常退出</span><br><span class="line">4)调用abort   产生SIGABOUT信号</span><br><span class="line">5)由信号终止  ctrl+c SIGINT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/Data-Structure-and-Algorithms-Lover/d/</url>
    <content><![CDATA[<h5 id="LeetCode-总结"><a href="#LeetCode-总结" class="headerlink" title="LeetCode 总结"></a>LeetCode 总结</h5><h5 id="二叉树最大路径和"><a href="#二叉树最大路径和" class="headerlink" title="二叉树最大路径和"></a>二叉树最大路径和</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">&#125;;</span><br><span class="line">int OneSideMax(TreeNode *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootroot-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;right);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        int a = OneSideMax(root-&gt;left);</span><br><span class="line">        int b = OneSideMax(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;     </span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + b;</span><br><span class="line">        &#125;</span><br><span class="line">  		  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*判断树是否为镜像,判断优先考虑递归QAQ*/</span><br><span class="line">bool isSym(struct TreeNode *root1 ,struct TreeNode *root2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == NULL &amp;&amp; root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==NULL || root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root1-&gt;left,root2-&gt;right)&amp;&amp;isSym(root1-&gt;right,root2-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetric(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">输出镜像树</span><br><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct TreeNode* Swap(struct TreeNode* root)</span><br><span class="line">&#123;   </span><br><span class="line">     <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(root-&gt;left);</span><br><span class="line">    Swap(root-&gt;right);</span><br><span class="line">    struct TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left  =  root-&gt;right ;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">return</span>  Swap(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*前序遍历和中序遍历的结果还原一棵二叉树*/</span><br></pre></td></tr></table></figure>
<h5 id="N树"><a href="#N树" class="headerlink" title="N树"></a>N树</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构框架</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>记言：被华为的笔试题弄晕了，才发现自己的数据结构和算法是多么的苍白无力，但我会变强的QAQ。<br>2019-4-15 ming</p>
<p>资料学习：在Github上有份资料值得推荐。<br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/</a> 向dalao递茶.jpg</p>
<p>遍历框架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*数组遍历*/</span><br><span class="line">void traverse（int [] arr）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i ; i &lt;arr.length ; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		//迭代 arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*链表遍历*/</span><br><span class="line">class ListNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	<span class="keyword">for</span> (ListNode p = head ; p != null ; p = p.next)&#123;</span><br><span class="line">    	</span><br><span class="line">        //迭代访问p.data</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	//递归head.data;</span><br><span class="line">	traverse(head.next);</span><br><span class="line">&#125;</span><br><span class="line">/*二叉树遍历*/</span><br><span class="line">class TreeNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode left ,right;</span><br><span class="line">&#125;</span><br><span class="line">void traverse (TreeNode root)&#123;</span><br><span class="line">	//递归root.data  先序</span><br><span class="line">    //cout &lt;&lt; root.data &lt;&lt; endl;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*N叉树遍历*/</span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode [] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void traverse(TreeNode root)&#123;</span><br><span class="line">	//c++ 11 标准</span><br><span class="line">	<span class="keyword">for</span>(TreeNode clid : root.children)&#123;</span><br><span class="line">    	//cout &lt;&lt; child.data &lt;&lt; endl;</span><br><span class="line">    	traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB的基本常识</title>
    <url>/Circuit-Lover/PCB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h4 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">频率：10M-100M </span><br><span class="line">线框：10mile（0.254mm=10mil）</span><br><span class="line">电源：20-30v //电源线加粗抗干扰</span><br><span class="line">价钱：80-100元</span><br><span class="line">DIP 双直插式</span><br><span class="line">QFP 方扁封装</span><br><span class="line">孔的类型</span><br><span class="line">孔有三大类别：过孔（Vai）、 插件孔（Pad孔） 、无铜安装孔（Npth）</span><br><span class="line">过孔（via）：只是起电气导通作用不用插器件焊接，其表面可以做开窗（焊盘裸露）、盖油或者塞油。</span><br><span class="line">插件孔（Pad孔）：需要插器件焊接的引脚孔，焊盘表面必须裸露出来</span><br><span class="line">无铜安装孔（Npth）:螺丝孔或器件塑料固定脚，没有电气性能，起定位固定作用。</span><br></pre></td></tr></table></figure>
<h4 id="AD软件操作"><a href="#AD软件操作" class="headerlink" title="AD软件操作"></a>AD软件操作</h4><h6 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q  精度转化mile---mm</span><br><span class="line">1 电路规划（板子大小）</span><br><span class="line">快捷键TVT打安装孔（双击属性：Board cutout 板剪切块）copper镀铜  polygon cutout多边形剪切</span><br><span class="line">2 二维s</span><br><span class="line">3 三维</span><br><span class="line">shitf+右键旋转</span><br><span class="line">ctrl+中键  放大</span><br><span class="line">N +  S  +  A  显示预拉线</span><br><span class="line">N +  H +  A      隐藏预拉线（N键）</span><br><span class="line">shitf +F查找类似</span><br><span class="line">先按3切换到三维界面，然后按住SHIFT不放，按鼠标右键调整视图角度</span><br></pre></td></tr></table></figure>
<h5 id="一块PCB的生成基本过程"><a href="#一块PCB的生成基本过程" class="headerlink" title="一块PCB的生成基本过程"></a>一块PCB的生成基本过程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.原理图 （满足输入左边，输出右边）</span><br><span class="line">2.一键生成PCB</span><br><span class="line">3.自动布线</span><br><span class="line">4.手工布线</span><br><span class="line">5.规则检查</span><br><span class="line">6.泪滴</span><br><span class="line">7.敷铜（放置多边形敷铜（G键））</span><br><span class="line">8.规则检查</span><br><span class="line">9.信号检查</span><br><span class="line">10.生成物料清单</span><br><span class="line">11.联系淘宝卖家 （嘉立创）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>超声波传感器</title>
    <url>/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p><strong>超声波分类</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">振动在弹性介质内的传播称为波动，简称波。</span><br><span class="line">低于16 Hz的机械波，称为次声波；</span><br><span class="line">在16~2×10^4 Hz之间，称为声波；</span><br><span class="line">高于2×10^4 Hz的机械波，称为超声波,</span><br><span class="line">在3×10^8~3×10^11Hz之间的波，称为微波。</span><br><span class="line">波类型和传递介质</span><br><span class="line">① 纵波：质点振动方向与波的传播方向一致的波，它能在固体、液体和气体介质中传播；</span><br><span class="line">② 横波：质点振动方向垂直于传播方向的波，它只能在固体介质中传播； </span><br><span class="line">③ 表面波：质点的振动介于横波与纵波之间，沿着介质表面传播，其振幅随深度增加而迅速衰减的波，表面波只在固体的表面传播。</span><br></pre></td></tr></table></figure>
<p><strong>超声波应用</strong><br>(1)超声波用于高效清洗<br>当弱的声波信号作用于液体中时，会对液体产生一定的负压，即液体体积增加，液体中分子空隙加大，形成许多微小的气泡；而当强的声波信号作用于液体时，则会对液体产生一定的正压，即液体体积被压缩减小，液体中形成的微小气泡被压碎。经研究证明：超声波作用于液体中时，液体中每个气泡的破裂会产生能量极大的冲击波，相当于瞬间产生几百度的高温和高达上千个大气压的压力，这种现象被称之为“空化作用”，超声波清洗正是利用液体中气泡破裂所产生的冲击波来达到清洗和冲刷工件内外表面的作用。超声清洗多用于半导体、机械、玻璃、医疗仪器等行业。<br>(2)超声波焊接(主要三要素：时间、压力、振幅)<br>压电陶瓷或磁致伸缩材料在高电压窄脉冲作用下，可得到较大功率的超声波，可以被聚焦，能用于集成电路及塑料的焊接。<br>注：金属也行。<br>(3)超声波在医学检查中的应用<br>胎儿的B超影像…</p>
<p><strong>超声波传感器</strong><br>超声物位传感器：单换能器、双换能器<br>只要测得超声波脉冲从发射到接收的时间间隔，便可以求得待测的物位。 </p>
<p><strong>超声侧厚传感器</strong><br>双晶直探头中的压电晶片发射超声振动脉冲，超声脉冲到达试件底面时，被反射回来，并被另一只压电晶片所接收。</p>
<p><strong>超声波流量传感器</strong><br>目前应用较广的主要是超声波传播时间差法.超声波在流体中传播时，在静止流体和流动流体中的传播速度是不同的，利用这一特点可以求出流体的速度，再根据管道流体的截面积， 便可知道流体的流量。</p>
<img src="/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="超声波传感器">


<p><strong>超声波传感器的应用</strong><br>超声波流量计<br>超声波侧厚<br>超声波探伤<br>超声波报警器</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程常识</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h5 id="计算机常识QAQ"><a href="#计算机常识QAQ" class="headerlink" title="计算机常识QAQ"></a>计算机常识QAQ</h5><img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/1.jpg" class="" title="计算机系统硬件组成（linux王保明）">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽贯穿整个系统的一组电子管道称为总线</span><br><span class="line">片内总线</span><br><span class="line">系统总线：数据总线DB、地址总线CB、控制总线CB</span><br><span class="line">外部总线</span><br><span class="line"></span><br><span class="line">CPU：运算寄存器ALU、控制器、寄存器（状态寄存器、通用寄存器）</span><br><span class="line">取指、译码、执行、写回、跳转。pc指针多32位。</span><br><span class="line"></span><br><span class="line">什么是操作系统</span><br><span class="line">操作系统：有效地管理计算机系统中的资源，合理地管理计算机系统的工作流程，方便用户使用的程序的集合。</span><br><span class="line"></span><br><span class="line">操作系统五大任务</span><br><span class="line">(1)文件管理</span><br><span class="line">(2)处理器管理</span><br><span class="line">(3)内存管理</span><br><span class="line">(4)设备管理</span><br><span class="line">(5)作业管理</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/2.jpg" class="">

<h5 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">体系结构:linux内核被划分为多个子系统。基本服务都集成到内核中,例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。（收包和发包产生大量中断，放在内核最有效率）。</span><br><span class="line">主要子系统：</span><br><span class="line">（1）系统调用接口</span><br><span class="line">（2）进程管理</span><br><span class="line">（3）内存管理：其中，为每个子程序提供了一个2^32虚拟内存。</span><br><span class="line">为n个进程提供访问的物理空间、段式管理和页式管理就行了。linux进程并发模型.</span><br><span class="line">（4）虚拟文件系统（VFS）：虚拟文件系统 在 系统调用层接口（SCI ）和内核所支持的文件系统之间提供了一个交换层。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展： Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供MMU的处理器上运行。Linux 内核的uClinux移植提供了对非 MMU 的支持</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/3.jpg" class="">


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>联发科面试</title>
    <url>/My-interview-Lover/%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/MySql-Lover/%E5%8A%A1/</url>
    <content><![CDATA[<h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</span><br><span class="line">事务的 ACID 特性：原子性、一致性、隔离性、持续性。</span><br><span class="line">事务是并发控制的基本单位。</span><br><span class="line">并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</span><br><span class="line">脏读：就是指当一个事务对数据进行了修改但还没有提交到数据库时，另一个事务访问并使用了这个数据。</span><br><span class="line">不可重复读：在一个事务内两次读数据之间，第二个事务访问该数据并进行了修改。</span><br><span class="line">丢失修改：两个事务读入同一数据并修改，T2提交的结果破坏了T1提交的结果。例如T1读A修改为A-1，T2也读A修改为A-1（实际上应该是读A-1，修改 为A-2）</span><br><span class="line">&lt;部分来源牛客网&gt;</span><br></pre></td></tr></table></figure>

<p>SHOW ENGINES;#开启事务<br>SET autocommit=0;<br>START TRANSACTION；<br>#处理<br>UPDATA account set  balance =100 where usename = ‘ming’;<br>ROLLBACK ;</p>
<p>__savepoint保存回滚</p>
<p>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点S<br>ELECT * FROM account;</p>
<p>扩展知识点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">恢复的实现技术:建立冗余数据,利用冗余数据实施数据库恢复。</span><br><span class="line">建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>少用全局变量</title>
    <url>/C-C-Lover/%E5%B0%91%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>全局变量</td>
<td>在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</td>
</tr>
<tr>
<td>局部变量</td>
<td>在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。</td>
</tr>
</tbody></table>
<p>__注意</p>
<p>全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。<br>滥用全局变量会造成不必要的常量频繁使用，特别当这个常量没有用宏定义“正名”时，代码阅读起来将万分吃力。</p>
<p>__有什么对策？</p>
<ol>
<li>能不用全局变量尽量不用。</li>
<li>如果不可避免需要用到，那能藏多深就藏多深。<br>1)如果只有某.c文件用，就static到该文件中，顺便把结构体定义也收进来；<br>2)如果只有一个函数用，那就static到函数里面去；<br>3)如果非要开放出去让人读取，那就用函数return出去，这样就是只读属性了；<br>4)如果非要遭人蹂躏赋值，好吧，我开放函数接口让你传参赋值<br>5)实在非要extern我，我还可以严格控制包含我.h档的对象，而不是放到公共的includes.h中被人围观，丢人现眼。<br>6）当一个模块里面的全局变量超过3个(含)时，就用结构体包起来吧。要归0便一起归0，省得丢三落四的。</li>
</ol>
<p>公众号：C/C++技术文章<br>参考资料：<br>【1】佚名. 全局变量、局部变量、静态全局变量、静态局部变量的区别<br>【2】佚名. 嵌入式C编程经验之全局变量猛于虎<br>【3】《C11标准文档》</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>华为面试</title>
    <url>/My-interview-Lover/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>自振荡产生正弦波、方波、三角波</title>
    <url>/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/</url>
    <content><![CDATA[<h4 id="振荡电路知识"><a href="#振荡电路知识" class="headerlink" title="振荡电路知识"></a>振荡电路知识</h4><h5 id="1、振荡条件"><a href="#1、振荡条件" class="headerlink" title="1、振荡条件"></a>1、振荡条件</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t1.jpg" class="">
<h5 id="2、起振、稳幅"><a href="#2、起振、稳幅" class="headerlink" title="2、起振、稳幅"></a>2、起振、稳幅</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t2.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(1)无输入源，起振信号源来自哪里？</span><br><span class="line">答：电器内部噪声以及电源接通扰动。</span><br><span class="line">(2)稳幅作用？</span><br><span class="line">答：信号输出幅度达到一定程度时，会失真。必须通过调幅限制，使得振幅平衡回到AF = 1。</span><br></pre></td></tr></table></figure>
<p>3、基本组成部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽放大电路</span><br><span class="line">▽反馈电路</span><br><span class="line">▽选频网络</span><br><span class="line">▽稳幅环节</span><br></pre></td></tr></table></figure>
<p>移相式正弦振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">扩展知识点：</span><br><span class="line">1. 电阻上的电压电流同相位</span><br><span class="line">2. 电感上的电流落后电压90°相位</span><br><span class="line">3. 电容上的电流超前电压90°相位</span><br></pre></td></tr></table></figure>
<p>RC振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注：Rf为热敏电阻。</span><br></pre></td></tr></table></figure>
<h4 id="课设设计：100Hz与5000Hz"><a href="#课设设计：100Hz与5000Hz" class="headerlink" title="课设设计：100Hz与5000Hz"></a>课设设计：100Hz与5000Hz</h4><h5 id="原理设计"><a href="#原理设计" class="headerlink" title="原理设计"></a>原理设计</h5><p>正弦波发生</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t6.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f0=1/(2π√R1R2C1C2)  </span><br><span class="line">①可以修改 R1 R2 C1 C2 来产生100Hz 和 5000Hz</span><br><span class="line">通过调节R1，R2，C1，C2的值，使得f0=100Hz。先取C1=100nF，C2=100nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=16K,R2=16K。</span><br><span class="line">为了方便调试，16k采用20k滑动变阻器。</span><br><span class="line">②通过调节R1，R2，C1，C2的值，使得f0=5000Hz。先取C1=1nF，C2=1nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=1K,R2≈640Ω。</span><br><span class="line">为了方便调试， 640Ω采用1k滑动变阻器</span><br></pre></td></tr></table></figure>
<p>正弦波转方波、三角波</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t7.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正弦波转方波：过零比较器</span><br><span class="line">方波转三角波: 积分放大器</span><br></pre></td></tr></table></figure>
<h5 id="proteus仿真"><a href="#proteus仿真" class="headerlink" title="proteus仿真"></a>proteus仿真</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t8.jpg" class="">

<h5 id="实物演示"><a href="#实物演示" class="headerlink" title="实物演示"></a>实物演示</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t9.jpg" class="">

<h5 id="课设总结"><a href="#课设总结" class="headerlink" title="课设总结"></a>课设总结</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我在这次课程设计中遇到，一直都调不出理想的波形，检查了很多东西，像接线问题、电路问题、电源问题、示波器问题地线问题等等，所以我总结出，对于要求精度很高的电路，一旦出现实际问题时，应该具备以下三个点：</span><br><span class="line">1.重新审查电路原理图，计算相关数据，运行仿真结果。</span><br><span class="line">2.元件器件的损坏或性能的影响，因为在这个放大电路中稍有偏差，结果就会相差很大，此次个人觉得时间较为紧迫，选择附近的元件卖家，结果性能远远达不到所需的要求。</span><br><span class="line">3.要有足够的耐心和冷静的思考，当图形出现差异时，冷静的思考是必不可少的。</span><br><span class="line">通过这次课程设计,我懂得了要完成一个电路的设计,理论基础是根基,实践操作是完成实物的重要部分,而创新能力则决定了一个电路的价值,因为设计一个电路,决不是简单地按课本的电路图进行焊接成型,我们要进行电路各个元件参数的计算,这个涉及我们所掌握的理论知识,元件的计算是设计中较为重要的一部分,计算准了,则设计出来的电路误差不大,否则,设计出来的电路性能指标跟要求相差甚远。</span><br><span class="line">最困难的是当电路出现错误是,如何检测出错误之处,如何排除错误,它考验了我们如何运用理论知识和实际的调试的能力, 这也是我大三这一年最需要注重和提高的地方。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>传感器的特点</title>
    <url>/Circuit-Lover/%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>1.什么叫传感器? </p>
<p>能够感受规定的被测量并按照一定规律转化成可用输出信号的器件或装置。</p>
<p>2、传感器共性是什么？<br>传感器的共性就是利用物理规律或物质的物理、生物、化学特性，将非电量信号（位移、速度、力等）输入转换成电量（电压、电流、电容等）输出。</p>
<p>3、传感器由哪些部分组成？<br>传感器一般是由敏感元件、转化元件和变换电路三部分组成。</p>
<p>4、改善传感器？<br>（1）差动技术<br>（2）平均技术<br>（3）补偿与修正<br>（4）干扰抑制<br>（5）稳定性处理</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>cvte面试</title>
    <url>/My-interview-Lover/te%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>文件夹系统目录</title>
    <url>/Linux-Lover/%E5%A4%B9%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><strong>文件夹系统目录</strong></p>
<table>
<thead>
<tr>
<th>文件目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。</td>
</tr>
<tr>
<td>/boot</td>
<td>Ubuntu内核和启动文件，比如vmlinuz-xxx。grub引导装载程序。</td>
</tr>
<tr>
<td>/cdrom</td>
<td>光盘</td>
</tr>
<tr>
<td>/dev</td>
<td>设备驱动文件  sda *磁盘驱动文件</td>
</tr>
<tr>
<td>/etc</td>
<td>存放一些系统配置文件，比如用户账号和密码文件，各种服务的起始地址。</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹，一般创建用户账户的时候，默认的用户主文件夹都会放到此目录下。</td>
</tr>
<tr>
<td>/lib</td>
<td>存放库文件</td>
</tr>
<tr>
<td>/media</td>
<td>此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到这个目录中。</td>
</tr>
<tr>
<td>/mnt</td>
<td>用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。</td>
</tr>
<tr>
<td>/opt</td>
<td>可选的文件和程序存放目录，给第三方软件放置的目录。</td>
</tr>
<tr>
<td>/root</td>
<td>root用户目录，也就是系统管理员目录。</td>
</tr>
<tr>
<td>/sbin</td>
<td>和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。</td>
</tr>
<tr>
<td>/run</td>
<td>运行有关的信息</td>
</tr>
<tr>
<td>/snap</td>
<td>包管理工具</td>
</tr>
<tr>
<td>/srv</td>
<td>服务相关目录。比如网络服务。</td>
</tr>
<tr>
<td>/sys</td>
<td>记录内核信息，虚拟文件系统。</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时目录</td>
</tr>
<tr>
<td>/var</td>
<td>存放一些变化的文件，比如日志文件</td>
</tr>
<tr>
<td>/usr</td>
<td>usr不是user的缩写，而是UNIX Software Resource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！  du -sh</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，数据放置到内存中，存放系统运行信息</td>
</tr>
</tbody></table>
<p>__ 其他:__<br> Cat /proc/cpuinfo   cpu信息<br>正常情况，应该是Owner可以读写，all可读，root可以修改可执行权限才对。<br>正常情况，对于目录，应该权限设定为744，对于文件默认权限应该设定为644。<br>用户私有文件，权限应该设定为600。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘文件、内存命令</title>
    <url>/Linux-Lover/%E5%86%85%E5%AD%98%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ls /dev/sd*</p>
<p>df：列出文件系统的整体磁盘使用量。主要查看个文件系统的使用量，<br>du:评估文件系统的磁盘使用量，主要查看单个文件的大小。<br>eg:du -h –max-depth=1  显示一层</p>
<p>磁盘的挂载和卸载mount和umount命令</p>
<p>sudo umount media/ming/MING    </p>
<p>mkdir udisk</p>
<p>sudo mount /dev/sdb1  /media/ming/udisk</p>
<p>sudo mount -o iocharset=utf8  /dev/sdb1 /media/ming/udisk //中文显示</p>
<p>分区挂载不能进行分区操作<br>sudo fdisk /dev/sdb</p>
<p>磁盘格式化<br>mkfs -t vfat /dev/sdx</p>
<p>3、磁盘格式化</p>
<p>   磁盘分区创建好以后就可以格式化磁盘，使用命令mkfs。如：<br>sudo mkfs -t vfat/dev/sdx<br>   把U盘拔了重插上去，防止报错</p>
<p>4、free  -h 查看内存 </p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C字符串常用函数</title>
    <url>/C-C-Lover/%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 操作随记</title>
    <url>/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令模式</span><br><span class="line"></span><br><span class="line">移动：首行gg 末行G</span><br><span class="line"></span><br><span class="line">复制：yy  粘贴p</span><br><span class="line"></span><br><span class="line">剪切：dd      留空剪切：D</span><br><span class="line"></span><br><span class="line">撤销：u   恢复：crtl +  r</span><br><span class="line"></span><br><span class="line">编辑模式（输入模式）</span><br><span class="line"></span><br><span class="line">i a     esc</span><br><span class="line"></span><br><span class="line">末行模式（尾行模式）。</span><br><span class="line"></span><br><span class="line">:w</span><br><span class="line"></span><br><span class="line">:q</span><br><span class="line"></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line">:q！</span><br><span class="line"></span><br><span class="line">：x   保存退出！！！！</span><br><span class="line"></span><br><span class="line">/ 查找</span><br><span class="line"></span><br><span class="line">：s/     g</span><br><span class="line"></span><br><span class="line">:%s/    g</span><br><span class="line"></span><br><span class="line">查看当前已经打开的文件名称：“:files”</span><br><span class="line">： esc    进入 退出</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/vim.jpg" class="">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随记命令(1)</title>
    <url>/Linux-Lover/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl +C    终止 <span class="built_in">cd</span> `</span><br><span class="line"></span><br><span class="line">df  -h      磁盘大小</span><br><span class="line"></span><br><span class="line">free -m     内存大小</span><br><span class="line"></span><br><span class="line">head -n  **.txt  文件头几行   默认10</span><br><span class="line"></span><br><span class="line">tail - n <span class="comment">##  ** .txt 文件末尾两行</span></span><br><span class="line"></span><br><span class="line">less 查看文件     ：q退出</span><br><span class="line"></span><br><span class="line"><span class="comment">#wc -lwc 统计文件内容信息（包含行数、单词数、字节数）</span></span><br><span class="line"></span><br><span class="line">         -l：表示lines，行数</span><br><span class="line"></span><br><span class="line">         -w：表示words，单词数  依照空格来判断单词数量</span><br><span class="line"></span><br><span class="line">         -c：表示bytes，字节数</span><br><span class="line"></span><br><span class="line">date 输出的形式：2018年3月24日星期六15:54:28</span><br><span class="line"></span><br><span class="line">date +%F 输出形式：2018-03-24</span><br><span class="line"></span><br><span class="line">date <span class="string">"+%F %T"</span>  ==输出的形式：2018-03-24 16:01:00</span><br><span class="line"></span><br><span class="line">==<span class="comment">#date “+%Y-%m-%d %H:%M:%S”</span></span><br><span class="line"></span><br><span class="line">date -d   <span class="string">"-1 day"</span>  <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"></span><br><span class="line">前天 -  后天 +</span><br><span class="line"></span><br><span class="line">cal  作用：用来操作日历的</span><br><span class="line"></span><br><span class="line">cal -1 本月</span><br><span class="line"></span><br><span class="line">cal -3 上 中 下</span><br><span class="line"></span><br><span class="line">cal   -y  2019 年份月历</span><br><span class="line"></span><br><span class="line">clear     / ctrl +L  清除终端</span><br><span class="line"></span><br><span class="line">ls   /  | wc<span class="_">-l</span>   管道的过滤使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls / |grep y</span></span><br><span class="line"></span><br><span class="line">hostname -f </span><br><span class="line"></span><br><span class="line">id  （包含用户id，用户组id，附加组id…）</span><br><span class="line"></span><br><span class="line">whoami   查看当前用户</span><br><span class="line"></span><br><span class="line">ps -ef 服务器进程   ps -ef  |grep http</span><br><span class="line"></span><br><span class="line">top 处理机资源占用情况</span><br><span class="line"></span><br><span class="line">du -sh 目录 查看目录大小</span><br><span class="line"></span><br><span class="line">service 服务名称  start stop  restart</span><br><span class="line"></span><br><span class="line">find  / -name      http    查找</span><br><span class="line"></span><br><span class="line">find  / -name      *.cof </span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 2986   killall 名称   杀死进程</span><br><span class="line"></span><br><span class="line">ifconfig      inet addr就是网卡的ip地址。</span><br><span class="line"></span><br><span class="line">reboot  启动</span><br><span class="line"></span><br><span class="line">shutdown   重启</span><br><span class="line"></span><br><span class="line">uptime 计算开机到现在的额时间</span><br><span class="line"></span><br><span class="line">uname  操作系统名称</span><br><span class="line"></span><br><span class="line">netstat -tnlp</span><br><span class="line"></span><br><span class="line">       -t：表示只列出tcp协议的连接；</span><br><span class="line"></span><br><span class="line">       -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</span><br><span class="line"></span><br><span class="line">       -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</span><br><span class="line"></span><br><span class="line">       -p：表示显示发起连接的进程pid和进程名称；</span><br><span class="line"></span><br><span class="line">man   cp 查看帮助文档</span><br><span class="line"></span><br><span class="line">软链接 （符号链接） ln -s   <span class="built_in">source</span>  target  </span><br><span class="line"></span><br><span class="line">硬链接 （实体链接）ln       <span class="built_in">source</span>  target</span><br><span class="line"></span><br><span class="line">Ctrl+s  阻止输入</span><br><span class="line"></span><br><span class="line">Ctrl+q  允许输入</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>cron /crontab 计划任务</title>
    <url>/Linux-Lover/ron-crontab-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>分 时 日  月  星期</p>
<p>四个符号：</p>
<p>*：表示取值范围中的每一个数字</p>
<p>-：做连续区间表达式的，要想表示1~7，则可以写成：1-7</p>
<p>/：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：*/10</p>
<p>,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6</p>
<p>问题1：每月1、10、22日的4:45重启network服务</p>
<p>45 4  1,10,22  * *  service network restart</p>
<p>问题2：每周六、周日的1:10重启network服务</p>
<p>10 1  *  * 6,0   service network restart</p>
<p>问题3：每天18:00至23:00之间每隔30分钟重启network服务</p>
<p>*/30 18-23  *  * *   service network restart</p>
<p>问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启</p>
<p>3,15 8-11  */2  * *   reboot</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>解压磁盘</title>
    <url>/Linux-Lover/%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<p>bzip2</p>
<p>bzip2 -z xxx</p>
<p>bzip2 -d xxx.gz</p>
<p>tar</p>
<p>tar -vcjf xxx xxx   bz2</p>
<p>tar -vxjf xxxx</p>
<p>tar -vczf xxx xxx  压缩gz</p>
<p>tar -vxzf xxxx  解压</p>
<p>rar</p>
<p>rar -a xxx.rar xxx   压缩</p>
<p>rar -x xxx.rar   解压</p>
<p>zip</p>
<p>zip -rv xxx.zip xxx   压缩</p>
<p>uzip -v xxx.zip   解压</p>
<p><strong>扩展硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">sudo fdisk - l</span><br><span class="line">sudo fdisk /dev/sda</span><br><span class="line">删除 分区：d</span><br><span class="line">新增 分区：n</span><br><span class="line">保存操作：w</span><br><span class="line">重启：reboot</span><br><span class="line">挂载磁盘</span><br><span class="line">在 home 下新建work作为这块磁盘挂载点</span><br><span class="line"><span class="comment"># mkdir  sda2</span></span><br><span class="line"><span class="comment"># sudo mount   /dev/sda2    /home/sda2</span></span><br><span class="line">设置开机磁盘自动挂载</span><br><span class="line"><span class="comment"># vi /etc/fstab</span></span><br><span class="line">添加行  /dev/sda2     /home/work   ext4   defaults, 0 1</span><br><span class="line">此时，磁盘已经挂好，查看挂好的磁盘</span><br><span class="line">参考：https://blog.csdn.net/u010801439/article/details/77676668</span><br></pre></td></tr></table></figure>
<p><strong>/dev/sda 磁盘不足</strong></p>
<p>#sudo apt-get autoclean<br> #sudo apt-get clean<br>#sudo apt-get autoremove<br>执行完后直接将/usr下释放了1G左右的空间。<br>整合碎片使用<br>参考：<a href="https://blog.csdn.net/itas109/article/details/83341149" target="_blank" rel="noopener">https://blog.csdn.net/itas109/article/details/83341149</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>设备地址</title>
    <url>/Linux-Lover/%E5%A4%87%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>电脑与板子连接路由（电脑连接Wifi）</p>
<p>192.168.0.128</p>
<p>192.168.0.255</p>
<p>255.255.255.0</p>
<p>00:0c:29:e3:61:25</p>
<p>板子</p>
<p>setenv ipaddr 192.168.0.50</p>
<p>setenv ethaddr 00:04:9f:04:d2:35</p>
<p>setenv gatewayip 192.168.0.1</p>
<p>setenv netmask 255.255.255.0</p>
<p>setenv serverip 192.168.0.128</p>
<p>saveenv</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>man手册</title>
    <url>/Linux-Lover/an%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h5 id="man"><a href="#man" class="headerlink" title="man"></a>man</h5><table>
<thead>
<tr>
<th align="center">代号</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Standard commands (标准命令)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">System calls (系统调用)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Libary functions （库函数）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Special device (设备说明)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">File formats (文件格式)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Game and toys (游戏娱乐)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">Miscellaneous (杂项)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Administrative commands(管理员命令)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">other  (存放内核文档)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>555概念及使用</title>
    <url>/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="常见波形"><a href="#常见波形" class="headerlink" title="常见波形"></a>常见波形</h5><img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/555-2.jpg" class="">
<h5 id="单稳态触发器"><a href="#单稳态触发器" class="headerlink" title="单稳态触发器"></a>单稳态触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单稳态触发器----用于脉冲波形的变换和定时、延时 (74121、MC14528)</span><br><span class="line">Tw = 0.7 RC</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/3.jpg" class="" title="波形变换">
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/4.jpg" class="" title="定时">
<h5 id="多谐振荡器"><a href="#多谐振荡器" class="headerlink" title="多谐振荡器"></a>多谐振荡器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">多谐振荡器----用于产生脉冲，没有稳定状态，只有两个暂稳态，从而产生自激振荡，无需外触发。</span><br><span class="line">T=0.7(R1C1+R2C2)</span><br></pre></td></tr></table></figure>

<h5 id="施密特触发器"><a href="#施密特触发器" class="headerlink" title="施密特触发器"></a>施密特触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">施密特触发器----用于脉冲波形的变换，尤其是将模拟量转换成数字波形</span><br><span class="line">具有回差：有两个触发翻转电平。输入信号增加时，在VT+处翻转；输入信号减小时，在VT- 处翻转。VT+-VT-称为回差电压，用ΔVT表示，所以其传输特性呈回线状。</span><br><span class="line">无记忆功能：施密特触发器的稳态要靠外加触发电压维持，信号撤除会导致电路状态的改变。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/5.jpg" class="">
<h5 id="555定时器"><a href="#555定时器" class="headerlink" title="555定时器"></a>555定时器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以经过内部链接构成施密特触发器。</span><br><span class="line">它的作用可以整流，整幅，以及整波。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/1.jpg" class="">

<table>
<thead>
<tr>
<th align="center">引脚</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1脚</td>
<td align="left">外接电源负端VSS或接地，一般情况下接地。</td>
</tr>
<tr>
<td align="center">2脚</td>
<td align="left">低触发端TL，该脚电压小于1/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">3脚</td>
<td align="left">输出端OUT。</td>
</tr>
<tr>
<td align="center">4脚</td>
<td align="left">直接清零端RST。当此端接低电平时，则时基电路不工作</td>
</tr>
<tr>
<td align="center">5脚</td>
<td align="left">CO为控制电压端。若此脚外接电压，则可改变内部两个比较器的基准电压，当该脚不用时，应将该脚串入一只0.01μF（103）瓷片电容接地，以防引入高频干扰。</td>
</tr>
<tr>
<td align="center">6脚</td>
<td align="left">高触发端TH，该脚电压大于2/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">7脚</td>
<td align="left">放电端。该端与放电管T的集电极相连</td>
</tr>
<tr>
<td align="center">8脚</td>
<td align="left">双极型时基电路VCC的范围是4.5 -16V，CMOS型时基电路VCC的范围为3-18V，一般用5V。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>Solidworks与PCB的结合</title>
    <url>/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<p>偶然的一次发现QAQ</p>
<p>PCB电路板与solidworks的完美结合</p>
<img src="/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/solidworks.jpg" class="">


<p>转载[<a href="https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]" target="_blank" rel="noopener">https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]</a></p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数电概念</title>
    <url>/Circuit-Lover/%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机51、32、合泰芯片基本了解之后？以前觉得没怎么在意，为什么32芯片和合泰，使用时要使能相应的时钟？而51却不用？</span><br><span class="line"></span><br><span class="line">可是随着电子产品集成度越来越高，功耗和发热越来越严重</span><br><span class="line">芯片厂商非常无奈也在开始想办法避免这个问题，而最直接</span><br><span class="line">的思路当然就是用多少功能就使能多少功能，对每个外设的</span><br><span class="line">时钟都设置了开关，让用户可以精确地控制，关闭不需要的设备</span><br><span class="line">，达到节省供电的目的。</span><br><span class="line">其实这样还有一个好处就是，不是每个外设都需要系统时钟那么高的频率。</span><br><span class="line"></span><br><span class="line">仅仅理解为节省资源的方式感觉还不够，后来思考下，才发现答案就来自数电中的锁存器和触发器，然后，又开始复习了。。。QAQ</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>继SolidWorks之后另一款3D软件的preo简单的学习</title>
    <url>/Mechanic-Lover/%E7%BB%A7SolidWorks%E4%B9%8B%E5%90%8E%E5%8F%A6%E4%B8%80%E6%AC%BE3D%E8%BD%AF%E4%BB%B6%E7%9A%84preo%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>1.组件中零件激活了之后要取消，直接ctrl+A即可。</p>
<p>2.颜色RGB</p>
<p>255  0  0  红色</p>
<p>248  255  247  白色</p>
<p>0     0    0  黑色</p>
<p>银白色  红(192) 绿(192) 蓝(192)。</p>
<p>染色过程中，高级的层次会覆盖掉低级的颜色</p>
<p>例如：总装配体&gt;子装配体&gt;零件</p>
<p>3.通过不定向，横截面的设置获取“正视于的效果”，配合参考选取视图。</p>
<p>4.仿真看着很单调，不过可以通过数据或者数学方程式驱动运动的轨迹，存在一个数据文档里；</p>
<p>钣金加工工艺（综合冷加工工艺）</p>
<p>下料 、成型、压铆，攻牙、焊接等</p>
<p>表面处理：喷粉，电镀等；</p>
<p>机床的知识<br>NC：数字控制，简称数控。<br>CNC：计算机数字控制，简称也是数控。NC是以前的数控，CNC是目前的数控，NC已经淘汰。另外，人们经常把加工中心叫做CNC。<br>DNC：在线加工。也就是一边传输程序，一边加工，用电脑控制数控机床在线加工。<br>2019-1-9 ming</p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统分类</title>
    <url>/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="Linux系统分类"><a href="#Linux系统分类" class="headerlink" title="Linux系统分类"></a>Linux系统分类</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一般来说，linux系统基本分为两大类</span><br><span class="line">Redhat系列:Redhat、Centos、Fedora等</span><br><span class="line">Debian系列:Debian、Ubuntu等</span><br></pre></td></tr></table></figure>

<h5 id="Redhat系列"><a href="#Redhat系列" class="headerlink" title="Redhat系列"></a>Redhat系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">商业用途，企业版，一般付费。</span><br><span class="line">rmp:包安装工具</span><br><span class="line">yum:程序与程序之间存在非常复杂的依赖关系。RPM无法解决软件包的依赖关系。</span><br></pre></td></tr></table></figure>

<h5 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">社区维护，桌面版，一般免费。</span><br><span class="line">dpkg:包安装工具</span><br><span class="line">apt-get:会解决和安装模块的依赖问题</span><br></pre></td></tr></table></figure>
<h5 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h5><img src="/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/example.jpg" class="">
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>模电概念</title>
    <url>/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h6 id="放大电路"><a href="#放大电路" class="headerlink" title="放大电路"></a>放大电路</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">放大电路模型:电压放大电路、电流放大电路</span><br><span class="line">放大电路的性能：输入电阻、输出电阻、增益、频率响应及带宽。</span><br></pre></td></tr></table></figure>
<h6 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同相电路</span><br><span class="line">反相电路</span><br><span class="line">求和电路</span><br><span class="line">求差电路</span><br><span class="line">差分电路</span><br><span class="line">积分电路</span><br><span class="line">微分电路</span><br><span class="line">·····</span><br></pre></td></tr></table></figure>
<h5 id="晶体三极管及其基本放大电路（BJT）"><a href="#晶体三极管及其基本放大电路（BJT）" class="headerlink" title="晶体三极管及其基本放大电路（BJT）"></a>晶体三极管及其基本放大电路（BJT）</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">外部条件：发射结正偏，集电结反偏</span><br><span class="line">共发射极、共基极、共集电极</span><br></pre></td></tr></table></figure>
<h5 id="场效应三极管及其放大电路"><a href="#场效应三极管及其放大电路" class="headerlink" title="场效应三极管及其放大电路"></a>场效应三极管及其放大电路</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">沟道中只有一种类型的载流子参与导电，所以场效应管也称为单极型三极管。</span><br><span class="line">共源极、共栅极、共源极</span><br></pre></td></tr></table></figure>
<h4 id="模拟开关与多路复用器区别"><a href="#模拟开关与多路复用器区别" class="headerlink" title="模拟开关与多路复用器区别"></a>模拟开关与多路复用器区别</h4><p>对信号通路进行选择，或者档位切换，想问模拟通道开关和多路复用器有什么区别？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">模拟开关和多路复用器件其实在电气上，或者架构上，原理上没什么区别。</span><br><span class="line">多路复用的话主要用在通道数比较多的场合，例如：4输入1输出，16输入1输出。</span><br><span class="line">模拟/数字开关主要用于通道数目比较小的。低导通电阻，根据应用需求不同；模拟开关可以分为音频模拟开关、视频模拟开关。</span><br></pre></td></tr></table></figure>
<h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><h5 id="MOS、NMOS、PMOS、COMS概念"><a href="#MOS、NMOS、PMOS、COMS概念" class="headerlink" title="MOS、NMOS、PMOS、COMS概念"></a>MOS、NMOS、PMOS、COMS概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MOS管导通特性，相当于开关闭合。</span><br><span class="line">NMOS的特性，Vgs大于一定的值就会导通，适合用于源极接地时的情况，只要栅极电压达到4V或10V就可以了。导通电阻小，且容易制造，市场广泛应用。</span><br><span class="line">PMOS的特性，Vgs小于一定的值就会导通，适合用于源极接VCC时的情况。导通电阻大，价格贵，替换种类少，通常还是使用NMOS。</span><br><span class="line">CMOS的产生？</span><br><span class="line">一、阈值损</span><br><span class="line">NMOS 传输高电平有阈值损（Vtn），低电平则没有；</span><br><span class="line">PMOS 传输低电平有阈值损（Vtp），高电平则没有。</span><br><span class="line">CMOS 互补结构则利用了上述“互补”特性，传输高低电平时都没有阈值损。</span><br><span class="line">二、线性</span><br><span class="line">NMOS 或 PMOS 单管。</span><br><span class="line">利用两管导通电流的“互补”特性，使得导通电流特性呈“高线性”。</span><br><span class="line">三、功耗</span><br><span class="line">主要差别在功耗上，NMOS和PMOS工作时至少有一个导通，而CMOS导通的时间很短，功耗明显降低</span><br></pre></td></tr></table></figure>
<h4 id="CMOS-与-TTL"><a href="#CMOS-与-TTL" class="headerlink" title="CMOS 与 TTL"></a>CMOS 与 TTL</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMOS是场效应晶体管，TTL是双极晶体管2。</span><br><span class="line">COMS具有较宽的逻辑电平范围（5-15V），TTL只能在5V下工作。</span><br><span class="line">CMOS的高低电平差异较大，抗干扰能力强，TTL差小，抗干扰能力差。</span><br><span class="line">CMOS功耗很小，TTL功耗大（1-5mA/门）</span><br><span class="line">CMOS的工作频率略低于TTL，但其高速CMOS几乎与TTL相同。</span><br><span class="line">TTL高电平3.6~5V，低电平0V~2.4V_</span><br><span class="line">CMOS电平VCC可达到12V_</span><br><span class="line">CMOS电路的高电平输出约为0.9VCC，低电平输出约为0.1VCC。</span><br><span class="line">CMOS电路不使用的输入端不能挂起，会引起逻辑混乱。</span><br><span class="line">TTL电路不使用的输入端空旷为高电平_</span><br><span class="line">另外，由于CMOS集成电路的电源电压变化范围大，对电源的要求不如TTL集成电路严格。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
</search>
