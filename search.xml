<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>QT-画面滑动切换</title>
    <url>/QT-Lover/QT-%E7%94%BB%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*widget.h*&#x2F;</span><br><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QMouseEvent&gt;</span><br><span class="line">#include &lt;QEvent&gt;</span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">     bool eventFilter(QObject *watched, QEvent *event);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*widget.c*&#x2F;</span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    this-&gt;installEventFilter(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line">bool Widget::eventFilter(QObject *watched, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">       static int press_x;</span><br><span class="line">       static int press_y;</span><br><span class="line">       static int release_x;</span><br><span class="line">       static int release_y;</span><br><span class="line">       </span><br><span class="line">QMouseEvent*  event_1 &#x3D; static_cast&lt;QMouseEvent *&gt; (event);</span><br><span class="line"></span><br><span class="line">    if(event_1-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress )</span><br><span class="line">    &#123;</span><br><span class="line">            press_x &#x3D; event_1-&gt;globalX();</span><br><span class="line">            press_y &#x3D; event_1-&gt;globalY();</span><br><span class="line">    &#125;</span><br><span class="line">    if(event_1-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonRelease)</span><br><span class="line">    &#123;</span><br><span class="line">            release_x &#x3D; event_1-&gt;globalX();</span><br><span class="line">            release_y &#x3D; event_1-&gt;globalY();</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*******判断左滑动*******&#x2F;</span><br><span class="line">	if(  ((release_x -press_x) &lt; 0)  &amp;&amp; ((release_y - press_y) &gt; 0)   &amp;&amp; (event_1-&gt;type()&#x3D;&#x3D; QEvent::MouseButtonRelease))</span><br><span class="line">    &#123;</span><br><span class="line">	int current_page &#x3D; ui-&gt;stackedWidget-&gt;currentIndex();</span><br><span class="line"></span><br><span class="line">        if(current_page &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">	ui-&gt;stackedWidget-&gt;setCurrentIndex(current_page - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current_page &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;stackedWidget-&gt;setCurrentIndex(4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;********判断右滑动********&#x2F;</span><br><span class="line">    if(  ((release_x -press_x) &gt; 0)  &amp;&amp; ((release_y - press_y) &lt; 0)   &amp;&amp; (event_1-&gt;type()&#x3D;&#x3D; QEvent::MouseButtonRelease))</span><br><span class="line">    &#123;</span><br><span class="line">	int current_page &#x3D; ui-&gt;stackedWidget-&gt;currentIndex();</span><br><span class="line">        if(current_page &lt; 4)</span><br><span class="line">        &#123;</span><br><span class="line">  ui-&gt;stackedWidget-&gt;setCurrentIndex(current_page + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current_page &#x3D;&#x3D; 4)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;stackedWidget-&gt;setCurrentIndex(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return QWidget::eventFilter(watched,event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="/QT-Lover/QT-%E7%94%BB%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2/cat.gif" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-ui快捷背景小记</title>
    <url>/QT-Lover/QT-ui%E5%BF%AB%E6%8D%B7%E8%83%8C%E6%99%AF%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>控件背景</strong></p>
<p>右键改变样式<br>写法1<br>#pushButton{<br>background:url(“:/new/prefix1/数字1.png”)<br>}<br>写法2<br>background:url(:/new/prefix1/cat.png);<br>background-image: url(:/new/prefix1/cat.png);</p>
<p>注意：background是一个集合，它包括background-color,background-image,background-size</p>
<p>border-image: url(:/new/prefix1/数字1.png);//文件<br>image: url(:/new/prefix1/cat.png);//文件原大小，多余为空白</p>







<p><strong>函数背景</strong></p>
<p>写法1：<br>setAutoFillBackground(true);<br>QPalette pal = this-&gt;palette();  pal.setBrush(backgroundRole(),QPixmap(“:/new/prefix1/MING.png”));<br>setPalette(pal);</p>
<p>注：设置的项目基类为Widget的时候，不能用setstylesheet设置widget的背景图片。</p>
<p>this-&gt;setStyleSheet( iconStyleSheet );<br>ui-&gt;pushButton-&gt;setStyleSheet(“#pushButton{background-image: url(:/new/prefix1/数字5.png);}”);</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-休眠函数</title>
    <url>/QT-Lover/QT-%E4%BC%91%E7%9C%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>方式一</strong></p>
<p>使用QElapsedTimer：会阻塞线程头文件：<br>#include <QElapsedTimer></p>
<p>QElapsedTimer t;<br>t.start();<br>while(t.elapsed()&lt;10000)</p>
<pre><code> QElapsedTimer timer;
    int count = 1;
    timer.start();
    do {
        count *= 2;
        slowOperation2(count);
    } while (timer.restart() &lt; 250);
return count;</code></pre><p> <strong>方式二</strong><br>自定义延时函数：不会阻塞当前线程使用QEventLoop<br>void Widget::Sleep(int msec)<br>{<br>    QTime dieTime = QTime::currentTime().addMSecs(msec);<br>    while( QTime::currentTime() &lt; dieTime )<br>        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);<br>}<br> 进入消息循环，不仅处理当前事件，而且处理其它事件<br>QCoreApplication::processEvents(QEventLoop::AllEvents, 100);</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull多线程测试（二）</title>
    <url>/Linux-Lover/imx6ull%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>用继承 QObject 的方法来创建多线程：<br>（1）写一个继承 QObject 的类，并把复杂耗时的操作声明为槽函数。<br>（2）在主线程（ui 线程）中 new 一个继承 Object 类的对象，不设置父类。<br>（3）声明并 new 一个 QThread 对象。（如果 QThread 对象没有 new 出来，则需要在 QObject类析构的时候使用 QThread::wait()等待线程完成。如果是通过堆分配（new 方式），则可以通过 deleteLater 来进行释放）<br>（4）使用 QObject::moveToThread(QThread*)方法，把 QObject 对象转移到新的线程中。<br>（5）把线程的finished()信号与QObject的deleteLater()类连接，这个是安全释放线程的关键，不连接的话，会导致内存泄漏。<br>（6）连接其他信号槽，如果是在连接信号槽之前调用 moveToThread，不需要处理 connect<br>函数的第五个参数，这个参数是表示信号槽的连接方式；否则，如果在连接所有信号槽之后再调用 moveToThread，则需要显式声明 Qt::QueuedConnection 来进行信号槽连接。</p>
<iframe src="//player.bilibili.com/player.html?aid=626236088&bvid=BV1Zt4y197gL&cid=206373278&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  height="600" width="100%"> </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull多线程测试（一）</title>
    <url>/Linux-Lover/imx6ull%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>参考来源：微联智控工作室 感谢QAQ</p>
<p>在 QT 开发过程中，使用多线程，有两种方法：<br>方法一：继承 QThread 的 run() 函数，把复杂的循环逻辑放在 run() 函数中执行。<br>方法二：把一个继承于 QObject 的类，使用 moveToThread() 方法，转移到一个 QThread 的类对象中。</p>
<p>方法一：继承 QThread  类，重载 run() 方法</p>
<p>继承 QThread  类，创建线程对象后，只有 run() 方法运行在新的线程里，类对象里面的其他方法都在创建 QThread  类的线程里运行。</p>
<p>1 、在ui 线程中，调用了继承 QThread 类里面的方法，会不会造成ui卡顿。<br>答：并不会造成 ui 卡顿。<br>2 、在ui 线程中,调用了 Thread::quit()/QThread::exit()/ QThread::terminate() 会不会停止线程。<br>答：只有QThread::terminate() 可以正真的停止线程</p>
<p>3 、 如何安全地退出一个线程？<br>答：m_thread-&gt;stopImmediately(); //调用这个函数，安全退出线程</p>
<p>线程结束，会发射 finish()信号，槽函数 onQThreadFinished()<br>即会被调用。</p>
<p>4 、 如何正确地启动一个线程？<br>（1）如何正确地启动一个全局线程？<br>（2） 如何正确地启动一个局部线程？</p>
<p>一个按钮出发两次子函数现象？<br>注：connect(ui&gt;pushButton_doSomthing,SIGNAL(clicked()),this,SLOT(on_pushButton_doSomthing_clicked()),Qt::UniqueConnection);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*在这里创建了一个全局线程*&#x2F;</span><br><span class="line">m_thread &#x3D; new ThreadfromQThread(this);</span><br><span class="line">    connect(m_thread,SIGNAL(message(QString)),this,SLOT(receiveMessage(QString)));  &#x2F;&#x2F;接收message信号，在窗口打印线程信息</span><br><span class="line">    connect(m_thread,SIGNAL(progress(int)),this,SLOT(progress(int)));&#x2F;&#x2F;接收progress信号，更新进度条</span><br><span class="line">    connect(m_thread,SIGNAL(finished()),this,SLOT(onQThreadFinished()));&#x2F;&#x2F;接收线程结束信号，打印线程结束的消息</span><br><span class="line"> m_heart.start();   &#x2F;&#x2F;启动定时器，不断更新heartbeat进度条</span><br><span class="line"></span><br><span class="line"> &#x2F;*局部线程*&#x2F;</span><br><span class="line">this-&gt;m_currentRunLoaclThre &#x3D; NULL;</span><br><span class="line">------------全局析构----------------</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;start destroy widget&quot;;</span><br><span class="line">    m_thread-&gt;stopImmediately();&#x2F;&#x2F;由于此线程的父对象是Widget，因此退出时需要进行判断</span><br><span class="line">    m_thread-&gt;wait();   &#x2F;&#x2F;在这里，会阻塞等待线程执行完</span><br><span class="line">    delete ui;</span><br><span class="line">    qDebug() &lt;&lt; &quot;end destroy widget&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------子函数---------------</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_qthreadRunLocal_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;判断这个局部线程是否已经存在，如果已经存在，则先退出</span><br><span class="line">    if(this-&gt;m_currentRunLoaclThre)</span><br><span class="line">    &#123;</span><br><span class="line">         this-&gt;m_currentRunLoaclThre-&gt;stopImmediately();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadfromQThread* thread &#x3D; new ThreadfromQThread(NULL);</span><br><span class="line">    &#x2F;&#x2F;这里父对象指定为NULL</span><br><span class="line">   connect(thread,SIGNAL(message(QString)),this,SLOT(receiveMessage(QString)));</span><br><span class="line">   &#x2F;&#x2F;接收message信号，在窗口打印线程信息</span><br><span class="line">  connect(thread,SIGNAL(progress(int)),this,SLOT(progress(int)));</span><br><span class="line">  &#x2F;&#x2F;接收progress信号，更新进度条</span><br><span class="line">  connect(thread,SIGNAL(finished()),this,SLOT(onQThreadFinished()));</span><br><span class="line">  &#x2F;&#x2F;接收线程结束信号，打印线程结束的消息</span><br><span class="line">    connect(thread,SIGNAL(finished()),thread,SLOT(deleteLater()));&#x2F;&#x2F;线程结束后调用deleteLater来销毁分配的内存</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;线程销毁时，会发送destroyed信号，然后把临时变量再次赋值为NULL</span><br><span class="line"> connect(thread,SIGNAL(destroyed(QObject*)),this,SLOT(onLocalThreadDestroy(QObject*)));</span><br><span class="line">    thread-&gt;setRunCount(5);</span><br><span class="line">    thread-&gt;start();</span><br><span class="line">    &#x2F;&#x2F;启动线程，执行run()函数</span><br><span class="line">    this-&gt;m_currentRunLoaclThre &#x3D; thread;  </span><br><span class="line">    &#x2F;&#x2F;保存当前正在运行的线程</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;局部线程销毁函数，</span><br><span class="line">void Widget::onLocalThreadDestroy(QObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">   if(qobject_cast&lt;QObject *&gt;(m_currentRunLoaclThre) &#x3D;&#x3D; obj)</span><br><span class="line">   &#123;</span><br><span class="line">        m_currentRunLoaclThre &#x3D; NULL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全局线程</strong></p>
<p>   会在创建时，把 ui 线程作为自己的父对象，当 ui 线程析构时，全局线程也会进行销毁。但此时，应该关注一个问题：当 ui 线程结束（窗体关闭）时，全局线程还没有结束，应当如何处理？如果没有处理好这种情况，在 ui 线程析构时，强行退出全局线程，会导致程序崩溃。往往这种线程的生命周期是伴随着 ui 线程一起开始与结束的。</p>
<p><strong>局部线程</strong></p>
<p>  也叫临时线程，这种线程一般是要进行一些耗时任务，为了防止 ui 线程卡死而存在的。同样地，我们更关注以下问题：在局部线程运行期间，如果因为某些因素要停止线程，该如何安全地退出局部线程？例如，在图片打开期间（还没有完全打开），要切换图片，该如何处理。在音乐播放期间，要切换下一首音乐，应如何处理。如果手动 delete 了线程指针，程序会很容易崩溃。正确的退出方法，可以使用 void QObject::deleteLater() [SLOT] 这个槽函数。</p>
<iframe src="//player.bilibili.com/player.html?aid=796213214&bvid=BV1oC4y187Ty&cid=205802849&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%"> </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull串口测试</title>
    <url>/Linux-Lover/imx6ull%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><strong>imx6ull串口测试</strong></p>
<iframe src="//player.bilibili.com/player.html?aid=883559512&bvid=BV17K4y147YL&cid=204200631&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%" > </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>usb烧录系统启动内核失败</title>
    <url>/Linux-Lover/usb%E7%83%A7%E5%BD%95%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>出现“Starting kernel …”以后就再也没有任何信息输出了，说明Linux 内核启动失败了。</p>
<p>解决Linux 内核启动失败</p>
<p>mmc dev 1  //切换到 EMMC<br>ls mmc 1:1  //输出 EMMC1 分区 1 中的所有文件</p>
<p>setenv bootcmd ‘mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb;bootz 80800000 - 83000000’</p>
<p>setenv bootargs ‘console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw’</p>
<p>saveenv</p>
<p>2 、修改 uboot<br>uboot 源码。打开 uboot 源码中的文件include/configs/mx6ull_alientek_emmc.h<br>在宏 CONFIG_EXTRA_ENV_SETTINGS</p>
<p>“findfdt=”<br> “if test $fdt_file = undefined; then “ <br> “setenv fdt_file imx6ull-alientek-emmc.dtb; “ <br>“fi;\0” \</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>进一步了解qt项目文件</title>
    <url>/QT-Lover/%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3qt%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6-0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u011012932/article/details/51774724" target="_blank" rel="noopener">https://blog.csdn.net/u011012932/article/details/51774724</a></p>
<p>看到一个人ffmpeg调用中的项目写法很特别，记录下QvQ</p>
<p>项目.pro</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET     &#x3D; ffmpegdemo</span><br><span class="line">TEMPLATE    &#x3D; app</span><br><span class="line">MOC_DIR     &#x3D; temp&#x2F;moc      &#x2F;&#x2F;指定来自moc的所有中间文件放置的目录</span><br><span class="line">RCC_DIR     &#x3D; temp&#x2F;rcc     &#x2F;&#x2F;指定Qt资源编译器输出文件的目录</span><br><span class="line">UI_DIR      &#x3D; temp&#x2F;ui     &#x2F;&#x2F;指定所有中间文件.o（.obj）放置的目录。</span><br><span class="line">OBJECTS_DIR &#x3D; temp&#x2F;obj      &#x2F;&#x2F;指定来自uic的所有中间文件放置的目录</span><br><span class="line">message($$DESTDIR)</span><br><span class="line">DESTDIR     &#x3D; $$PWD&#x2F;..&#x2F;bin  			 &#x2F;&#x2F;指定在何处放置目标文件。</span><br><span class="line">message($$DESTDIR)</span><br><span class="line"></span><br><span class="line">#ffmpeg3表示用ffmpeg3版本 可以改成ffmpeg4表示用ffmpeg4版本</span><br><span class="line">#qt32表示采用32位的ffmpeg 可以改成qt64表示采用64位的ffmpeg</span><br><span class="line">DEFINES     +&#x3D; ffmpeg4 qt64    		 &#x2F;&#x2F;qmake添加这个变量的值作为编译器C预处理器宏</span><br><span class="line">SOURCES     +&#x3D; main.cpp widget.cpp</span><br><span class="line">HEADERS     +&#x3D; widget.h</span><br><span class="line">FORMS       +&#x3D; widget.ui   </span><br><span class="line">CONFIG      +&#x3D; warn_off</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;ffmpeg         &#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line">include ($$PWD&#x2F;ffmpeg&#x2F;ffmpeg.pri)     &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>子项目.pri</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEADERS     +&#x3D; $$PWD&#x2F;ffmpeghead.h</span><br><span class="line">HEADERS     +&#x3D; $$PWD&#x2F;ffmpeg.h</span><br><span class="line">SOURCES     +&#x3D; $$PWD&#x2F;ffmpeg.cpp</span><br><span class="line"></span><br><span class="line">#ffmpeg4则使用ffmpeg4的目录</span><br><span class="line">contains(DEFINES, ffmpeg4) &#123;</span><br><span class="line">strPath &#x3D; ffmpeg4</span><br><span class="line">&#125; else &#123;</span><br><span class="line">strPath &#x3D; ffmpeg3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#32位的库则使用32位的库的头文件和lib文件</span><br><span class="line">contains(DEFINES, qt32) &#123;</span><br><span class="line">strLib &#x3D; winlib</span><br><span class="line">strInclude &#x3D; include</span><br><span class="line">&#125; else &#123;</span><br><span class="line">strLib &#x3D; winlib64</span><br><span class="line">strInclude &#x3D; include64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;$$strPath&#x2F;$$strInclude   </span><br><span class="line">&#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line"></span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;$$strPath&#x2F;$$strInclude&#x2F;plugins </span><br><span class="line">&#x2F;&#x2F;指定编译项目时应该被搜索的#include目录。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定链接到项目中的库列表。</span><br><span class="line">win32 &#123; </span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;$$strPath&#x2F;$$strLib&#x2F; -lavcodec -lavfilter -lavformat -lswscale -lavutil -lswresample -lavdevice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#请自行替换</span><br><span class="line">unix &#123;</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;linuxlib&#x2F; -lavfilter -lavformat -lavdevice -lavcodec -lswscale -lavutil -lswresample -lavdevice -lpthread -lm -lz -lrt -ldl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt上第三方串口类QExtSerialPort</title>
    <url>/QT-Lover/t%E4%B8%8A%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%B2%E5%8F%A3%E7%B1%BBQExtSerialPort/</url>
    <content><![CDATA[<p>在win下使用<br>qextserialbase.cpp<br>qextserialbase.h<br>qextserialport.cpp<br>qextserialport.h<br>win_qextserialport.cpp<br>win_qextserialport.h</p>
<p>在linux下使用<br>qextserialbase.cpp<br>qextserialbase.h<br>qextserialport.cpp<br>qextserialport.h<br>posix_qextserialport.cpp<br>posix_qextserialport.h。</p>
<p>工程文件.pro</p>
<p>DEFINES += QT_DEPRECATED_WARNINGS <em>TTY_POSIX</em><br>qmake添加这个变量的值作为编译器C预处理器宏(-D选项)。<br>然后就可以在代码中使用：<br>#ifdef QT_DEPRECATED_WARNINGS<br>    // TODO<br>#else<br>    // TODO<br>#endif</p>
<p>常见 使用</p>
<p>struct PortSettings portSettings;</p>
<p>portSettings = { BAUD57600, DATA_8, PAR_NONE, STOP_1, FLOW_OFF, 2 };</p>
<p>串口设置时需要先将串口打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QString _SerialPortName &#x3D; &quot;\\\\.\\&quot;;</span><br><span class="line">_SerialPortName.append(PortName);</span><br><span class="line">SerialPort &#x3D; new Win_QextSerialPort(_SerialPortName, QextSerialBase::Polling);</span><br><span class="line"></span><br><span class="line">if (SerialPort-&gt;open(QIODevice::ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">	SerialPort-&gt;setBaudRate(portSettings.BaudRate);</span><br><span class="line">	SerialPort-&gt;setParity(portSettings.Parity);</span><br><span class="line">	SerialPort-&gt;setStopBits(portSettings.StopBits);</span><br><span class="line">	SerialPort-&gt;setDataBits(portSettings.DataBits);</span><br><span class="line">	&#x2F;&#x2F;	SerialPort-&gt;setTimeout(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节读写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QSerialPort-&gt;putChar(c);</span><br><span class="line">QSerialPort-&gt;getChar(c);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器层面</title>
    <url>/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>Cache</strong></p>
<p>统一的cache：数据指令一起<br>哈佛Cache：数据指令分开</p>
<p>存储内容动态变化，必须保存存储数据以及主存储器的地址。</p>
<p>存储管理单元MMU—多个活动程序快速切换</p>
<p>存储器管理的两种基本方法：段式管理和页式管理。</p>
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/%E6%AE%B5.jpg" class="">
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/%E9%A1%B5.jpg" class="">

<p>高10位：页目录<br>次高10位：页表<br>12位：页结构（数据）</p>
<img src="/ARM-Lover/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E9%9D%A2/64%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" class="">


<p>虚拟内存是操作系统物理内存和进程之间的中间层，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。<br>64位，每个进程的虚拟内存空间是完全独立的，所以它们都可以完整的使用 0x0000000000000000 到 0x00007FFFFFFFFFFF 的全部内存。<br>此内核虚拟地址范围总计为 256 TB，但实际在使用的是8TB<br>X64 CPU 已经限制了虚拟地址中可用的比特数为 48 位，Windows 做出了进一步的限制，将其削减为 44 位。</p>
<p>32位地址数 2^32 * 1024<em>1024</em>1024<em>8<br>32内存容量  2^32 * 1024</em>1024*1024 =4G<br>TiB    2的40   TB 10的12次</p>
<p>Linux默认页大小是4KB？0-11  2的12次<br>过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找速度和额外开销；<br>过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；</p>
<p>Linux 在 2.6.10 中引入了四层的页表辅助虚拟地址的转换，在 4.11 中引入了五层的页表结构，在未来还可能会引入更多层的页表结构以支持 64 位的虚拟地址。</p>
<p>32位中<br>10+10+12  4G</p>
<p>64，为什么每层的页表结构只能够负责 9位虚拟地址的寻址？<br>规定48位虚拟地址。9+9+9+9+12<br>64 位的虚拟内存在操作系统中需要多少层的页表结构才能寻址？<br>6</p>
<p><strong>ARM系统控制协处理器</strong></p>
<p>ARM系统控制协处理器是一个片上协处理器,使用逻辑协处理器号15,控制片上Cache或Cache,<br>存储器管理或保护单元、写缓冲器、预取缓冲器、转移目标Cache以及系统配置信号操作。</p>
<p><strong>CP15指令</strong></p>
<p>MRC MCR</p>
<p><strong>MMU存储器管理单元（Memory Management Unit）</strong></p>
<p>MMU完成两个基本功能:<br>1、将虚拟地址转换为物理地址。<br>2、控制存储器访问权限,中止非法访问</p>
<p>转化 ：虚拟地址-》物理地址</p>
<p>虚拟地址-》CP15寄存器2（转化表基地址）-》主存储器的物理地址</p>
<p>注意：小型嵌入式系统甚至可能连这种开销也不能承受,或者可能只有非常简单的调度”需求(例如在所有时间里只执行1个固定程序，根本不需要一个“操作系统”。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM流水线</title>
    <url>/ARM-Lover/ARM%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p><strong>3级流水线</strong></p>
<p>1.取指<br>从存储器中取出指令,放人指令流水线。<br>2.译码<br>指令被译码,并为下一周期准备数据通路的控制信号。在这一级,指令占有详码理辑,不占有数据通路。<br>3.执行<br>指令占有数据通路,寄存器堆被读取,操作数被移位, ALU（算数逻辑单元）产生结果并回写到目的寄存器。</p>
<p>（1）STR计算地址、数据传送。<br>（2）所有指令都占用数据通路一个或多个相邻周期。<br>（3）在指令占用数据通路的每一个周期,都在前面的相邻周期占有译码逻辑在第一个数据通路周期,每条指令为下下条指令发出取指信号。<br>（4）转移指令清空(flush)和重填指令流水线。</p>
<p>PC指向当前指令后的8个字节（两条指令）</p>
<p><strong>5级流水线</strong></p>
<p>所有的处理器都要满足对高性能的要求。直到ARM7为止,在ARM核中使用的”3级流水线的性价比是很高的。但是,为了得到更高的性能,需要重新考虑处理器的组织结构。</p>
<p>CPI：每条指令的平均周期数</p>
<p>冯·诺依曼瓶颈有关–指令和数据放在同一个存储器的任何存储程序计算机,其性能将受到现有存储器带宽的限制。</p>
<p>使用5级流水线的ARM处理器具有下流水线级:</p>
<p>1、取指<br>从存储器中取出指令,并将其放入指令流水线。<br>2、译码<br>指令披译码,从寄存器堆中读取寄存器操作数。在寄存器堆中有3个操作数读端口,因此,大多数ARM指令能在1个周期内读取其操作数。译码级已经开始从寄存器堆中读取寄存器操作数，这样的话,<br>读取到得就是PC+4，不是PC+8。<code>数据前推的方式</code></p>
<p>3、执行<br>把一个操作数移位,产生ALU的结果,如果指令是load或Store,则在ALU中i算存储器的地址。<br>4、缓冲/数据<br>如果需要,则访问数据存储器;否则AL.U的结果只是简单地缓冲1个时钟周期,以便使所有的指令具有同样的流水线流程。<br>5、回写<br>将指令产生的结果回写(writeback)到寄存器堆,包括任何从存储器中读取的数据。</p>
<p><strong>向下兼容的必要性</strong></p>
<p>PC+4，直接送到译码级的寄存器文件(file),穿过两级之间的流水线寄存器。下一条指令的PC+4等于当前指令的PC+8,因此,未使用额外的硬件便得到了正确的r15.</p>
<p><strong>ARM操作模式</strong></p>
<p>|CPSR[4:0]当前状态寄存器|模式|用途<br>|-|-|<br>|10000|用户|正常用户模式|<br>|10001|FIQ|处理快速中断|<br>|10010|IRQ处理标准中断处理||<br>|10011|SVC|软件中断|<br>|10100|中止|处理存储器故障|<br>|10111|未定义|处理未定义的指令陷阱|<br>|11111|系统|运行特权操作系统任务|</p>
<p>SPSR<br>每一种特权模式（除系统模式外）都有一个一直相关的程序状态保存寄存器SPSR。</p>
<p>进入特权监控自己SPRS用通用寄存器保存。</p>
<p>异常||向量地址<br>|-|-|<br>|复位  | svc |0x00000000<br>|未定义|  und |0x00000004<br>|软件中断 |svc |0x00000008<br>|取存储器故障| abort |0x0000000C<br>|访问数据故障| abort| 0x00000010<br>|IRQ |IRQ |0x00000018<br>|FRQ |FRQ |0x0000001C</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM体系架构</title>
    <url>/ARM-Lover/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>ARM处理器是精简指令集计算机（RISC）。</p>
<p>ARM由于各种因素的偶然组合而诞生,成为Aconn产品线的核心部分,后来,在明智地将缩写字ARM的意义修改为Advanced RISC Machine以后,它把它的名字借给新组成的公司去在Acorn的产品范围之外扩展市场。尽管名称变化了,体系结构仍保持同原Acorn的设计相近。</p>
<p><strong>采用的技术特征</strong></p>
<p>ARM体系结构采用了Berkcley RISC设计中的特征<br>（1）Load/Store体系结构；<br>      针对存储器状态的惟一操作是将存储器的值拷贝到寄存器(Load指令)或将寄存器中的值拷贝到存储器(Store指令).<br>（2）固定的32位指令；<br>    load/store指令：装载和存储指令<br>    ldr、sdr单寄存器<br>    ldm、stm多寄存器<br>（3）3地址指令格式；<br>    在这种指令中包括两个操作数地址码和一个结果地址码，可使得在操作结束后，原来的操作数不被改变。</p>
<p><strong>也放弃了其他特征</strong></p>
<p>（1）寄存器窗口：带来的主要问题是大量的寄存器占用很大的芯片面积。不采用<br>（2）延迟转移：在原来的ARM中延迟转移没有采用,因为它使异常处理更加复杂。从长远观点来看,这是一个好的决定,因为当采用不同流水线重新实现体系结构时,它能使任务简化。不采用<br>（3）所有指令单周期执行：ARM被设计为使用最少的时钟周期来访问存储器,而不是所有的指令都单周期,执行。当访问在储器需要超过1个周期时,就多用1个周期、有可能时,做一些有用的事,如支持自动变址寻址模式。这减少了完成任何操作序列所需要的ARM指令总数,提高效率和改进代码密度。</p>
<p><strong>ARM编程模型</strong></p>
<p>处理器指令集定义了操作。程序员可以用这些操作来改变集成了处理器的系统的态</p>
<p>当编写用户级程序时,仅有15个通用32位寄存器(ro~r14)、程序计数器PC(r15)和当前程序状态寄存器(CPSR. Current Program Status Register)需要考虑。其余寄存器仅用于系统级编程和异常处理（如中断）。</p>
<p><strong>ARM异常</strong></p>
<p>ARM体系结构支持-系列中断、陷阱和监控调用为异常。<br>在任何情况下处理异常的方法都是一-样的,即<br>1)通过将PC拷贝到r14-exc以及将CPSR拷贝到SPSR-exc(在此cxc表示异常类型)来保存当前状态<br>2)将处理器操作模式改变为适当的异常模式<br>3)将PC强制变为00(16)~1C(16)范围内某个与异常类型有关的特殊值。<br>这个特殊值位置(向量地址)的指令通常是指向异常处理程序的转移指令。通常将13-exc初始化,使其指向存储器中一个专用堆栈。异常处理程序将使用r13_exc来保存一些用户寄存器,使其能作为工作寄存器使用。</p>
<p><strong>arm中r0-r15作用？</strong></p>
<p>参考：<a href="http://blog.chinaunix.net/uid-28458801-id-3792828.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-28458801-id-3792828.html</a></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r0-r3</td>
<td>用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。</td>
</tr>
<tr>
<td>r4-r11</td>
<td>被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。</td>
</tr>
<tr>
<td>r12</td>
<td>是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。</td>
</tr>
<tr>
<td>r13</td>
<td>是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。</td>
</tr>
<tr>
<td>r14</td>
<td>是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复</td>
</tr>
<tr>
<td>r15</td>
<td>是程序计数器 PC。</td>
</tr>
</tbody></table>
<p>注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM处理器知识</title>
    <url>/ARM-Lover/Untitled/</url>
    <content><![CDATA[<p>需要是发明之母！！！</p>
<p>第一片ARM 由Acorn Computers Limited公司研发 1983-1985<br>高性能，低功耗和低价格，立足市场。</p>
<p><strong>什么是片上调试？</strong></p>
<p>通过一个片上的调试模块OCD，可以实现对MCU的运行过程进行单步调试、全速运行、设置硬件断点等调试操作，还可以dao随时查看或者修改MCU的片内/片外数据存储区域的内容，从而为调试者提供了访问MCU运行时的内部状态以及控制MCU运行过程的方法和途径。</p>
<p>缺点：调试过程只能有一个接口。</p>
<p><strong>SIMD指令</strong></p>
<p>SIMD全称Single Instruction Multiple Data，单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。</p>
<p>伴随着指令集结构的进展,微结构也出现一些变化以增强性能。<br>ARM7TDMI采用基子3级流水线的微结构,这与最初ARM核使用的结构是样的,但是对于像5级流水线ARM9TDMI这样更高速芯核的市场正在快速发展。<br>这种简单性是这些机器实或低功耗和小硅片面积的关键。</p>
<p>基于微处理器核的片上系统(SoC, System on-Chip)设计,也可用于微处理器核设计<br>Thumb新型压缩指令格式。</p>
<p>1980年，精简指令集计算机(RISC , Reduced Introduction Set Computer)的思想起源于1980年斯坦福大学的一项处理器研究项目,而其中一些核心思想可以追溯到更早的计算机。这些思想也影响了ARM处理器设计。</p>
<p><strong>计算机体系结构</strong></p>
<p>计算机体系结构描述从用户角度看到的计算机。指令集,可见寄存器、存储器管理表结构和异常处理模式都是体系结构的一部分。</p>
<p><strong>计算机组织</strong></p>
<p>计算机组织描述用户不能看到的体系结构的实现方式。流水线结构、透明的Cache(高速缓存)、步行表(table-walking)硬件以及转换后备缓冲(TLB, TranslationLook-aside Bufer)都是计算机组织的问题。</p>
<p><strong>处理器</strong></p>
<p>通用处理器是一个执行存储器中指令的有限状态机。</p>
<p><strong>存储程序计算机</strong></p>
<p>存储程序(stored-program)数字计算机把指令和数据存放在同一个存储器系统中,必要时可以将指令作为数据处理。</p>
<p><strong>简单的处理器</strong></p>
<p>MU0可以由一些基本的部件构成,即<br>程序计数器(PC)寄存器:用来保存当前指令的地址。<br>累加器(ACC)寄存器:用来保存正在处理的数据。<br>算术逻辑单元(ALU):可以对二进制操作数进行若干操作,如加、减、增值等。<br>指令寄存器(IR):保仔当前执行的指令。<br>指令译码器和控制逻辑:它根据指令控制上述部件产生所需的结果。</p>
<p>其中4位为操作码(opceode),12位为地址域(S),最简单的指令集只使用了16种可用操作码中的8种。<br>指令基本都是操作ACC,PC跳转，执行指令。<br>所有不改变PC的指令，占2个时钟周期。<br>1、访问存储器中的操作并执行操作<br>2、读取下一步要执行的指令</p>
<p>指令的演变-》隐含的方式不断发展。如地址指令ADD</p>
<p>1970年单片复杂指令集计算机(CISC, ComplexInstruction Set Computer),这是带有小型计算机指令集的微处理器。而这个指令集义是以有限的可用硅资源为代价的。<br>（1）一个指令多个周期</p>
<p>期间，处理器由比主存储器速度快的微码ROM(只读存储器)控制,因此,将经常使用的操作以微码序列实现,而不使用需要从主仔储器读取几条指令的方式</p>
<p>1980年RISC革命精简指令集计算机(RISC, Reduced Instruction Set Computer)诞生在指令集日益复杂的时候, RISC的概念对ARM处理器的设计有重大影响。<br>（1）一个指令一个周期<br>（2）固定的(32位)指令长度,指令类型很少。而CISC处理器指令集的长度一般可变,指令类型也很多。<br>切勿单以时钟频率来评价处理器。<br>缺点：<br>（1）RISC不能执行x86代码。<br>（2）与CISC相比,通常RISC的代码密度低。</p>
<p>代码密度：同样的一段代码，对于不同的单片机来说，编译之后多数情况下占用的空间是不相同的。占用的空间越大，则说明代码密度越低，反之异然。<br>代码密度低是指令集长度固定的结果,而且当应用领域较宽时,这个问题会更加严重。如果没有Cache,则代码密度低会导致在取指时使用更大的主存储器带宽,造成更高的存储器功耗。当处理器集成一定规模的片上Cache时,代码密度低会导致在任何时候都只有少部分正在工作的指令集能够装入Cache,会降低(ache的命中率,造成对主存储器带宽的需求以及功耗有更大的增长。</p>
<p>ARM处理器是根据RISC原理设计的,但是由于各种原因,在低代码密度问题上它比其他多数RISC要好一些,然而它的代码密度仍然不如某些CISC处理器的。</p>
<p>在代码密度特别重要的场合, ARM公司在某些版本的ARM处理器中,加入了一个称为Thumb结构的新型机构。Thumb指令集是原来32位ARM指令集的16位压缩形式,并在指令流水线中使用了动态解压缩硬件。Thumb代码密度优于多数CISC:处理器达到的代码密度</p>
<p>RISC实际上就是ARM的别名。<br>指令集的发展</p>
<p><strong>处理器做些什么</strong></p>
<p>实际上,它只用很少的时间进行这个意义上的“计算”。尽管它进行相当数量的,算术运算,但是,这些运算多数需要寻址,以便找到相关数据与程序的位置。找到用户的数据后,多数是把它们移来移去,而不是进行转换意义上的处理。(优化对象)</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>动态使用率 (/%)</th>
</tr>
</thead>
<tbody><tr>
<td>数据移动</td>
<td>43</td>
</tr>
<tr>
<td>控制流</td>
<td>23</td>
</tr>
<tr>
<td>算术操作</td>
<td>15</td>
</tr>
<tr>
<td>比较</td>
<td>13</td>
</tr>
<tr>
<td>逻辑操作</td>
<td>5</td>
</tr>
<tr>
<td>其他</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>流水线</strong></p>
<p>处理器按照一系列步骤来执行每一条指令。典型的步骤如下:<br>1)从存储器读取指令(fetch)<br>2)译码以鉴别它是哪一类指令(dec)<br>3)从寄存器堆取得所需的操作数(reg)<br>4)将操作数进行组合以得到结果或存储器地址(ALU)<br>5)如果需要,则访问存储器以存取数据(mem)<br>6)将结果回写到寄存器堆(res)</p>
<p>转移指令—-》流水线冒险–》“写后读”</p>
<p>流水线效率尽管有些技术可以减少这些流水线问题的影响,但是,不能完全消除这些困难。</p>
<p>（1）流水线越深(就是流水线的级数越多),问题就越严重。对于相对简单的处理器,使用3~5级流水线效果会更好。<br>（2）但是,超过了这个级数,收益递减的法则开始生效,增加的成本和复杂度将超过收益。<br>（3）显然,只有当所有指令都依相似的步骤执行时,流水线才能带来好处。如果处理器的指令非常复杂,每一条指令的行为都与下一条指令不同,那么就很难用流水线实现。<br>1980年,因为有限的硅资源、有限的设计资源,以及设计一个复杂指令集的流水线的高度复杂性,当时的复杂指令集微处理器没有采用流水线。<br>（4）流水线的高度复杂性,当时的复杂指令集微处理器没有采用流水线。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile嵌套</title>
    <url>/Makefile-Lover/Makefile%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<p>子嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">cd subdir $ (MAKE)</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">subsystem:</span><br><span class="line"> $ (MAKE)  -C subdir</span><br></pre></td></tr></table></figure>
<p>环境变量的传递与屏蔽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export variable</span><br><span class="line"></span><br><span class="line">unexport variable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表，双链表，循环链表</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>_单链表</strong></p>
<p>单链表的一个优点是结构简单，但是它也有一个缺点，即在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct  Node</span><br><span class="line">&#123;</span><br><span class="line">	Int data;</span><br><span class="line">	Struct Node * next;</span><br><span class="line"></span><br><span class="line">&#125;SList;</span><br><span class="line"></span><br><span class="line">创建: SLIST *SList_Create()  SLIST *pHead, *pM, *pCur</span><br><span class="line">遍历int SList_Print(SLIST *pHead) printf(&quot;%d &quot;, tmp-&gt;data);tmp &#x3D; tmp-&gt;next;</span><br><span class="line">插入	SLIST *pM, *pCur, *pPre; &#x2F;&#x2F;创建新的业务节点pM</span><br><span class="line">删除pPre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">销毁tmp &#x3D; pHead-&gt;next; free(pHead);pHead &#x3D; tmp;</span><br><span class="line">反序：	t &#x3D; q-&gt;next; &#x2F;&#x2F;缓冲后面的链表</span><br><span class="line">		q-&gt;next &#x3D; p;	&#x2F;&#x2F;逆置</span><br><span class="line">		p &#x3D; q; &#x2F;&#x2F;让p下移一个结点</span><br><span class="line">		q &#x3D; t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">#define  _CRT_SECURE_NO_WARNINGS </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;SLIST;</span><br><span class="line">SLIST *SList_Create(); &#x2F;&#x2F;创建链表</span><br><span class="line">int SList_Print(SLIST *pHead); &#x2F;&#x2F;遍历链表</span><br><span class="line">int SList_NodeInsert(SLIST *pHead, int x, int y); &#x2F;&#x2F;插入值  在x值之前 删除y</span><br><span class="line">int SList_NodeDel(SLIST *pHead, int y);</span><br><span class="line">int SList_Destory(SLIST *pHead);</span><br><span class="line">SLIST *SList_Create()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	SLIST *pHead, *pM, *pCur;</span><br><span class="line">	int		data;</span><br><span class="line">	&#x2F;&#x2F;创建头节点 并初始化</span><br><span class="line">	pHead &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	pHead-&gt;data &#x3D; 0;</span><br><span class="line">	pHead-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\nplease enter you data: &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line"></span><br><span class="line">	pCur &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">	while (data !&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;创建业务节点 并初始化 不断接受输入 malloc新结点</span><br><span class="line">		pM &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">		if (pM &#x3D;&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		pM-&gt;data &#x3D; data;</span><br><span class="line">		pM-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;2 新结点 入链表 </span><br><span class="line">		pCur-&gt;next &#x3D; pM;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;3 新结点变成当前节点</span><br><span class="line">		pCur &#x3D; pM;  &#x2F;&#x2F;链表结点的尾部追加 </span><br><span class="line"></span><br><span class="line">		printf(&quot;\nplease enter you data: &quot;);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br><span class="line">int SList_Print(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *tmp &#x3D; NULL;</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp &#x3D; pHead-&gt;next;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\nBegin\t&quot;);</span><br><span class="line">	while (tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, tmp-&gt;data);</span><br><span class="line">		tmp &#x3D; tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\tEnd&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_NodeInsert(SLIST *pHead, int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *pM, *pCur, *pPre;</span><br><span class="line">	&#x2F;&#x2F;创建新的业务节点pM</span><br><span class="line">	pM &#x3D; (SLIST *)malloc(sizeof(SLIST));</span><br><span class="line">	if (pM &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pM-&gt;next &#x3D; NULL;</span><br><span class="line">	pM-&gt;data &#x3D; y;</span><br><span class="line">	&#x2F;&#x2F;遍历链表</span><br><span class="line">	pPre &#x3D; pHead;</span><br><span class="line">	pCur &#x3D; pHead-&gt;next;</span><br><span class="line"></span><br><span class="line">	while (pCur)</span><br><span class="line">	&#123;</span><br><span class="line">		if (pCur-&gt;data &#x3D;&#x3D; x)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		pPre &#x3D; pCur;</span><br><span class="line">		pCur &#x3D; pCur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;让新结点 连接 后续链表</span><br><span class="line">	pM-&gt;next &#x3D; pPre-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;让前驱节点 连接 新结点</span><br><span class="line">	pPre-&gt;next &#x3D; pM;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_NodeDel(SLIST *pHead, int y)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST  *pCur, *pPre;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化状态</span><br><span class="line"></span><br><span class="line">	pPre &#x3D; pHead;</span><br><span class="line">	pCur &#x3D; pHead-&gt;next;</span><br><span class="line">	while(pCur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		if (pCur-&gt;data &#x3D;&#x3D; y)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		pPre &#x3D; pCur;</span><br><span class="line">		pCur &#x3D; pCur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除操作</span><br><span class="line">	if (pCur &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;没有找到结点值为:%d 的结点\n&quot;, y);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pPre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">	if (pCur !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		free(pCur);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_Destory(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST *tmp &#x3D; NULL;</span><br><span class="line">	if (pHead &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while (pHead !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp &#x3D; pHead-&gt;next;</span><br><span class="line">		free(pHead);</span><br><span class="line">		pHead &#x3D; tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SList_Reverse(SLIST *pHead)</span><br><span class="line">&#123;</span><br><span class="line">	SLIST	*p &#x3D; NULL; &#x2F;&#x2F;前驱指针</span><br><span class="line">	SLIST	*q &#x3D; NULL; &#x2F;&#x2F;当前指针</span><br><span class="line">	SLIST	*t &#x3D; NULL; &#x2F;&#x2F;缓存的一个结点</span><br><span class="line">	if (pHead&#x3D;&#x3D;NULL || pHead-&gt;next &#x3D;&#x3D; NULL ||pHead-&gt;next-&gt;next &#x3D;&#x3D;NULL )</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;初始化 	&#x2F;&#x2F;前驱结点</span><br><span class="line">	p &#x3D; pHead-&gt;next;</span><br><span class="line">	q &#x3D; pHead-&gt;next-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;p &#x3D; pHead;  &#x2F;&#x2F;代码能兼容</span><br><span class="line">	&#x2F;&#x2F;q &#x3D; pHead-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;一个结点 一个结点的逆置</span><br><span class="line">	while(q)</span><br><span class="line">	&#123;</span><br><span class="line">		t &#x3D; q-&gt;next; &#x2F;&#x2F;缓冲后面的链表</span><br><span class="line">		q-&gt;next &#x3D; p;	&#x2F;&#x2F;逆置</span><br><span class="line">		p &#x3D; q; &#x2F;&#x2F;让p下移一个结点</span><br><span class="line">		q &#x3D; t;</span><br><span class="line">	&#125; </span><br><span class="line">	&#x2F;&#x2F;头节点 变成 尾部结点 后  置null</span><br><span class="line">	pHead-&gt;next-&gt;next &#x3D; NULL;  &#x2F;&#x2F;尾部置为NULL</span><br><span class="line">	pHead-&gt;next &#x3D; p;  &#x2F;&#x2F;头部连接</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int  ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	SLIST *pHead &#x3D; NULL;</span><br><span class="line">	pHead &#x3D; SList_Create();</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; SList_NodeInsert(pHead, 20, 19);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; SList_NodeDel(pHead, 19);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	ret &#x3D;  SList_Reverse(pHead);</span><br><span class="line">	ret &#x3D; SList_Print(pHead);</span><br><span class="line"></span><br><span class="line">	SList_Destory(pHead);</span><br><span class="line"></span><br><span class="line">	printf(&quot;hello...\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双链表</strong></p>
<p>其中一个是头结点，另一个是尾结点，它们都不存放数据元素，<br>头结点的pre 为空，而尾结点的 Next 为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DouLinkNode &#123;</span><br><span class="line">    int data ;               &#x2F;&#x2F;链表中存放的数据，可以自定义数据结构 </span><br><span class="line">    struct DouLinkNode *pre ,*next;</span><br><span class="line">&#125;;</span><br><span class="line">struct DouLinkNode *create(int n)</span><br><span class="line">&#123;   </span><br><span class="line">    int x;</span><br><span class="line">    struct DouLinkNode *head &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    struct DouLinkNode *p,*s;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    p-&gt;pre &#x3D; NULL;</span><br><span class="line">    while(n)</span><br><span class="line">	&#123;</span><br><span class="line">        s &#x3D; (struct DouLinkNode*)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">        printf(&quot;input data of the node:data&#x3D;&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        s-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; s;</span><br><span class="line">        s-&gt;pre &#x3D; p;</span><br><span class="line">        p &#x3D; s;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next &#x3D; NULL;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;* 双向链表打印 *&#x2F;</span><br><span class="line">void display(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p &#x3D; head-&gt;next;</span><br><span class="line">    while(p-&gt;next) &#123;</span><br><span class="line">        printf(&quot;%d &lt;---&gt; &quot;,p-&gt;data);</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d \n&quot;,p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 链表头插节点 *&#x2F;&#x2F;&#x2F;头插法  第二个</span><br><span class="line">void insertListHead(struct DouLinkNode *pList, int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    pNode-&gt;next &#x3D; pList-&gt;next;</span><br><span class="line">    pNode-&gt;pre &#x3D; pList;</span><br><span class="line">    if (NULL !&#x3D; pNode-&gt;next) &#123;</span><br><span class="line">        pNode-&gt;next-&gt;pre &#x3D; pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    pList-&gt;next &#x3D; pNode;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 链表尾插节点 *&#x2F; </span><br><span class="line">void insertListTail(struct DouLinkNode *pList, int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList; </span><br><span class="line">    while(NULL !&#x3D; pCur-&gt;next) &#123;</span><br><span class="line">        pCur &#x3D; pCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pCur-&gt;next &#x3D; pNode;</span><br><span class="line">    pNode-&gt;pre &#x3D; pCur;</span><br><span class="line">    pNode-&gt;next &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 在链表的指定位置插入节点: index &#x3D; 0 ---&gt; 头插； index &#x3D; length ---&gt; 尾插 *&#x2F;</span><br><span class="line">int insertList(struct DouLinkNode *pList, int data, int index)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList; </span><br><span class="line">    int len &#x3D;  get_List_Length(pCur);</span><br><span class="line">    if(index &gt; len) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        insertListHead(pList, data);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if(index &#x3D;&#x3D; len) &#123;</span><br><span class="line">        insertListTail(pList, data);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct DouLinkNode *pNode &#x3D; (struct DouLinkNode *)malloc(sizeof(struct DouLinkNode));</span><br><span class="line">    pNode-&gt;data &#x3D; data;</span><br><span class="line">    pCur &#x3D; pList;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while( index--) &#123;</span><br><span class="line">        pCur &#x3D; pCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">    pCur-&gt;next &#x3D; pNode;</span><br><span class="line">    pNode-&gt;pre &#x3D; pCur;</span><br><span class="line">    pNode-&gt;next-&gt;pre &#x3D; pNode;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除链表中的指定值 *&#x2F;</span><br><span class="line">int deleteListNode(struct DouLinkNode *pList, int key)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *pPre &#x3D; pList;</span><br><span class="line">    struct DouLinkNode *pCur &#x3D; pList-&gt;next;</span><br><span class="line">    int count &#x3D; 0; &#x2F;&#x2F;记录删除节点个数 </span><br><span class="line">    while(NULL!&#x3D;pCur) &#123;</span><br><span class="line">        if(pCur-&gt;data &#x3D;&#x3D; key) &#123;</span><br><span class="line">            if(NULL !&#x3D; pCur-&gt;next) &#123;</span><br><span class="line">                pCur-&gt;next-&gt;pre &#x3D; pCur-&gt;pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pCur-&gt;pre-&gt;next &#x3D; pCur-&gt;next;</span><br><span class="line">            pPre &#x3D; pCur; </span><br><span class="line">            pCur &#x3D; pCur-&gt;next;</span><br><span class="line">            free(pPre);</span><br><span class="line">            count ++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pPre &#x3D; pCur;</span><br><span class="line">            pCur &#x3D; pCur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 链表求长 *&#x2F;</span><br><span class="line">int get_List_Length(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    for (p; p-&gt;next!&#x3D;NULL; p&#x3D;p-&gt;next) &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 双向链表排序 *&#x2F;</span><br><span class="line">struct DouLinkNode *sort(struct DouLinkNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct DouLinkNode *p,*s,*min;</span><br><span class="line">    int tmp;</span><br><span class="line"></span><br><span class="line">    for(p &#x3D; head-&gt;next ;p-&gt;next!&#x3D;NULL ;p&#x3D;p-&gt;next) &#123;</span><br><span class="line">        min &#x3D; p ;</span><br><span class="line">        for(s&#x3D; p-&gt;next ; s!&#x3D;NULL ;s&#x3D;s-&gt;next) &#123;</span><br><span class="line">            if(s-&gt;data &lt;min-&gt;data)</span><br><span class="line">                min &#x3D; s;               &#x2F;&#x2F;找到每次排序中最小的节点，然后记住这个节点</span><br><span class="line">        &#125; if(min !&#x3D; p) &#123;               &#x2F;&#x2F;把这个节点与前面的节点的数据进行交换，把最小的数据放在前面的节点内。</span><br><span class="line">            tmp &#x3D; min-&gt;data;</span><br><span class="line">            min-&gt;data &#x3D; p-&gt;data;</span><br><span class="line">            p-&gt;data &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环链表</strong></p>
<p>特点：”无头无尾”。</p>
<p>单循环链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：网络</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;约瑟夫环问题   环状链</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef struct node </span><br><span class="line">&#123;	</span><br><span class="line">	int number;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;person ;</span><br><span class="line">person *initlink(int n)</span><br><span class="line">&#123;</span><br><span class="line">	person *head &#x3D;(person*)malloc(sizeof(person));</span><br><span class="line">	head-&gt;number &#x3D;1;</span><br><span class="line">	head-&gt;next &#x3D;NULL;</span><br><span class="line">	person *cyclic &#x3D;head;</span><br><span class="line">	int i;</span><br><span class="line">	for (i&#x3D;2 ; i &lt;&#x3D; n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		person* body &#x3D; (person*)malloc(sizeof(person));</span><br><span class="line">		body-&gt;number &#x3D; i ;</span><br><span class="line">		body-&gt;next &#x3D; NULL;</span><br><span class="line">		cyclic-&gt;next &#x3D; body;</span><br><span class="line">		cyclic &#x3D; cyclic-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cyclic-&gt;next &#x3D;head;&#x2F;&#x2F;呈环状</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">void findAndKillK(person * head,int k,int m)</span><br><span class="line">&#123; </span><br><span class="line">	person * tail&#x3D;head;   &#x2F;&#x2F;找到链表第一个结点的上一个结点</span><br><span class="line">	while(tail-&gt;next !&#x3D; head)&#123;tail&#x3D;tail-&lt;next;&#125;&#x2F;&#x2F;找到链表第一个结点的上一个结点，为删除操作做准备 </span><br><span class="line">	</span><br><span class="line">	person *p &#x3D; head ;</span><br><span class="line">	while(p-&gt;number!&#x3D; k) &#x2F;&#x2F;找到k编号</span><br><span class="line">	&#123;</span><br><span class="line">		tail&#x3D;p;</span><br><span class="line">		p&#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(p-&gt;next !&#x3D; p) &#x2F;&#x2F;剩最后一个</span><br><span class="line">	&#123;</span><br><span class="line">		int i ;</span><br><span class="line">		for(i &#x3D;1 ;i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tail &#x3D; p;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tail-&gt;next &#x3D; p-&gt;next;&#x2F;&#x2F;摘除</span><br><span class="line">		printf(&quot;出列：%d\n&quot;,p-&gt;number);</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; tail-&gt;next; &#x2F;&#x2F;下一个为第一个</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		printf(&quot;出列：%d\n&quot;,p-&gt;number); &#x2F;&#x2F;最后一个</span><br><span class="line">		free(p);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">int main() </span><br><span class="line">	&#123;</span><br><span class="line">    printf(&quot;输入圆桌上的人数n:&quot;);</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    person * head&#x3D;initLink(n);</span><br><span class="line">    printf(&quot;从第k人开始报数(k&gt;1且k&lt;%d)：&quot;,n);</span><br><span class="line">    int k;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">    printf(&quot;数到m的人出列：&quot;);</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    findAndKillK(head, k, m);</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链循环链表：略</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>炫酷的图片来源QAQ</title>
    <url>/QT-Lover/%E7%82%AB%E9%85%B7%E7%9A%84%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90QAQ/</url>
    <content><![CDATA[<p>JPG的图片格式是有损的，优点是有更丰富的色彩，非常适合来存储照片，用来表达更生动的图像效果，比如颜色渐变。<br>PNG格式的图片是无损的，而且PNG-8格式是GIF格式的非常好的替代者，在达到相同效果的情况下，PNG-8格式体积更小，而且支持透明度的调节。<br>SVG格式的图片是无损的矢量图。在放大的不会失真，适合绘制企业logo，icon等。</p>
<p>有损压缩是对图像本身的改变,在保存图像时保留了较多的亮度信息,而将色相和色纯度的信息和周围的像素进行合并,合并的比例不同,压缩的比例也不同,由于信息量减少了,所以压缩比可以很高,图像质量也会相应的下降。<br>无损压缩是对文件本身的压缩,和其它数据文件的压缩一样,是对文件的数据存储方式进行优化。</p>
<p>图标网站：Iconfont：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p>
<p>一位大佬的博客：<a href="https://cloud.tencent.com/developer/article/1631262" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1631262</a></p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT上执行shell</title>
    <url>/QT-Lover/T%E4%B8%8A%E6%89%A7%E8%A1%8Cshell/</url>
    <content><![CDATA[<p>1、脚本echo输出的内容得通过connect调用函数获取。<br>2、start/execute 调用的时候脚本就开始了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QProcess&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include&lt;QList&gt;</span><br><span class="line">#include&lt;QStringList&gt;</span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">    ~Widget();</span><br><span class="line">   &#x2F;&#x2F; void executeShellQProcess(QString str);</span><br><span class="line"></span><br><span class="line">         QString shellOutput;</span><br><span class="line">private slots:</span><br><span class="line">         void executeShellQProcess();</span><br><span class="line">         void readProcess();</span><br><span class="line">         void finishedProcess();</span><br><span class="line">         void on_pushButton_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QProcess *runShellProcess;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include&lt;QProcess&gt;</span><br><span class="line">#include&lt;QDir&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line">    runShellProcess &#x3D; new QProcess(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        connect(runShellProcess, SIGNAL(readyRead()), this, SLOT(readProcess()));</span><br><span class="line">      &#x2F;&#x2F;  connect(runShellProcess, SIGNAL(finished(int)), this, SLOT(finishedProcess()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void Widget::executeShellQProcess()&#123;</span><br><span class="line">    shellOutput&#x3D;&quot;&quot;;</span><br><span class="line">    QString filename &#x3D; QCoreApplication::applicationDirPath();</span><br><span class="line">    qDebug()&lt;&lt;filename;</span><br><span class="line">    QDir::setCurrent(filename);</span><br><span class="line">    runShellProcess-&gt;start( &quot;.&#x2F;test.sh&quot;);</span><br><span class="line">    &#x2F;&#x2F; runShellProcess-&gt;execute( &quot;.&#x2F;test.sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::readProcess()&#123;</span><br><span class="line">    QString output&#x3D;runShellProcess-&gt;readAll();</span><br><span class="line">      shellOutput+&#x3D;output;</span><br><span class="line">      &#x2F;&#x2F;qDebug()&lt;&lt;&quot;shellOutput1&quot;&lt;&lt;endl;</span><br><span class="line">     &#x2F;&#x2F;do something</span><br><span class="line">       qDebug()&lt;&lt;shellOutput&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::finishedProcess()&#123;</span><br><span class="line">     qDebug()&lt;&lt;shellOutput&lt;&lt;endl;</span><br><span class="line">     &#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    executeShellQProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull亮度调节</title>
    <url>/Linux-Lover/imx6ull%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82/</url>
    <content><![CDATA[<p>设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为<br>0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%<br>actual_brightness：这个节点只读，可以通过读取这个节点，获取 LCD 实际的亮度值。<br>brightness：这个节点可读可写，向这个节点写入不同值（0-7），可调节 LCD 亮度。<br>max_brightness：这个节点只读，通过读取此节点</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title> imx6ull点灯测试</title>
    <url>/Linux-Lover/imx6ull%E7%82%B9%E7%81%AF%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>echo “out” &gt; /sys/class/gpio/gpio130/direction #控制为输出<br>echo “in” &gt; /sys/class/gpio/gpio130/direction #控制为输入<br>echo “1” &gt; /sys/class/gpio/gpio130/value #输出为高电平<br>echo “0” &gt; /sys/class/gpio/gpio130/value #输出为低电平</p>
<p>brightness 节点用来控制 LED 的亮灭，通过对 brightness 节点写入 0 或 1，可以控制 LED 的亮灭状态。<br>trigger 支持的状态值有：rc-feedback, nand-disk, mmc0, timer,oneshot, heartbeat, backlight, gpio.</p>
<p>测试中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LED1_BRIGHTNESS    &quot;&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;dtsleds&#x2F;leds&#x2F;red&#x2F;brightness&quot;</span><br><span class="line">#define LED1_TRIGGER       &quot;&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;dtsleds&#x2F;leds&#x2F;red&#x2F;trigger&quot;</span><br><span class="line">#define TRIGGER_NONE          &quot;none&quot;</span><br><span class="line">#define TRIGGER_HEARTBEAT     &quot;heartbeat&quot;</span><br></pre></td></tr></table></figure>

<p>视频</p>
<iframe src="//player.bilibili.com/player.html?aid=883253911&bvid=BV1jK4y1t7iz&cid=197202487&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"
height="600" width="100%" > </iframe>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>i.MX6UL芯片上电过程分析</title>
    <url>/Linux-Lover/i-MX6UL%E8%8A%AF%E7%89%87%E4%B8%8A%E7%94%B5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>参考来源：公众号【微联智控】<br>参考来源：正点原子<br><strong>误区</strong></p>
<p>芯片一上电的时候，首先执行的程序是类似 u-boot 之类的 BootLoader，或者是单片机程序里面类似于 xxxx_start_up.S 的启动文件，更有很多单片机工程师认为，芯片一上电就去执行 main()函数。</p>
<p><strong>事实</strong></p>
<p>大部分嵌入式处理器芯片一上电的时候，首先执行的既不是 BootLoader，也不是执行类似于 xxxx_start_up.S 的启动文件。而是执行一段开发者看不见摸不着的程序，通常把这段程序称为 BootROM。这段程序在嵌入式处理器芯片生产设计的时候就被芯片设计厂家固化在芯片里面，开发者作为使用芯片的角色，不需要获得 BootROM 的源码，也不需要对 BootROM 源码进行改写。</p>
<p>（1）Image Vector Table —— 镜像向量表，简称 IVT，位于固定地址的指针列表，ROM 检<br>查该列表以确定程序映像的其他组件所在的位置。<br>（2）Boot Data —— 表示程序镜像的位置，镜像大小，以及插件标志。<br>（3）Device Configuration Data —— 表示芯片 IC 的初始化数据。<br>（4）User Code and Data —— 用户代码和数据</p>
<p>以 SD/EMMC 为例，IVT 偏移为 1Kbyte，IVT+Boot data+DCD 的总大小为 4KByte-<br>1KByte=3KByte。<br>IVT+Boot data+DCD+.bin</p>
<p>参考：<a href="https://www.cnblogs.com/yuanqiangfei/p/10225138.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanqiangfei/p/10225138.html</a></p>
<p>Efuse类似于EEPROM，是一次性可编程存储器，在芯片出场之前会被写入信息，在一个芯片中，efuse的容量通常很小，一些芯片efuse只有128bit。<br>28bit的efuse包含芯片电压字段、芯片版本号、芯片生产日期以及其他信息。<br>芯片在初次上电过程中会读取efuse中的电压字段数值，送到芯片外部的电源管理器，电源管理器在芯片初始上电前会提供一个标准的电压（假设为1.0v），在接受到efuse中的电压字段数值后会调节电压大小。完成电源电压调整后，芯片会重新进行上电复位操作。</p>
<img src="/Linux-Lover/i-MX6UL%E8%8A%AF%E7%89%87%E4%B8%8A%E7%94%B5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/%E4%B8%8A%E7%94%B5%E5%90%AF%E5%8A%A8.jpg" class="">


<p>总的来说，i.MX6UL这款芯片的BootROM的主要功能是，根据内部eFUSES或者外部GPIO<br>的状态，来判断芯片从哪里（可以是 SD 卡，NandFlash，eMMC 等）加载启动镜像，然后再<br>从启动镜像获取芯片的初始化方式（启动镜像 u-boot.imx 就是 u-boot.bin + header 数据的集<br>合，这个 header 数据就是提供给芯片的 BootROM 使用的），最后通过绝对地址，跳转到启<br>动镜像那里，执行第一句用户程序指令（通常是 u-boot 里面的_start 函数，通过 u-boot.lds<br>链接脚本，可以看到 u-boot 的第一个函数入口，接下来才是 u-boot 的启动过程）。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>截屏工具gsnap移植</title>
    <url>/Linux-Lover/gsnap%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>参考：微联智控</p>
<p>截屏工具 gsnap 的移植，需要依赖以下库文件：libpng、libjpeg、zlib、libmath。<br>libmath 由于交叉编译器自带，因此 libmath 可以不用移植。</p>
<p>创建：/opt/work/tools/gsnap<br>基本配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CC&#x3D;arm-linux-gnueabihf-gcc   &#x2F;&#x2F;编译器</span><br><span class="line"># .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;work&#x2F;tools&#x2F;gsnap&#x2F;xxx_install   &#x2F;&#x2F;安装路径</span><br></pre></td></tr></table></figure>

<p>把生成的lib、iclude放到 gsnap_install/lib 目录下的动态库复制到开发板的/lib 目录</p>
<p>可以进行屏幕截图：gsnap fb.jpg /dev/fb0</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>shell进阶命令</title>
    <url>/shell-Lover/shell%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>find命令</p>
<p>常用<br>1、查找当前用户主目录下的所有文件：<br>$ find $HOME -print<br>$ find ~ -print</p>
<p>2、查找系统中最后N分钟被改变文件数据的文件</p>
<p>$find -mmin n<br>在系统根目录下查找更改时间在5日以内的文件，可以用：<br>$ find / -mtime -5 -print</p>
<p>find和Xargs<br>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>
<p>awk命令</p>
<p>awk ‘{print $NF}’ myfile.sh<br>print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段</p>
<p>sed命令<br> 通过文件或管道读取文件内容。</p>
<ul>
<li>sed并不直接修改源文件，而是将读入的内容复制到缓冲区中，我们称之为模式空间（pattern space）。</li>
<li>根据sed的指令对模式空间中的内容进行处理并输出结果，默认输出至标准输出即屏幕上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 这里就简单介绍几个脚本指令操作作为sed程序的例子。</span><br><span class="line">    a,append        追加</span><br><span class="line">    i,insert        插入</span><br><span class="line">    d,delete        删除</span><br><span class="line">    s,substitution  替换</span><br><span class="line">    </span><br><span class="line">查找替换应用举例</span><br><span class="line">sed  &#39;2a TYPE&#x3D;Ethernet&#39;  test.txt    第二行后添加新行TYPE&#x3D;Ethernet</span><br><span class="line">sed  &#39;3i  TYPE&#x3D;Ethernet&#39;  test.txt   第三行前添加新行  TYPE&#x3D;Ethernet</span><br><span class="line">sed  &#39;s&#x2F;yes&#x2F;no&#x2F;g&#39;     test.txt       将样本文件中的所有yes替换为no</span><br><span class="line">sed  &#39;3,4d&#39;  test.txt                删除第3至4行的内容</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>shell流程语句小记</title>
    <url>/shell-Lover/shell%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>if then else语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种格式：</span><br><span class="line">if 条件</span><br><span class="line">then 命令</span><br><span class="line">fi</span><br><span class="line">例子：</span><br><span class="line">if [ &quot;13&quot; -lt &quot;12&quot; ]  # &quot;13&quot; 前一个空格，“13”后也有一个空格。</span><br><span class="line">then</span><br><span class="line">        echo &quot;yes 13 is less then 12&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;NO&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二种格式：</span><br><span class="line"></span><br><span class="line">if 条件1</span><br><span class="line">then </span><br><span class="line">     命令1</span><br><span class="line">elif 条件2</span><br><span class="line">then </span><br><span class="line">     命令2</span><br><span class="line">else</span><br><span class="line">     命令3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>case多选择语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式值)</span><br><span class="line">	命令1</span><br><span class="line">	;;</span><br><span class="line">模式值)</span><br><span class="line">	命令2</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>





<p>for循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for i in 1 2 3 4 5 </span><br><span class="line">do </span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>until循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until 条件</span><br><span class="line">do	</span><br><span class="line">	命令1</span><br><span class="line">	命令2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>while循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line">#while01</span><br><span class="line">echo &quot;ctrl+d quit&quot; </span><br><span class="line">while echo -n &quot;please enter you name:&quot;; read Name  </span><br><span class="line">do</span><br><span class="line">        echo &quot;Yeah, you name: $Name&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>break<br>退出循环,如果是在一个嵌入循环里，可以指定n来跳出循环个数<br>continue<br>跳出循环步</p>
]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>了解ESP8266</title>
    <url>/MCU-Lover/ESP8266/</url>
    <content><![CDATA[<p>参考连接;<a href="https://www.bilibili.com/video/BV1dJ411S723?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dJ411S723?p=1</a><br><a href="https://www.espressif.com/zh-hans" target="_blank" rel="noopener">https://www.espressif.com/zh-hans</a><br><strong>IOT物联网</strong></p>
<p>物联网（The Internet of Things，简称IOT）是指通过 各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。物联网是一个基于互联网、传统电信网等的信息承载体，它让所有能够被独立寻址的普通物理对象形成互联互通的网络 [1]  。</p>
<img src="/MCU-Lover/ESP8266/%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F.jpg" class="">

<p>阿里云、腾讯云</p>
<p>百度云：<a href="https://console.bce.baidu.com/#/index/overview" target="_blank" rel="noopener">https://console.bce.baidu.com/#/index/overview</a></p>
<img src="/MCU-Lover/ESP8266/MQTT.jpg" class="">


<p><strong>ESP8266</strong></p>
<p>IPv4, TCP/UDP/HTTP/FTP<br>用户配置<br>AT+ 指令集, 云端服务器, Android/iOS APP</p>
<p>AT指令<br>SDK编程</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/shell-Lover/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>正则表达式</strong></p>
<p>概念：一种用来描述文本模式的特殊语法<br>由普通字符（例如：字符a到z），以及特殊字符（元字符，如/ * ？等）组成匹配的字符串<br>文本过滤工具在某种模式之下，都支持正则表达式。</p>
<p>基本元字符集及其含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pattern\&#123;n\&#125;    n为pattern 前面出现次数</span><br><span class="line">pattern\&#123;n,\&#125;m       n为pattern 前面出现最少次数</span><br><span class="line"> pattern\&#123;n,m\&#125;        n为pattern 前面出现n-m</span><br><span class="line"> </span><br><span class="line">A\&#123;3\&#125;B   AAAB    </span><br><span class="line">A\&#123;3,\&#125;B AAAB AAAAB ...</span><br><span class="line">A\&#123;3,5\&#125;B AAAB AAAAB AAAAAB </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行首以^匹配字符串或字符序列</span><br><span class="line">行尾以$匹配字符串或字符</span><br><span class="line">用*$匹配单字符串或其重复序列</span><br><span class="line">使用\屏蔽一个特殊字符的含义:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
  </entry>
  <entry>
    <title>QT-数据库操作</title>
    <url>/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>sqlite数据库(本地数据库）</p>
<img src="/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/1.jpg" class="">

<img src="/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/2.jpg" class="">


<p>QT-Mysql数据库<br>QT+ = core gui sl</p>
<p>QT 32 位，数据库64 位经常连接不成功。</p>
<p>MySQL Product Archives</p>
<p><a href="https://downloads.mysql.com/archives/c-c/" target="_blank" rel="noopener">https://downloads.mysql.com/archives/c-c/</a>  下载 6.0 版本</p>
<p>把lib加入QT的bin目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QtSql&#x2F;QSqlDatabase&gt;</span><br><span class="line">#include &lt;QMessageBox&gt;</span><br><span class="line">#include &lt;QSqlError&gt;</span><br><span class="line">#include &lt;QSqlQuery&gt;</span><br><span class="line">#include &lt;QVariantList&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;打印支持数据库类型</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;qDebug()&lt;&lt;QSqlDatabase::drivers();</span><br><span class="line">   &#x2F;&#x2F;添加MYSQL数据库</span><br><span class="line">   QSqlDatabase db&#x3D;    QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</span><br><span class="line">   &#x2F;&#x2F;连接</span><br><span class="line">   db.setHostName(&quot;localhost&quot;);&#x2F;&#x2F;主机名</span><br><span class="line">   db.setUserName(&quot;root&quot;);   &#x2F;&#x2F; 用户名</span><br><span class="line">   db.setPassword(&quot;861459&quot;);  &#x2F;&#x2F;密码</span><br><span class="line">   db.setDatabaseName(&quot;world&quot;);  &#x2F;&#x2F;数据库表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;打开数据库</span><br><span class="line">   if (!db.open())</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       QMessageBox::warning(this,&quot;错误&quot;,db.lastError().text());</span><br><span class="line">       return ;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">  QMessageBox::warning(this,&quot;成功&quot;,db.lastError().text());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   QSqlQuery query(db);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age) values(1, &#39;mike&#39;, 18); &quot;);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age, score) values(2, &#39;lucy&#39;, 22, 90);&quot;);</span><br><span class="line">&#x2F;&#x2F;   query.exec(&quot;insert into student(id, name, age, score) values(3, &#39;Tom&#39;, 20, 78);&quot;);</span><br><span class="line">&#x2F;&#x2F;obdc风格处理  顺序执行</span><br><span class="line">   query.exec(&quot;create table student(id int primary key auto_increment, name varchar(255), age int, score int);&quot;);</span><br><span class="line"></span><br><span class="line">   query.prepare(&quot;insert into student( name, age, score) values( ?, ?, ?)&quot;);</span><br><span class="line"></span><br><span class="line">    QVariantList namelist;</span><br><span class="line">   namelist&lt;&lt;&quot;xiaoming&quot;&lt;&lt;&quot;xiaozhag&quot;&lt;&lt;&quot;xiaolin&quot;;</span><br><span class="line">   QVariantList agelist;</span><br><span class="line">   agelist&lt;&lt;11&lt;&lt;22&lt;&lt;33;</span><br><span class="line">   QVariantList scorelist;</span><br><span class="line">   scorelist&lt;&lt;59&lt;&lt;69&lt;&lt;79;</span><br><span class="line">   query.addBindValue(namelist);</span><br><span class="line">   query.addBindValue(agelist);</span><br><span class="line">   query.addBindValue(scorelist);</span><br><span class="line"></span><br><span class="line">   query.execBatch();&#x2F;&#x2F;执行预处理</span><br><span class="line">   query.exec(&quot; update student set score &#x3D; 90 where id &#x3D; 3;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   connect(this,&amp;Widget::destroyed,[&#x3D;]()&#123;</span><br><span class="line">QSqlQuery query(db);</span><br><span class="line">       query.exec(&quot;drop table student;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;多个库的调用注意事项</span><br><span class="line">&#x2F;&#x2F;   QSqlDatabase db1&#x3D;    QSqlDatabase::addDatabase(&quot;QMYSQL&quot;,&quot;a&quot;);&#x2F;&#x2F;a当做标识符号</span><br><span class="line">&#x2F;&#x2F;   &#x2F;&#x2F;连接</span><br><span class="line">&#x2F;&#x2F;   db1.setHostName(&quot;localhost&quot;);&#x2F;&#x2F;主机名</span><br><span class="line">&#x2F;&#x2F;   db1.setUserName(&quot;root&quot;);   &#x2F;&#x2F; 用户名</span><br><span class="line">&#x2F;&#x2F;   db1.setPassword(&quot;861459&quot;);  &#x2F;&#x2F;密码</span><br><span class="line">&#x2F;&#x2F;   db1.setDatabaseName(&quot;world&quot;);  &#x2F;&#x2F;数据库表</span><br><span class="line">&#x2F;&#x2F;   if (!db1.open())</span><br><span class="line">&#x2F;&#x2F;   &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;       QMessageBox::warning(this,&quot;错误&quot;,db1.lastError().text());</span><br><span class="line">&#x2F;&#x2F;       return ;</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F;   else</span><br><span class="line">&#x2F;&#x2F;   &#123;</span><br><span class="line">&#x2F;&#x2F;  QMessageBox::warning(this,&quot;成功&quot;,db1.lastError().text());</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F;   QSqlQuery query1(db1);&#x2F;&#x2F;进行关联</span><br><span class="line">&#x2F;&#x2F;   query1.exec(&quot;create table student(id int primary key auto_increment, name varchar(255), age int, score int); create table student(id int primary key, name varchar(255), age int, score int);&quot;);</span><br><span class="line"></span><br><span class="line">query.exec(&quot;select * from student;&quot;);</span><br><span class="line">while(query.next())&#x2F;&#x2F;一行一行 没有内容返回假的</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;取内容</span><br><span class="line">   qDebug()&lt;&lt; query.value(0).toInt()</span><br><span class="line">           &lt;&lt;query.value(1).toString()</span><br><span class="line">          &lt;&lt;query.value(&quot;age&quot;).toInt()</span><br><span class="line">         &lt;&lt;query.value(&quot;score&quot;).toInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取内容</span><br><span class="line">    QString name&#x3D;lineEdit-&gt;text();</span><br><span class="line"></span><br><span class="line">    QString str&#x3D;QString(&quot;delete from student where name &#x3D; &#39;%1&#39;;&quot;).arg(name);</span><br><span class="line">   &#x2F;&#x2F;开启事务</span><br><span class="line">    QSqlDatabase::database().transaction();</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.exec(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_2_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;确定删除</span><br><span class="line">    QSqlDatabase::database().commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButton_3_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;回滚</span><br><span class="line">     QSqlDatabase::database().rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-传输文件</title>
    <url>/QT-Lover/QT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<img src="/QT-Lover/QT-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/1.jpg" class="">


<p>定时发送，防止粘包。。。</p>
<p>client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef CLIENTWIDGET_H</span><br><span class="line">#define CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_clientwidget.h&quot;</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include &lt;QTcpSocket&gt;</span><br><span class="line"></span><br><span class="line">class clientWidget : public QWidget, private Ui::clientWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit clientWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QTcpSocket *tcpSocket; &#x2F;&#x2F;通信套接字</span><br><span class="line">    QFile file; &#x2F;&#x2F;文件对象</span><br><span class="line">    QString fileName; &#x2F;&#x2F;文件名字</span><br><span class="line">    qint64 fileSize; &#x2F;&#x2F;文件大小</span><br><span class="line">    qint64 recvSize; &#x2F;&#x2F;已经发送文件的大小</span><br><span class="line"></span><br><span class="line">     bool    isStart;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonconect_clicked();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"></span><br><span class="line">#include &quot;clientwidget.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QMessageBox&gt;</span><br><span class="line">#include &lt;QHostAddress&gt;</span><br><span class="line">clientWidget::clientWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    tcpSocket&#x3D;new QTcpSocket (this);</span><br><span class="line">    setWindowTitle(&quot;客户端&quot;);</span><br><span class="line">        isStart&#x3D;true;</span><br><span class="line"></span><br><span class="line">        this-&gt;progressBar-&gt;setValue(0); &#x2F;&#x2F;当前值</span><br><span class="line"></span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        QByteArray  buf&#x3D;tcpSocket-&gt;readAll();</span><br><span class="line">        if(true&#x3D;&#x3D;isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            isStart&#x3D;false;</span><br><span class="line">            &#x2F;&#x2F;头部信息</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;初始化</span><br><span class="line">            fileName&#x3D;QString(buf).section(&quot;##&quot;,0,0);</span><br><span class="line">            fileSize&#x3D;QString(buf).section(&quot;##&quot;,1,1).toInt();</span><br><span class="line">            recvSize&#x3D;0;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;打开文件</span><br><span class="line">            file.setFileName(fileName);</span><br><span class="line">            bool isok&#x3D;file.open(QIODevice::WriteOnly);</span><br><span class="line">            if(false&#x3D;&#x3D;isok)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug()&lt;&lt;&quot;write error 40&quot;;</span><br><span class="line">                tcpSocket-&gt;disconnectFromHost(); &#x2F;&#x2F;断开连接</span><br><span class="line">                tcpSocket-&gt;close(); &#x2F;&#x2F;关闭套接字</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;   this-&gt;progressBar-&gt;setMinimum(0); &#x2F;&#x2F;最小值</span><br><span class="line">            this-&gt;progressBar-&gt;setMaximum(fileSize&#x2F;1024); &#x2F;&#x2F;最大值</span><br><span class="line">            this-&gt;progressBar-&gt;setValue(0); &#x2F;&#x2F;当前值</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">       else</span><br><span class="line">            &#123;</span><br><span class="line">                qint64 len&#x3D;file.write(buf);</span><br><span class="line"></span><br><span class="line">                if(len &gt;0) &#x2F;&#x2F;接收数据大于0</span><br><span class="line">                &#123;</span><br><span class="line">                    recvSize +&#x3D; len; &#x2F;&#x2F;累计接收大小</span><br><span class="line"></span><br><span class="line">                    qDebug() &lt;&lt; recvSize;</span><br><span class="line">                this-&gt;progressBar-&gt;setValue(recvSize&#x2F;1024);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if(recvSize&#x3D;&#x3D;fileSize)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    tcpSocket-&gt;write(&quot;file done&quot;);</span><br><span class="line">                    file.close();</span><br><span class="line">                    QMessageBox::information(this,&quot;完成&quot;,&quot;文件接收完成！&quot;);</span><br><span class="line">                    isStart&#x3D;true;</span><br><span class="line">                    tcpSocket-&gt;disconnectFromHost();&#x2F;&#x2F;断开连接</span><br><span class="line">                    tcpSocket-&gt;close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clientWidget::on_Buttonconect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取</span><br><span class="line">    QString ip&#x3D;this-&gt;Editip-&gt;text();</span><br><span class="line">    quint16 port&#x3D;Editport-&gt;text().toInt();&#x2F;&#x2F;quint</span><br><span class="line"></span><br><span class="line">    tcpSocket-&gt;connectToHost(QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QTcpServer&gt; &#x2F;&#x2F;监听套接字</span><br><span class="line">#include &lt;QTcpSocket&gt; &#x2F;&#x2F;通信套接字</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include &lt;QTimer&gt;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget, private Ui::Widget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line">private slots:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void on_buttonFile_clicked();</span><br><span class="line"></span><br><span class="line">    void on_buttonSend_clicked();</span><br><span class="line">    void senddata();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    QTcpServer *tcpServer; &#x2F;&#x2F;监听套接字</span><br><span class="line">    QTcpSocket *tcpSocket; &#x2F;&#x2F;通信套接字</span><br><span class="line"></span><br><span class="line">    QFile file; &#x2F;&#x2F;文件对象</span><br><span class="line">    QString fileName; &#x2F;&#x2F;文件名字</span><br><span class="line">    qint64 fileSize; &#x2F;&#x2F;文件大小</span><br><span class="line">    qint64 sendSize; &#x2F;&#x2F;已经发送文件的大小</span><br><span class="line"></span><br><span class="line">    QTimer timer; &#x2F;&#x2F;定时器</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"></span><br><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &lt;QFileDialog&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QFileInfo&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;监听套接字</span><br><span class="line">    tcpServer &#x3D; new QTcpServer(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;监听</span><br><span class="line">    tcpServer-&gt;listen(QHostAddress::Any, 8888);</span><br><span class="line">    setWindowTitle(&quot;服务器端口为：8888&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;两个按钮都不能按</span><br><span class="line">    this-&gt;buttonFile-&gt;setEnabled(false);</span><br><span class="line">    this-&gt;buttonSend-&gt;setEnabled(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果客户端成功和服务器连接</span><br><span class="line">    &#x2F;&#x2F;tcpServer会自动触发 newConnection()</span><br><span class="line"></span><br><span class="line">    connect(tcpServer, &amp;QTcpServer::newConnection,</span><br><span class="line">    [&#x3D;]()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;取出建立好连接的套接字</span><br><span class="line">        tcpSocket &#x3D; tcpServer-&gt;nextPendingConnection();</span><br><span class="line">        &#x2F;&#x2F;获取对方的ip和端口</span><br><span class="line">        QString ip &#x3D; tcpSocket-&gt;peerAddress().toString();</span><br><span class="line">        quint16 port &#x3D; tcpSocket-&gt;peerPort();</span><br><span class="line"></span><br><span class="line">        QString str &#x3D; QString(&quot;[%1:%2] 成功连接&quot;).arg(ip).arg(port);</span><br><span class="line">        this-&gt;textEdit-&gt;setText(str); &#x2F;&#x2F;显示到编辑区</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;成功连接后，才能按选择文件</span><br><span class="line">        this-&gt;buttonFile-&gt;setEnabled(true);</span><br><span class="line"></span><br><span class="line">        connect(tcpSocket, &amp;QTcpSocket::readyRead,</span><br><span class="line">                [&#x3D;]()</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;取客户端的信息</span><br><span class="line">                    QByteArray buf &#x3D; tcpSocket-&gt;readAll();</span><br><span class="line">                    if(QString(buf) &#x3D;&#x3D; &quot;file done&quot;)</span><br><span class="line">                    &#123;&#x2F;&#x2F;文件接收完毕</span><br><span class="line">                         this-&gt;textEdit-&gt;append(&quot;文件发送完毕&quot;);</span><br><span class="line">                         file.close();</span><br><span class="line">                         &#x2F;&#x2F;断开客户端端口</span><br><span class="line">                         tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">                         tcpSocket-&gt;close();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">    connect(&amp;timer,&amp;QTimer::timeout,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        timer.stop();</span><br><span class="line">        senddata();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_buttonFile_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;路径选择</span><br><span class="line">    QString filepath&#x3D;QFileDialog::getOpenFileName(this,&quot;open&quot;,&quot;..&#x2F;&quot;);</span><br><span class="line">   &#x2F;&#x2F;判断是否为空</span><br><span class="line">    if (filepath.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;failure&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        fileName.clear();</span><br><span class="line">        fileSize&#x3D;0;&#x2F;&#x2F;数据初始化</span><br><span class="line"></span><br><span class="line">        QFileInfo info(filepath);</span><br><span class="line">        fileName&#x3D;info.fileName();</span><br><span class="line">        fileSize&#x3D;info.size();</span><br><span class="line"></span><br><span class="line">        sendSize&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;指定文件名字  只读打开失败</span><br><span class="line">        file.setFileName(filepath);</span><br><span class="line">        bool isok&#x3D;file.open(QIODevice::ReadOnly);</span><br><span class="line">        if(false&#x3D;&#x3D;isok)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug()&lt;&lt;&quot;只读方式打开失败 77&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        this-&gt;textEdit-&gt;append(filepath);</span><br><span class="line">        this-&gt;buttonFile-&gt;setEnabled(false);</span><br><span class="line">        this-&gt;buttonSend-&gt;setEnabled(true);&#x2F;&#x2F;发送按钮显示</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送文件按钮</span><br><span class="line">void Widget::on_buttonSend_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;头部的信息</span><br><span class="line">    QString head&#x3D;QString (&quot;%1##%2&quot;).arg(fileName).arg(fileSize);</span><br><span class="line"></span><br><span class="line">    qint64 len &#x3D;tcpSocket-&gt;write(head.toUtf8());</span><br><span class="line"></span><br><span class="line">    if (len &gt;0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;真正的信息&#x2F;&#x2F;定时发送，防止黏包</span><br><span class="line">        timer.start(20);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;头部信息发送失败~&quot;;</span><br><span class="line">        file.close();</span><br><span class="line">       this-&gt;buttonFile-&gt;setEnabled(true);</span><br><span class="line">       this-&gt;buttonSend-&gt;setEnabled(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::senddata()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;textEdit-&gt;append(&quot;正在发送文件……&quot;);</span><br><span class="line">    qint64 len &#x3D;0;</span><br><span class="line">    do&#123;</span><br><span class="line">        char buf[4*1024]&#x3D;&#123;0&#125;;  &#x2F;&#x2F;每次发送4k</span><br><span class="line">        len&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;往文件都数据 存在buf   返回len 读了多少</span><br><span class="line">        len &#x3D;file.read(buf,sizeof(buf));</span><br><span class="line">        &#x2F;&#x2F;文件都数据 存在buf 发送   指定长度len   返回值发了len</span><br><span class="line">        len &#x3D; tcpSocket-&gt;write(buf,len);</span><br><span class="line">        sendSize+&#x3D;len;</span><br><span class="line">    &#125;</span><br><span class="line">    while(len&gt;0);</span><br><span class="line">        if(sendSize&#x3D;&#x3D;fileSize)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            this-&gt;textEdit-&gt;append(&quot;文件发送完毕&quot;);</span><br><span class="line">            file.close();</span><br><span class="line">            tcpSocket-&gt;disconnect();</span><br><span class="line">            tcpSocket-&gt;close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-UDP</title>
    <url>/QT-Lover/QT-UDP/</url>
    <content><![CDATA[<img src="/QT-Lover/QT-UDP/1.jpg" class="">


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include &lt;QUdpSocket&gt;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget, private Ui::Widget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QUdpSocket *udpsocket;&#x2F;&#x2F;udp套接字</span><br><span class="line">private slots:</span><br><span class="line">    void on_pushButtontsend_clicked();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include&lt;QHostAddress&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配空间指定父对象</span><br><span class="line">  &#x2F;&#x2F;  udpsocket&#x3D;new QUdpSocket (this);组播D类地址</span><br><span class="line"> &#x2F;&#x2F;udpsocket-&gt;joinMulticastGroup(QHostAddress(&quot;224.0.0.2&quot;))</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;广播255.255.255.255</span><br><span class="line">&#x2F;&#x2F;udpsocket-&gt;bind(QHostAddress::AnyIPv4,8888);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">    udpsocket-&gt;bind(QHostAddress::Any,8888);</span><br><span class="line">    this-&gt;setWindowTitle(&quot;服务端8888&quot;);</span><br><span class="line"></span><br><span class="line">    connect(udpsocket,&amp;QUdpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line">        char buff[1024]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">        QHostAddress cliAddr;</span><br><span class="line">        quint16 port;</span><br><span class="line">        qint64 len&#x3D;udpsocket-&gt;readDatagram(buff,sizeof(buff),&amp;cliAddr,&amp;port);</span><br><span class="line">       &#x2F;&#x2F;接收不大于maxSize字节的数据报并将其存储在数据中。</span><br><span class="line">        &#x2F;&#x2F;发送方的主机地址和端口存储在address和“port”中(除非指针为0)。成功返回数据报的大小;</span><br><span class="line">        if (len&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            QString str&#x3D;QString (&quot;[%1 :%2] %3&quot;).arg(cliAddr.toString()).arg(port).arg(buff);</span><br><span class="line">             this-&gt;textEdit-&gt;setText(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Widget::on_pushButtontsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    QString ip&#x3D;this-&gt;lineEditIP-&gt;text();</span><br><span class="line">    quint16 port&#x3D;this-&gt;lineEditPort-&gt;text().toInt();</span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容；</span><br><span class="line">    QString str&#x3D;this-&gt;textEdit-&gt;toPlainText();</span><br><span class="line">    udpsocket-&gt;writeDatagram(str.toUtf8().data(),QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-中英配置</title>
    <url>/QT-Lover/QT-%E4%B8%AD%E8%8B%B1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/kidults/article/details/87969380" target="_blank" rel="noopener">https://blog.csdn.net/kidults/article/details/87969380</a></p>
<p><a href="https://blog.csdn.net/qq_26787115/article/details/80226060" target="_blank" rel="noopener">https://blog.csdn.net/qq_26787115/article/details/80226060</a></p>
<p>1、创建语言文件</p>
<p>　　打开.pro文件，加入以下：</p>
<p>TRANSLATIONS+=cn.ts</p>
<p>　　工具-&gt;外部-&gt;Qt语言家-&gt;更新翻译,将生成翻译文件cn.ts  en.ts</p>
<p>2、Windows则在开始菜单中可以找到：</p>
<p>在打开的Liguist，把上一步生成的en.ts打开，选择Source text 进行逐个翻译</p>
<p>翻译完后，将 en.ts 进行保存</p>
<p>3、工具-&gt;外部-&gt;Qt语言家-&gt;发布翻译,将生成翻译文件**.qm</p>
<p>QTranslator translator;//系统中英翻译</p>
<img src="/QT-Lover/QT-%E4%B8%AD%E8%8B%B1%E9%85%8D%E7%BD%AE/1.JPG" class="">



<p>注意：翻译后，应该避免控件操作控件的操作</p>
<p>**</p>
<p>注：翻译文件加载的位置必须在界面实例化之前完成，否则是没有效果的</p>
<p>**</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-TCP</title>
    <url>/QT-Lover/QT-TCP/</url>
    <content><![CDATA[<p>因为IP地址是有来标识主机的，IP地址相同说明可能是同一台计算机。<br>端口是用来标识进程的，同一台计算机上两个进程绝对不能占用同一个端口，所以不可能是同一台计算机。<br>{协议，本地地址，本地端口，远程地址，远程端口}。 </p>
<p>项目文件<br>QT += network</p>


<p>client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef CLIENTWIDGET_H</span><br><span class="line">#define CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_clientwidget.h&quot;</span><br><span class="line">#include &lt;QTcpSocket&gt;</span><br><span class="line"></span><br><span class="line">class ClientWidget : public QWidget, private Ui::ClientWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit ClientWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonconnect_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonsend_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonclose_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTcpSocket *tcpSocket;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; CLIENTWIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line">#include &quot;clientwidget.h&quot;</span><br><span class="line">#include&lt;QTextEdit&gt;</span><br><span class="line">#include&lt;QHostAddress&gt;</span><br><span class="line">ClientWidget::ClientWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配空间</span><br><span class="line">    this-&gt;setWindowTitle(&quot;客户端&quot;);</span><br><span class="line"></span><br><span class="line">    tcpSocket&#x3D;new QTcpSocket(this);</span><br><span class="line">&#x2F;&#x2F;请求连接成功标志触发 connected</span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::connected,[&#x3D;]()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this-&gt;Textrend-&gt;setText(&quot;成功连接！QAQ&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;读取接受服务端 readRead</span><br><span class="line">    connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        QByteArray array&#x3D;tcpSocket-&gt;readAll();</span><br><span class="line"></span><br><span class="line">        this-&gt;Textrend-&gt;append(array);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonconnect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取IP</span><br><span class="line"> QString ip&#x3D;this-&gt;lineEditIp-&gt;text();</span><br><span class="line"> quint16 port&#x3D;this-&gt;lineEditPort-&gt;text().toInt();&#x2F;&#x2F;字符串转化为int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主动连接</span><br><span class="line"> tcpSocket-&gt;abort();&#x2F;&#x2F;取消之前的连接</span><br><span class="line"></span><br><span class="line"> tcpSocket-&gt;connectToHost(QHostAddress(ip),port);&#x2F;&#x2F;建立连接函数！！</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString str&#x3D;this-&gt;Textwrite-&gt;toPlainText();</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());&#x2F;&#x2F;发送函数  含中文</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ClientWidget::on_Buttonclose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">      tcpSocket-&gt;disconnectFromHost();     &#x2F;&#x2F;断开连接disconnected</span><br><span class="line"></span><br><span class="line">      this-&gt;Textrend-&gt;setText(&quot;断开连接！QAQ&quot;);</span><br><span class="line">&#x2F;&#x2F;    tcpSocket-&gt;close();</span><br><span class="line">&#x2F;&#x2F;     tcpSocket&#x3D;NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef SERVERWIDGET_H</span><br><span class="line">#define SERVERWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &quot;ui_serverwidget.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QTcpServer&gt;&#x2F;&#x2F; 监听套接字</span><br><span class="line">#include &lt;QTcpSocket&gt;&#x2F;&#x2F;通信套接字  服务器两个</span><br><span class="line">class ServerWidget : public QWidget, private Ui::ServerWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit ServerWidget(QWidget *parent &#x3D; 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_Buttonsend_clicked();</span><br><span class="line"></span><br><span class="line">    void on_Buttonclose_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QTcpServer *tcpSerever;</span><br><span class="line">    QTcpSocket *tcpSocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; SERVERWIDGET_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line">#include &quot;serverwidget.h&quot;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">ServerWidget::ServerWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(this);</span><br><span class="line"></span><br><span class="line">     tcpSocket&#x3D;NULL;&#x2F;&#x2F;否则提示。。</span><br><span class="line">     tcpSerever&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">    this-&gt;setWindowTitle(&quot;服务端 8888&quot;);</span><br><span class="line"></span><br><span class="line">    tcpSerever&#x3D;new QTcpServer (this);&#x2F;&#x2F;监听</span><br><span class="line"></span><br><span class="line">    tcpSerever-&gt;listen(QHostAddress::Any,8888);&#x2F;&#x2F;只能在接收成功  server  newConnection是接收信息</span><br><span class="line"></span><br><span class="line">    connect(tcpSerever,&amp;QTcpServer::newConnection,[&#x3D;]()&#123;&#x2F;&#x2F;取出套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tcpSocket&#x3D;tcpSerever-&gt;nextPendingConnection();</span><br><span class="line"></span><br><span class="line">        QString ip&#x3D;tcpSocket-&gt;peerAddress().toString();</span><br><span class="line"></span><br><span class="line">        qint16 port&#x3D;tcpSocket-&gt;peerPort();</span><br><span class="line"></span><br><span class="line">       QString temp&#x3D;QString (&quot;[%1 : %2]:连接成功！QAQ&quot;).arg(ip).arg(port);</span><br><span class="line">     &#x2F;&#x2F;  qDebug()&lt;&lt;&quot;  d &quot;;</span><br><span class="line">       this-&gt;textEdit-&gt;setText(temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       connect(tcpSocket,&amp;QTcpSocket::readyRead,[&#x3D;]()</span><br><span class="line">       &#123;</span><br><span class="line">          &#x2F;&#x2F;通信取出来</span><br><span class="line">           QByteArray array &#x3D;tcpSocket-&gt;readAll();</span><br><span class="line"></span><br><span class="line">           textEdit-&gt;append(array);</span><br><span class="line"></span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServerWidget::on_Buttonsend_clicked()&#x2F;&#x2F;写传输</span><br><span class="line">&#123;</span><br><span class="line">    if(NULL &#x3D;&#x3D; tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取编辑区内容</span><br><span class="line">    QString str &#x3D;this-&gt;textEdit_2-&gt;toPlainText();</span><br><span class="line">    &#x2F;&#x2F;发送</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServerWidget::on_Buttonclose_clicked()&#x2F;&#x2F;关闭</span><br><span class="line">&#123;</span><br><span class="line">    if(NULL &#x3D;&#x3D; tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">    tcpSocket-&gt;close();</span><br><span class="line">     tcpSocket&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/QT-Lover/QT-TCP/1.JPG" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-线程</title>
    <url>/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>QT-线程池</p>
<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" class="">

<p>QT-线程QtConcurrent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：</span><br><span class="line">QT -&#x3D; gui concurrent</span><br><span class="line">CONFIG +&#x3D; c++11 console</span><br><span class="line">第二步：#include &lt;QtConcurrent&#x2F;QtConcurrent&gt;</span><br><span class="line">QString filePath&#x3D;&quot;D:&#x2F;test2.txt&quot;;</span><br><span class="line">    QByteArray data&#x3D;&quot;hello concurrentthread2&quot;;</span><br><span class="line">    QtConcurrent::run([&amp;filePath,&amp;data]()&#123;</span><br><span class="line">        qDebug()&lt;&lt;data;</span><br><span class="line">        QFile file(filePath);</span><br><span class="line">        file.open(QIODevice::WriteOnly);</span><br><span class="line">        file.write(data);</span><br><span class="line">        file.waitForBytesWritten(30*1000);&#x2F;&#x2F;等待写入</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>QT-线程QThread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef MYTHREAD_H</span><br><span class="line">#define MYTHREAD_H</span><br><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">&#x2F;&#x2F;继承获取接口</span><br><span class="line">class MyThread:public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    void run()&#x2F;&#x2F;斜体虚函数</span><br><span class="line">&#123;</span><br><span class="line">    qDebug()&lt;&lt;QThread::currentThread();&#x2F;&#x2F;指针 或者说显示当前的线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c中</span><br><span class="line">MyThread mythread；</span><br><span class="line">  mythread.start();  &#x2F;&#x2F;启动接口函数</span><br></pre></td></tr></table></figure>
<p>QT-线程制图</p>
<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE1.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE2.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE3.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE4.jpg" class="">

<img src="/QT-Lover/QT-%E7%BA%BF%E7%A8%8B/QT-%E7%BA%BF%E7%A8%8B%E5%88%B6%E5%9B%BE5.jpg" class="">


<p>QT-connect第五个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 队列连接：槽函数在接受者所在线程执行。QueuedConnection</span><br><span class="line">* 直接连接：槽函数在发送者所在线程执行。DirectConnection</span><br><span class="line">* 自动连接：二者不在同一线程时，等同于队列连接AutoConnection</span><br><span class="line"></span><br><span class="line">connect(thread,&amp;QThread::finished,thread,&amp;QObject::deleteLater);</span><br><span class="line">&#x2F;&#x2F;线程结束后调用deleteLater来销毁分配的内存</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-程序打包</title>
    <url>/QT-Lover/QT-%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>打开 MinGW 5.3.0 32bit</p>
<p>E:\QT\5.9.6\mingw53_32\bin\windeployqt.exe  环境变量</p>
<p>当前目录</p>
<p>  cd    / d   C:\Users\asus\Desktop\212</p>
<p>windeployqt  put.exe</p>
<p>windeployqt  Template.exe</p>
<p>//linux 系统同样有linuxdeployqt</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-常见坐标获取</title>
    <url>/QT-Lover/QT-%E5%B8%B8%E8%A7%81%E5%9D%90%E6%A0%87%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<p>当前光标相对于屏幕的绝对位置/ /对电脑屏幕来说，左上角也为（0，0）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QCursor::pos()</span><br></pre></td></tr></table></figure>
<p>当前光标相对于当前窗口的位置//相对转化函数mapfromglobal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this-&gt;mapFromGlobal(QCursor::pos())</span><br></pre></td></tr></table></figure>
<p>鼠标事件发生的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MainWindow::mouseReleaseEvent(QMouseEvent* event)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    QPoint pos &#x3D; event-&gt;pos();       &#x2F;&#x2F;相对于当前窗口的位置</span><br><span class="line"></span><br><span class="line">    QPoint globalPos &#x3D; event-&gt;globalPos();    &#x2F;&#x2F;相对于屏幕的全局绝对位置</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>窗体的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget *widget &#x3D; new QWidget();</span><br><span class="line"></span><br><span class="line">widget.pos();    &#x2F;&#x2F;窗体的左上角的位置</span><br></pre></td></tr></table></figure>
<p>判断鼠标光标是否悬浮在某个子控件上//xxx-&gt;geometry()-&gt;contains()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(ui-&gt;pushButtonTest-&gt;geometry().contains( this-&gt;mapFromGlobal(QCursor::pos())))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-制图</title>
    <url>/QT-Lover/QT-%E5%88%B6%E5%9B%BE/</url>
    <content><![CDATA[<p><strong>画笔</strong><br>QPainter</p>
<p><strong>Device设备</strong><br>QPixmap  QImage QPicture</p>
<p>QPixmap专门为图像在屏幕上的显示做了优化，其中QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。（白色变透明）</p>
<p>QImage专门为图像的像素级访问做了优化。<br>QPicture则可以记录和重现QPainter的各条命令。</p>
<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPixmap.jpg" class="">


<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPixmap2.jpg" class="">



<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QImage.jpg" class="">


<img src="/QT-Lover/QT-%E5%88%B6%E5%9B%BE/QPicture.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-写法小发现</title>
    <url>/QT-Lover/QT-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>QString::arg()用法</p>
<p>Qstring str=Qstring(“%1 %2 %3 “).arg(1).arg(2).arg(“egdhqdg “);</p>
<p>Qstring::sprintf()用法</p>
<p>QString str；</p>
<p>str.sprintf(“%d %s,10,”hello””);</p>
<p>oLatin1、toLocal8Bit都是QString转QByteArray的方法</p>
<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QByteArray qByteArray(&quot;&quot;) ; </span><br><span class="line">qByteArray.append(&quot;daniel&quot;);</span><br><span class="line">qByteArray.size();</span><br><span class="line">qByteArray.count(&#39;a&#39;);</span><br><span class="line">qByteArray.fill(&#39;a&#39;);</span><br><span class="line">qByteArray.data();</span><br></pre></td></tr></table></figure>



<p>#define TIMEMS      qPrintable(QTime::currentTime().toString(“HH:mm:ss zzz”))</p>
<p>开源控件链接：<a href="https://gitee.com/feiyangqingyun/QWidgetDemo" target="_blank" rel="noopener">https://gitee.com/feiyangqingyun/QWidgetDemo</a></p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-文件</title>
    <url>/QT-Lover/QT-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>文件系统分类:<br>1顺序访问设备:<br>2随机访问设备:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本文本</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line">#include&lt;QFileInfo&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QDir&gt;</span><br><span class="line">    QFile file(&quot;D:&#x2F;in.txt&quot;);&#x2F;&#x2F;QFile创建了一个文件对象。</span><br><span class="line">    &#x2F;&#x2F;qDebug()&lt;&lt;QDir::currentPath();</span><br><span class="line">    if (!file.open(QIODevice::ReadOnly|QIODevice::Text))&#x2F;&#x2F;只读 文本</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;open file failure&quot;;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        while(!file.atEnd())&#123;</span><br><span class="line">            qDebug()&lt;&lt;file.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   QFileInfo info(file);</span><br><span class="line">    qDebug()&lt;&lt;info.isDir();&#x2F;&#x2F;检查该文件是否是目录；</span><br><span class="line">    qDebug()&lt;&lt;info.isExecutable();  &#x2F;&#x2F;检查该文件是否是可执行文件等。</span><br><span class="line">    qDebug()&lt;&lt;info.baseName();    &#x2F;&#x2F;可以直接获得文件名；</span><br><span class="line">    qDebug()&lt;&lt;info.completeBaseName();  &#x2F;&#x2F;获取完整的文件名</span><br><span class="line">    qDebug()&lt;&lt;info.suffix();     &#x2F;&#x2F;则直接获取文件后缀名。</span><br><span class="line">    qDebug()&lt;&lt;info.completeSuffix(); &#x2F;&#x2F; 获取完整的文件后缀</span><br></pre></td></tr></table></figure>
<p>二进制文本<br>QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU或者字节顺序（大端或小端）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QFile file(&quot;file.dat&quot;);</span><br><span class="line">file.open(QIODevice::WriteOnly);</span><br><span class="line">QDataStream out(&amp;file);</span><br><span class="line">out &lt;&lt; QString(&quot;the answer is&quot;);  &#x2F;&#x2F;写入</span><br><span class="line">out &lt;&lt; (qint32)42;</span><br><span class="line">QFile file(&quot;file.dat&quot;);</span><br><span class="line">file.open(QIODevice::ReadOnly);</span><br><span class="line">QDataStream in(&amp;file);</span><br><span class="line">QString str;</span><br><span class="line">qint32 a;</span><br><span class="line">in &gt;&gt; str &gt;&gt;a;</span><br></pre></td></tr></table></figure>
<p>QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file.open(QIODevice::ReadWrite);&#x2F;&#x2F;读写 </span><br><span class="line">    QDataStream stream(&amp;file);</span><br><span class="line">    QString str &#x3D; &quot;fff answer is 42&quot;;</span><br><span class="line">    stream &lt;&lt; str;</span><br><span class="line">    file.close();</span><br></pre></td></tr></table></figure>
<p>文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QCoreApplication a(argc, argv);</span><br><span class="line">    QFile data (&quot;D:&#x2F;file2.txt&quot;);</span><br><span class="line">    if (!data.open(QFile::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        QTextStream in(&amp;data);</span><br><span class="line">        in.readAll();</span><br><span class="line">        QString inter&#x3D;in.readAll();</span><br><span class="line">        qDebug()&lt;&lt;inter;</span><br><span class="line">    &#125;</span><br><span class="line">data.close();</span><br></pre></td></tr></table></figure>
<p>QBuffer 内存文件。</p>


<p>另外，QBuffer也支持常用的信号。比如，当有数据可读时，它会发出readyRead（）信号；每一次向QBuffer中写入新数据时都会发出bytesWritten()信号。</p>
]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-事件</title>
    <url>/QT-Lover/QT-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>事件</strong></p>
<p>事件（event）是由系统或者 Qt 本身在不同的时刻发出的。<br>一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p>Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于<code>QEvent</code>。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数<code>（event handler）</code>。</p>
<p>protected  virtual 类 子函数实现</p>
<p>keyPressEvent()<br>keyReleaseEvent()<br>mouseDoubleClickEvent()<br>mouseMoveEvent()          —-setMouseTracking()<br>mousePressEvent()<br>mouseReleaseEvent() 等。</p>
<p>event()函数主要用于事件的分发,分发给不同的事件处理器（event handler）。<br>e-&gt;type() == QEvent::KeyPress  事件类别<br>keyEvent-&gt;key() == Qt::Key_Tab  按键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CustomTextEdit::event(QEvent*e)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   if (e-&gt;type() &#x3D;&#x3D; QEvent::KeyPress)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        QKeyEvent *keyEvent &#x3D;static_cast(e);</span><br><span class="line"></span><br><span class="line">       if (keyEvent-&gt;key() &#x3D;&#x3D; Qt::Key_Tab)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            qDebug() &lt;&lt; &quot;You presstab.&quot;;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件过滤器</strong><br>virtual bool QObject::eventFilter ( QObject *watched, QEvent * event );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool MainWindow::eventFilter(QObject *obj, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">         if (obj &#x3D;&#x3D; textEdit) &#123;                                                    &#x2F;&#x2F;判断被监视的对象</span><br><span class="line">                 if (event-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) &#123;                   &#x2F;&#x2F;判断事件类型</span><br><span class="line">                         QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent*&gt;(event);</span><br><span class="line">                         qDebug() &lt;&lt; &quot;Ate key press&quot; &lt;&lt; keyEvent-&gt;key();</span><br><span class="line">                         return true;                                                    &#x2F;&#x2F;将键盘事件过滤</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                         return false;                                                &#x2F;&#x2F;继续处理其他事件</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">                 &#x2F;&#x2F; pass the event on to the parent class</span><br><span class="line">                 return QMainWindow::eventFilter(obj, event);           &#x2F;&#x2F;调用父类函数</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</p>
<p>1、重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</p>
<p>1、重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</p>
<p>1、在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</p>
<p>1、在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</p>
<p>1、重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApplication : public QApplication</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    MyApplication(int &amp; argc, char ** argv):QApplication(argc, argv)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual bool notify(QObject * obj, QEvent * event)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;qDebug()&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;obj&lt;&lt;event;</span><br><span class="line"></span><br><span class="line">        if(event-&gt;type() &#x3D;&#x3D; QMouseEvent::MouseButtonPress)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            qDebug()&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;obj&lt;&lt;event;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return QApplication::notify(obj,event);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;来源网络</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-dialog</title>
    <url>/QT-Lover/QT-dialog/</url>
    <content><![CDATA[<p>自定义对话框:</p>
<p>    使用QDialog::exec()实现应用程序级别的模态对话框</p>
<p>    使用QDialog::open()实现窗口级别的模态对话框</p>
<p>    使用QDialog::show()实现非模态对话框。</p>
<p>dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);//  属性 ： 让dialog关闭时自动销毁   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模态&#x2F;&#x2F;对话框需要关闭才能用</span><br><span class="line">void MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    	QDialog dialog;</span><br><span class="line">    	dialog.setWindowTitle(tr(&quot;Hello, dialog!&quot;));</span><br><span class="line">dialog.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">非模态&#x2F;&#x2F;对话框不需要关闭也能用，需要析构</span><br><span class="line">void MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog *dialog &#x3D; new QDialog;</span><br><span class="line">    dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);&#x2F;&#x2F;   属性 ： 让dialog关闭时自动销毁         释放内存   堆</span><br><span class="line">    dialog-&gt;setWindowTitle(tr(&quot;Hello, dialog!&quot;)); </span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> QDialog dialog(this);   &#x2F;&#x2F;栈上  子函数里</span><br><span class="line"> QDialog *dialog &#x3D; new QDialog;   &#x2F;&#x2F;堆上    考虑到内存泄漏</span><br></pre></td></tr></table></figure>


<p>消息对话框</p>
<img src="/QT-Lover/QT-dialog/%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg" class="">

<p>标准文件对话框</p>
<img src="/QT-Lover/QT-dialog/%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg" class="">








]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-窗体常用函数</title>
    <url>/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>窗体常用函数</p>
<img src="/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.jpg" class="">

<p>ui-&gt;stackedWidget-&gt;setCurrentIndex(5);</p>
<p>设计换页</p>
<img src="/QT-Lover/QT-%E7%AA%97%E4%BD%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%AE%BE%E8%AE%A1%E6%8D%A2%E9%A1%B5.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-控件</title>
    <url>/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>继承图</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E7%BB%A7%E6%89%BF%E5%9B%BE.jpg" class="" title="来源网络">

<p>Qlabel</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/Qlabel.jpg" class="">

<p>QTextEdit</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTextEdit.jpg" class="">

<p>QListView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QListView.jpg" class="">

<p>QTreeView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTreeView.jpg" class="">

<p>QTableView</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTableView.jpg" class="">

<p>//获取点击行索引int index = tableView-&gt;currentIndex().row();</p>
<p>QPushButton</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QPushButton.jpg" class="">

<p>QComboBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QComboBox.jpg" class="">

<p>QFontComboBox(字体)</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QFontComboBox.jpg" class="">

<p>QRadioButton(单选)</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QRadioButton.jpg" class="">

<p>QCheckBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QCheckBox.jpg" class="">

<p>QScrollBar</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QScrollBar.jpg" class="">

<p>QSpinBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QSpinBox.jpg" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QObject::connect(slider,&amp;QSlider::valueChanged,spinBox,&amp;QSpinBox::setValue);</span><br><span class="line">void (QSpinBox:: *spinBoxSignal)(int)&#x3D;&amp;QSpinBox::valueChanged;</span><br><span class="line">QObject::connect(spinBox,spinBoxSignal,slider,&amp;QSlider::setValue);</span><br></pre></td></tr></table></figure>

<p>QTimeEdit QDateTime</p>



<p>QDateEdit QDateTime</p>



<p>QLineEdit</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QLineEdit.jpg" class="">


<p>布局（水平、网格）</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E5%B8%83%E5%B1%80.jpg" class="">

<p>QGroupBox</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/%E5%B8%83%E5%B1%80.jpg" class="">

<p>QTabWidget</p>
<img src="/QT-Lover/QT-%E6%8E%A7%E4%BB%B6/QTableView.jpg" class="">]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux音频驱动了解</title>
    <url>/Linux-Lover/linux%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>音频编解码芯片</strong></p>
<p>音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频CODEC 最重要的指标。比如常见音频采样率有 8K、44.1K、48K、192K 甚至 384K 和 768K，采样位数常见的有 8 位、16 位、24 位、32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的 HIFI。因此大家会看到高端的音频播放器都会有很高的采<br>样率和采样位数，同样的价格也会越高。当然了，实际的效果还与其他部分有关，采样率和采样位数只是其中重要的指标之一。</p>
<p><strong>WM8960</strong></p>
<p>WM8960 是一颗由 wolfson(欧胜)公司出品的音频编解码芯片。</p>
<p>此接口 5 根线的作用如下：<br>ADCDAT：ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给<br>主控制器。<br>ADCLRC：ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号<br>的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC<br>引脚作为帧时钟。<br>DACDAT：DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。<br>DACLRC ：DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左<br>右声道数据，此信号的频率等于采样率。<br>BCLK ：位时钟，用于同步。<br>MCLK ：主时钟，WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，<br>MCLK 频率等于采样率的 256 或 384 倍，因此大家在 WM8960 的数据手册里面常看到<br>MCLK=256fs 或 MCLK=384fs</p>
<p>I2S 接口需要 3 根信号线<br>SCK ：串行时钟信号，也叫做位时钟(BCLK)，音频数据的每一位数据都对应一个 SCK，立体声都是双声道的，因此 SCK=2×采样率×采样位数。比如采样率为 44.1KHz、16 位的立体声音频，那么 SCK=2×44100×16=1411200Hz=1.4112MHz。</p>
<p>WS ：字段(声道)选择信号，也叫做 (LRCK)，也叫做帧时钟，用于切换左右声道数据，WS 为“1”表示正在传输左声道的数据，WS 为“0”表示正在传输右声道的数据。WS 的频率等于采样率，比如采样率为 44.1KHz 的音频，WS=44.1KHz。</p>
<p>SD：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。<br>数据格式：Left Justified(左对齐)和 Right Justified(右对齐)</p>
<p>为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 (MCLK) 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。</p>
<p><strong>WM8960重要引脚</strong></p>
<p> AUD INT<br> SAI2_TX_SYN<br> SAI2_TX_BLCK<br> SAI2_RX_DATA<br> SAI2_TX_DATA</p>
<p> I2C SCL<br> I2C SDA</p>
<p>两个接口，SAI 和 I2C，我们依次来看一下这两个接口：<br>①、SAI 接口一共用到了 6 根数据线，这 6 根数据线用于 I.MX6ULL 与 WM8960 之间的音频数据收发。<br>②、WM8960 在使用的时候需要进行配置，配置接口为 I2C，连接到了 I.MX6ULL 的 I2C2上。</p>
<p>alsa-lib 和 和 alsa-utils  移植（buildroot）</p>
<p>amixer scontrols  //查看所有设置项</p>
<p>amixer scontents  //查看设置值</p>
<p>amixer sset 设置项目 设置值<br>或：<br>amixer cset 设置项目 设置值</p>
<p>amixer sget 设置项目<br>或：<br>amixer cget 设置项目</p>
<p>amixer sset Headphone 127,127<br>amixer sset Speaker 127,127<br>amixer sset ‘Right Output Mixer PCM’ on<br>amixer sset ‘Left Output Mixer PCM’ on</p>
<p>aplay test.wav //播放歌曲</p>
<p>录音</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #!&#x2F;bin&#x2F;sh</span><br><span class="line"> #正点原子@ALIENTEK</span><br><span class="line"> #设置捕获的音量</span><br><span class="line">amixer cset name&#x3D;&#39;Capture Volume&#39; 90,90</span><br><span class="line"></span><br><span class="line"> #PCM</span><br><span class="line"> amixer sset &#39;PCM Playback&#39; on</span><br><span class="line"> amixer sset &#39;Playback&#39; 256</span><br><span class="line"> amixer sset &#39;Right Output Mixer PCM&#39; on</span><br><span class="line"> amixer sset &#39;Left Output Mixer PCM&#39; on</span><br><span class="line"></span><br><span class="line"> #ADC PCM</span><br><span class="line"> amixer sset &#39;ADC PCM&#39; 200</span><br><span class="line"></span><br><span class="line"> #耳机&#x2F;喇叭（扬声器）设置播放音量，直流&#x2F;交流</span><br><span class="line"> #Turn on Headphone</span><br><span class="line"> amixer sset &#39;Headphone Playback ZC&#39; on</span><br><span class="line"> #Set the volume of your headphones(98% volume，127 is the MaxVolume)</span><br><span class="line"> amixer sset Headphone 125,125</span><br><span class="line"> #Turn on the speaker</span><br><span class="line"></span><br><span class="line"> amixer sset &#39;Speaker Playback ZC&#39; on</span><br><span class="line"> #Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span><br><span class="line"> amixer sset Speaker 125,125</span><br><span class="line"> #Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span><br><span class="line"> amixer sset &#39;Speaker AC&#39; 4</span><br><span class="line"> #Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span><br><span class="line"> amixer sset &#39;Speaker DC&#39; 4</span><br><span class="line"> #音频输入，左声道管理</span><br><span class="line"> #Turn on Left Input Mixer Boost</span><br><span class="line"> amixer sset &#39;Left Input Mixer Boost&#39; off</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT1&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT1&#39; 0</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT2&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT2&#39; 0</span><br><span class="line"> #Turn off Left Boost Mixer LINPUT3</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT3&#39; off</span><br><span class="line"> amixer sset &#39;Left Input Boost Mixer LINPUT3&#39; 0</span><br><span class="line"> #音频输入，右声道管理，全部关闭</span><br><span class="line"> #Turn on Right Input Mixer Boost</span><br><span class="line"> amixer sset &#39;Right Input Mixer Boost&#39; on</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT1&#39; off</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 0</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT2&#39; on</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 127</span><br><span class="line"> amixer sset &#39;Right Boost Mixer RINPUT3&#39; off</span><br><span class="line"> amixer sset &#39;Right Input Boost Mixer RINPUT3&#39; 0</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer cset name &#x3D;&#39;Capture Volume&#39; 100,100</span><br><span class="line"></span><br><span class="line">amixer sset &#39;PCM Playback&#39; on</span><br><span class="line">amixer sset &#39;Playback&#39; 256</span><br><span class="line">amixer sset &#39;Right Output Mixer PCM&#39; on</span><br><span class="line">amixer sset &#39;Left Output Mixer PCM&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset &#39;ADC PCM&#39; 200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Headphone Playback ZC&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset Headphone 125,125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker Playback ZC&#39; on</span><br><span class="line"></span><br><span class="line">amixer sset Speaker 125,125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker AC&#39; 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Speaker DC&#39; 4</span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Input Mixer Boost&#39; on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Boost Mixer LINPUT1&#39; off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT1&#39; 0</span><br><span class="line"> amixer sset &#39;Left Boost Mixer LINPUT2&#39; on</span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT2&#39; 127</span><br><span class="line">amixer sset &#39;Left Boost Mixer LINPUT3&#39; off</span><br><span class="line">amixer sset &#39;Left Input Boost Mixer LINPUT3&#39; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">amixer sset &#39;Right Input Mixer Boost&#39; on</span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT1&#39; off</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT1&#39; 0</span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT2&#39; off</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT2&#39; 0</span><br><span class="line"></span><br><span class="line">amixer sset &#39;Right Boost Mixer RINPUT3&#39; on</span><br><span class="line">amixer sset &#39;Right Input Boost Mixer RINPUT3&#39; 127</span><br></pre></td></tr></table></figure>
<p>arecord -f cd -d 10 record.wav<br>aplay record.wav</p>
<p>保存声卡设置<br>alsactl -f /var/lib/alsa/asound.state store //保存声卡设置<br>alsactl -f /var/lib/alsa/asound.state restore //配置</p>
<p>打开/etc/init.d/rcS 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -f &quot;&#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state&quot; ]; then</span><br><span class="line"> echo &quot;ALSA: Restoring mixer setting......&quot;</span><br><span class="line"> &#x2F;sbin&#x2F;alsactl -f &#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state restore &amp;</span><br><span class="line"> fi</span><br></pre></td></tr></table></figure>

<p><strong>mplayer</strong></p>
<p>1 、mplayer播放音频<br>mplayer test.flac</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 ：增加音量。</span><br><span class="line">0：减小音量。</span><br><span class="line">左键：倒退 10 秒</span><br><span class="line">右键：快进 10 秒</span><br><span class="line">上键：倒退 1 分钟</span><br><span class="line">下键：快进 1 分钟</span><br><span class="line">空格：暂停和播放</span><br></pre></td></tr></table></figure>

<p>2、视频播放测试</p>
<p>mplayer test.avi -fs //居中播放视频</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>QT-信号传递</title>
    <url>/Linux-Lover/-%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送类</span><br><span class="line"></span><br><span class="line"> void send()   &#123; </span><br><span class="line"></span><br><span class="line">  mit newPaper(m_name);  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">    void newPaper(const QString &amp;name);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    QString m_name;</span><br><span class="line"></span><br><span class="line">接受类</span><br><span class="line"></span><br><span class="line"> Reader()  &#123;&#125;</span><br><span class="line"></span><br><span class="line">   void receiveNewspaper(const QString &amp;name)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        qDebug() &lt;&lt; &quot;ReceivesNewspaper: &quot; &lt;&lt; name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>摄像头和声卡驱动</title>
    <url>/Linux-Lover/%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>写一个摄像头驱动程序<br>-&gt; uvc驱动程序重点<br>描述符的分析<br>属性的控制：VideoControl Interface 设置<br>格式的选择：VideoStreaming Interface 设置<br>数据的获取：VideoStreaming Interface 的URB来获得</p>
<p>内核配置摄像头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device Drivers </span><br><span class="line">---&gt;&lt;*&gt; Multimedia support</span><br><span class="line">   ---&gt;  [*] Media USB Adapters </span><br><span class="line">        &lt;*&gt;USB Video Class (UVC)</span><br><span class="line">        [*]UVC input events device support</span><br></pre></td></tr></table></figure>



<p>声卡驱动</p>
<p>oss(交钱)<br>alsa（主流，可以模拟oss）</p>
<p>存储：数字信号。<br>播放：一定条件，采样频率越高失真率越少，容量越大。44k<br>转化精度:8bit,16bit。<br>通道：单/双</p>
<p>写一个声卡驱动程序<br>-&gt;alsa 驱动程序</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 232、485、GPS</title>
    <url>/Linux-Lover/Linux-232%E3%80%81485%E3%80%81GPS/</url>
    <content><![CDATA[<p>串口是很常用的一个外设，在 Linux 下通常通过串口和其他设备或传感器进行通信，根据<br>电平的不同，串口分为 TTL 和 RS232。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uart_driver  注册与注销</span><br><span class="line">int uart_register_driver(struct uart_driver *drv)</span><br><span class="line">void uart_unregister_driver(struct uart_driver *drv)</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">int uart_add_one_port(struct uart_driver *drv,</span><br><span class="line">struct uart_port *uport)</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux SPI</title>
    <url>/Linux-Lover/nux-SPI/</url>
    <content><![CDATA[<p>spi_master 结构<br>transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函<br>数。<br>transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，<br>SPI 的数据会打包成 spi_message，然后以队列方式发送出去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spi_master  申请与释放</span><br><span class="line">spi_alloc_master 函数用于申请 spi_master，函数原型如下：</span><br><span class="line">struct spi_master *spi_alloc_master(struct device *dev,</span><br><span class="line">unsigned size)</span><br><span class="line"></span><br><span class="line">spi_master 的释放通过 spi_master_put 函数来完成，当我们删除一个 SPI 主机驱动的时候就</span><br><span class="line">需要释放掉前面申请的 spi_master，spi_master_put 函数原型如下：</span><br><span class="line">void spi_master_put(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spi_master  的注册</span><br><span class="line">int spi_register_master(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"> spi_master 的注销</span><br><span class="line">void spi_unregister_master(struct spi_master *master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spi_message初始化</span><br><span class="line">void spi_message_init(struct spi_message *m)</span><br><span class="line"></span><br><span class="line">spi_transfer 添加到 spi_message 队列中</span><br><span class="line">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)</span><br><span class="line"></span><br><span class="line">同步传输函数为 spi_sync，函数原型如下：</span><br><span class="line">int spi_sync(struct spi_device *spi, struct spi_message *message)</span><br><span class="line"></span><br><span class="line">SPI 异步传</span><br><span class="line">输函数为 spi_async，函数原型如下：</span><br><span class="line">int spi_async(struct spi_device *spi, struct spi_message *message)</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>wifi驱动了解</title>
    <url>/Linux-Lover/ifi%E9%A9%B1%E5%8A%A8%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>支持 USB 和 SDIO 这两种接口的 WIFI。</p>
<p>SDIO 接口的 WIFI 使用芯片为 RTL8189FS<br>RTL8188 USB WIFI</p>
<p>在编译 RTL8188 和 RTL8189 驱动之前需要先配置 Linux 内核。参考正点原子</p>
<p>1 、配置 USB 设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; &lt;*&gt; USB support</span><br><span class="line">    -&gt; &lt;*&gt; Support for Host-side USB</span><br><span class="line">      -&gt; &lt;*&gt; EHCI HCD (USB 2.0) support</span><br><span class="line">      -&gt; &lt;*&gt; OHCI HCD (USB 1.1) support</span><br><span class="line">       -&gt; &lt;*&gt; ChipIdea Highspeed Dual Role Controller</span><br><span class="line">        -&gt; [*] ChipIdea device controller</span><br><span class="line">        -&gt; [*] ChipIdea host controller</span><br></pre></td></tr></table></figure>
<p>配置支持 WIFI 设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; [*] Network device support</span><br><span class="line">    -&gt; [*] Wireless LAN</span><br><span class="line">      -&gt; &lt;*&gt; IEEE 802.11 for Host AP (Prism2&#x2F;2.5&#x2F;3 and WEP&#x2F;TKIP&#x2F;CCMP)</span><br><span class="line">        -&gt; [*] Support downloading firmware images with Host AP driver</span><br><span class="line">        -&gt; [*] Support for non-volatile firmware download</span><br><span class="line"></span><br><span class="line">-&gt; Networking support</span><br><span class="line">  -&gt; -*- Wireless</span><br><span class="line">    -&gt; [*] cfg80211 wireless extensions compatibility</span><br><span class="line">    -&gt; &lt;*&gt; Generic IEEE 802.11 Networking Stack (mac80211)</span><br></pre></td></tr></table></figure>
<p>make编译后<br>驱动编译为模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; Network device support (NETDEVICES [&#x3D;y])</span><br><span class="line">    -&gt; Wireless LAN (WLAN [&#x3D;y])</span><br><span class="line">    -&gt; Realtek wifi (REALTEK_WIFI [&#x3D;m])</span><br><span class="line">      -&gt; rtl8189ftv sdio wifi</span><br><span class="line">      -&gt; rtl8188eus usb wifi</span><br><span class="line">      -&gt; Realtek 8192C USB WiFi</span><br></pre></td></tr></table></figure>

<p>make modules -j12 //编译驱动模块</p>
<p>8188eu.ko、8189fs.ko 和 8192cu.ko 就是我们需要的 RTL8188EUS、<br>RTL8189FS 和 RTL8188CUS/8192CU 的 驱 动 模 块 文 件 ，移rootfs/lib/modules/4.1.15 目录中。</p>
<p>RTL8188 USB WIFI 测试</p>
<p>depmod //第一次加载驱动的时候需要运行此命令<br>modprobe 8188eu.ko  //RTL8188EUS 模块加载 8188eu.ko 模块</p>
<p>ifconfig -a  //查看“wlan0”的网卡</p>
<p>但是WIFI 要想联网，需要移植一些其他第三方组件!!!!</p>
<p><strong>wireless tools  移植</strong></p>
<p>wireless tools 是操作 WIFI 的工具集合，包括一下工具：</p>
<p>①、iwconfig：设置无线网络相关参数。<br>②、iwlist：扫描当前无线网络信息，获取 WIFI 热点。<br>③、iwspy：获取每个节点链接的质量。<br>④、iwpriv：操作 WirelessExtensions 特定驱动。<br>⑤、ifrename：基于各种静态标准命名接口。<br>modprobe 8188eu.ko  //加载 RTL8188 驱动模块</p>
<p>ifconfig wlan0 up //打开 wlan0 网卡</p>
<p>wlan0 网卡打开以后就可以使用 iwlist 命令查找当前环境下的 WIFI 热点信息，也就是无线<br>路由器，输入如下命令：</p>
<p>iwlist wlan0 scan</p>
<p><strong>wpa_supplicant 移植</strong></p>
<p>1、wpa_supplicant 移植 依赖于 openssl<br>openssl-1.1.1d.tar.gz，新建openssl文件夹<br> ./Configure linux-armv4 shared no-asm –prefix=/home/ming/linux/tool/openssl CROSS_COMPILE=arm-linux-gnueabihf-</p>
<p>将 lib 目录下的 libcrypto 和 libssl 库拷贝到开发<br>板根文件系统中的/usr/lib 目录</p>
<p>cp libcrypto.so* /home/ming/linux/nfs/rootfs/usr/lib/ -af<br>cp libssl.so* /home/ming/linux/nfs/rootfs/usr/lib/ -af</p>
<p>2、wpa_supplicant 移植 依赖 libnl  库移植</p>
<p>sudo apt-get install bison<br>sudo apt-get install flex</p>
<p>./configure –host=arm-linux-gnueabihf –prefix=/home/ming/linux/tool/libnl/</p>
<p>3、<br>CC = arm-linux-gnueabihf-gcc</p>
<p>#openssl 库和头文件路径</p>
<p>CFLAGS += -I/home/ming/linux/tool/openssl/include<br>LIBS += -L/home/ming/linux/tool/openssl/lib -lssl<br>    -lcrypto</p>
<p>#libnl 库和头文件路径<br>CFLAGS += -I/home/ming/linux/tool/libnl/include/libnl3<br>LIBS += -L/home/ming/linux/tool/libnl/lib</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核自带HOST与USBOTG</title>
    <url>/Linux-Lover/inux%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6HOST/</url>
    <content><![CDATA[<p>USB<br>Generic HID driver  //使能通用 HID 驱动<br>USB HID transport layer //USB 键盘鼠标等 HID 设备驱动</p>
<p>鼠标<br>等价使用“USB HIDBP Keyboard (simple Boot) support”和“USB HIDBP Mouse<br>(simple Boot) support”这两个配置项<br>hexdump  /dev/input/event3</p>
<p>键盘<br>vi /etc/inittab<br>tty1::askfirst:-/bin/sh</p>
<p>U盘 FAT32 格式的<br>SCSI 协议<br>SCSI disk support //选中此选项<br>USB Mass Storage support //USB 大容量存储设备</p>
<p>mkdir /mnt/usb_disk -p //创建目录<br>mount /dev/sda1 /mnt/usb_disk/ -t vfat -o iocharset=utf8  //挂载</p>
<p>操作完成后拔出前<br>sync //同步<br>umount /mnt/usb_disk //卸载</p>
<p> USB OTG</p>
<p> OTG  从机U盘实验<br> 内核<br>drivers/usb/gadget/libcomposite.ko<br>drivers/usb/gadget/function/usb_f_mass_storage.ko<br>drivers/usb/gadget/legacy/g_mass_storage.ko<br>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：<br>cd drivers/usb/gadget/  //进入 gadget 目录下<br>sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp function/usb_f_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp legacy/g_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/</p>
<p>USB 声卡实验</p>
<p>ALPHA 开发板板载了音频解码芯片，因此可以将 ALPHA 开发板作为一个外置USB 声卡<br> drivers/usb/gadget/libcomposite.ko<br>drivers/usb/gadget/function/usb_f_uac1.ko<br>drivers/usb/gadget/legacy/g_audio.ko</p>
<p>将上述三个.ko 模块拷贝到开发板根文件系统中，命令如下：</p>
<p>cd drivers/usb/gadget/<br>sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp function/usb_f_uac1.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/<br>sudo cp legacy/g_audio.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>USB</title>
    <url>/Linux-Lover/SB/</url>
    <content><![CDATA[<p><strong>USB</strong></p>
<p>注意：USB 和 CAN 共用一个专用的 存储器用于数据的发送和接收。（不能同时使用）。<br>USB模块对同步传输和高吞吐量的批量传输提供了特殊的双缓冲区机制，在微控制器使用一个<br>缓冲区的时候，该机制保证了USB外设总是可以使用另一个缓冲区。</p>
<p>在任何不需要使用USB模块的时候，通过写控制寄存器总可以使USB模块置于低功耗模式<br>(SUSPEND模式)。可以在低功耗模式下唤醒USB模块。也可以将一特定的中断<br>输入源直接连接到唤醒引脚上。<br>高功耗设备 ： 总耗电不超过 总耗电不超过 2.5mA。 。<br>低功耗设备 ： 总耗电不超过 总耗电不超过 500uA</p>
<p>:Full-Speed 和 High-Speed，也就是全速(FS)和高速(HS)。U<br>Mbps是一种传输速率单位，指每秒传输的位（比特）数量，USB2.0中<br>FS 的速度为 12Mbps，USB2.0<br>HS 速度为 480Mbps。<br>USB1.0，理论速度为 1.5Mbps<br>最大的有效数据长度:<br>  低速设备: 8 字节 字节<br>  全速设备: 8, 16, 32, 64 字节 字节<br>  高速设备: 64 字节</p>
<p> PHY指物理层，OSI的最底层。 一般指与外部信号接口的芯片。</p>
<p>USB Host是指驱动过后，板子就可以连接USB接口连接的器件，读取和装载数据了。<br>USB Device是指驱动过后，板子可以当做一个USB移动设备，通过USB连接到电脑上，类似U盘<br>OTG是增加了host、device协商机制的usb口。<br>USB接口<br>A类扁平接口<br>B类　方形的梯形接口<br>MINI USB<br>( Mini USB 插头相比 USB A 插头多了一个 ID 线，这个 ID 线用于实现 OTG 功能，通过 ID 线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。)<br>Mirco USB<br>USB  拓扑结构（USB 集线器也叫做 USB HUB）</p>
<p> USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB<br>设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、<br>配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个<br>特定的端点。</p>
<p> <strong>USB OTG</strong></p>
<p>USB技术的发展，使得PC和周边设备能够通过简单方式、适度的制造成本将各种设备连接在一起，上述我们提到应用，都可以通过USB总线，作为PC的周边，在PC的控制下进行数据交换。但这种方便的交换方式，一旦离开了PC，各设备间无法利用USB口进行操作，因为没有一个设备能够充当PC一样的Host。<br>On-The-Go，即OTG技术就是实现在没有Host的情况下，实现设备间的数据传送。<br> 第五根线ID<br>ID=1 ：OTG 设备工作在从机模式。<br>ID=0：OTG 设备工作在主机模式。</p>
<p> HUB 芯片，支持一拖四扩展,使用 GL850G 扩展出来的 4 路 USB 接口只能用作 HOST！</p>
<p> <strong>USB 设备常用描述符</strong></p>
<p>Device Descriptor  设备描述符  1<br>Configuration Descriptor  配置描述符  2<br>String Descriptor  字符串描述符  3<br>Interface Descriptor  接口字符串  4<br>Endpoint Descriptor  端点描述符  5</p>
<p><strong>设备描述符用于描述 USB</strong></p>
<img src="/Linux-Lover/SB/1.JPG" class="">

<img src="/Linux-Lover/SB/2.JPG" class="">

<img src="/Linux-Lover/SB/3.JPG" class="">

<img src="/Linux-Lover/SB/4.JPG" class="">

<img src="/Linux-Lover/SB/5.JPG" class="">



<p> <strong>USB数据包</strong></p>
<p>USB 是串行通信，需要一位一位的去传输数据， USB 传输的时候先将原始数据进行打包，USB 中传输的基本单元就是数据包。<br>这四种包通过包标识<br>符 PID 来区分，PID 共有 8 位，USB 协议使用低 4 位 PID3<del>PID0。令牌包的 PID1</del>0 为 01，数<br>据包的 PID1<del>0 为 11，握手包的 PID1</del>0 为 10，特殊包的 PID1~0 为 00。</p>
 <img src="/Linux-Lover/SB/6.JPG" class="">

<p> <strong>USB传输</strong></p>
<p> 1、控制传输<br> 2、同步传输<br> 3、批量传输<br> 4 、中断传输</p>
<p><strong>USB枚举</strong></p>
<p>当 USB 设备与 USB 主机连接以后主机就会对 USB 设备进行枚举，通过枚举来获取设备的<br>描述符信息。<br>①、第一回合，当 USB 主机检测到 USB 设备插入以后机会发出总线复位信号来复位设备。<br>USB 设备复位完成以后地址为 0，主机向地址 0 的端点 0 发送数据，请求设备的描述符。设备<br>得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描<br>述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。<br>//复位</p>
<p>②、第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0 的端点 0 发送设置<br>地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过<br>程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0 字节状态数据包，表明设备<br>已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到<br>主机发送的 ACK 包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。<br>//设地址</p>
<p>③、第三回合，主机向新的设备地址端点 0 发送请求设备描述符数据包，这一次主机要获<br>取整个设备描述符，一共是 18 个字节。<br>//发数据</p>
<p>④、和第③步类似，接下来依次获取配置描述符、配置集合、字符串描述符等等。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Linux消息队列</title>
    <url>/Linux-Lover/%E4%BA%86%E8%A7%A3Linux%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>消息队列</strong></p>
<p>    消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法<br>    每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值<br>    消息队列也有管道一样的不足，就是每个消息的最大长度是有上限的（MSGMAX），每个消息队列的总的字节数是有上限的（MSGMNB），系统上消息队列的总数也有一个上限（MSGMNI）</p>
<pre><code>cat /proc/sys/kernel/msgmax 最大消息长度 限制
cat /proc/sys/kernel/msgmnb 消息队列总的字节数
cat /proc/sys/kernel/msgmni 消息条目数</code></pre><p>IPC Inter-Process Communication，进程间通信</p>
<img src="/Linux-Lover/%E4%BA%86%E8%A7%A3Linux%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1.JPG" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列函数 </span><br><span class="line">	#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">	int msgget(key_t key, int msgflg);&#x2F;&#x2F;用来创建和访问一个消息队列</span><br><span class="line">	int msgctl(int msqid, int cmd, struct msqid_ds *buf);&#x2F;&#x2F;消息队列的控制函数</span><br><span class="line">	int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);&#x2F;&#x2F;发送</span><br><span class="line">	ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);&#x2F;&#x2F;接受</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程间通讯</title>
    <url>/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p><strong>进程互斥</strong></p>
<p>由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥<br>系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源。<br>在进程中涉及到互斥资源的程序段叫临界区</p>
<p><strong>进程同步</strong></p>
<p>进程同步指的是多个进程需要相互配合共同完成一项任务。</p>
<p><strong>进程间通信目的</strong></p>
<p>1、数据传输：一个进程需要将它的数据发送给另一个进程<br>2、资源共享：多个进程之间共享同样的资源。<br>3、通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。<br>4、进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<p>进程间通信分类<br>    文件<br>    文件锁<br>    管道（pipe）和有名管道（FIFO）<br>    信号（signal）<br>    消息队列<br>    共享内存<br>    信号量<br>    互斥量<br>    条件变量<br>    读写锁<br>    套接字（socket）</p>
<img src="/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/1.JPG" class="">


<p><strong>共享内存</strong></p>
<p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。</p>
<img src="/Linux-Lover/inux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/2.jpg" class="">






]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Linux管道</title>
    <url>/Linux-Lover/%E8%A7%A3Linux%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p>从一个进程连接到另一个进程的一个数据流称为一个“管道”。<br>管道的本质====》固定大小的内核缓冲区。</p>
<p>管道限制：<br>1、半双工，需要两个管道<br>2、只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信。<br> ls | wc -w // 统计当前目录下文件个数</p>
<p><strong>匿名管道</strong></p>
<p>int pipe(int pipefd[2]);<br>fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端。</p>
<img src="/Linux-Lover/%E8%A7%A3Linux%E7%AE%A1%E9%81%93/1.JPG" class="">


<p><strong>管道一些常见规则</strong></p>
<p>当没有数据可读时<br>read调用阻塞，即进程暂停执行，一直等到有数据来到为止。<br>当管道满的时候<br>调用返回-1，errno值为EAGAIN<br> cat /usr/include/linux/limits.h<br>#define PIPE_BUF        4096<br>如果所有管道写端对应的文件描述符被关闭，则read返回0<br>如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE<br>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。<br>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。</p>
<p><strong>有名管道（FIFO管道）</strong></p>
<p>匿名管道应用的一个限制就是只能在具有共同祖先（具有亲缘关系）的进程间通信。<br>如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为命名管道。命名管道是一种特殊类型的文件。</p>
<p>匿名管道与命名管道PK<br>匿名管道由pipe函数创建并打开。<br>命名管道由mkfifo函数创建，打开用open<br>FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的方式<br>同，一但这些工作完成之后，它们具有相同的语义。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/Linux-Lover/%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p><strong>内网</strong></p>
<p>NAT的最典型应用是：在一个局域网内，只需要一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。<br>内网是可以上网的，内网需要一台服务器或路由器做网关,通过它来上网。</p>
<p><strong>内网穿透</strong></p>
<p>即NAT穿透，采用端口映射，让外网的电脑找到处于内网的电脑，同时也可基于 HTTP/2实现web内网穿透。<br>方法：在局域网内部的任一PC或服务器上运行到花生壳内网穿透客户端，此时域名解析到的IP地址是局域网网关出口处的公网IP地址，再在网关处做端口映射指向监控设备即可。</p>
<p>源IP + 源端口–&gt;路由器-&gt;目的IP + 目的端口</p>
<p>有NAT转化映射表,这样做目的。<br>1、保护局域网<br>2、节省IP</p>
<p>内网穿透方法：<br>1、设置路由器</p>
<p>2、借用软件：花生壳<br><a href="https://www.oray.com/" target="_blank" rel="noopener">https://www.oray.com/</a><br>添加映射，自动生成域名。<br>6元买1年送98年，实惠QAQ!!!</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>了解摄像头和声卡</title>
    <url>/Linux-Lover/%E4%BA%86%E8%A7%A3%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1/</url>
    <content><![CDATA[<p><strong>摄像头</strong></p>
<p>常见接口：usb、cmos</p>
<p>主要参数：分辨率（像素点数）、格式、帧率(1s拍几张图)</p>
<p>API接口：V4l2</p>
<img src="/Linux-Lover/%E4%BA%86%E8%A7%A3%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%A3%B0%E5%8D%A1/1.JPG" class="">


<p><strong>声卡</strong></p>
<p>采样频率、采样位宽。<br>声道个数（ADC采集个数）</p>
<p>API接口：ALSA (复杂)<br>—-&gt;alsa-lib编写APP<br>参考：<a href="http://www.equalarea.com/paul/alsa-audio.html" target="_blank" rel="noopener">代码</a></p>
<p>buildroot 配置 alsa-utils </p>
<p>Target packages<br>-&gt; Audio and video applications<br>-&gt; alsa-utils  此目录下的软件全部选中</p>
<p>只录制声音<br>开发板：ffmpeg -f alsa -ac 1 -i hw:0,0 my.wav<br>//第0个声卡第0个模块，通道一，保存格式.wav<br>播放：  aplay my.wav</p>
<p>只推送声音：</p>
<p>ffmpeg -f alsa -ac 1 11025 -i hw:0,0 -acodec aac -f flv rtmp://127.0.0.1/live/ming</p>
<p>推送视频和声音：<br>ffmpeg -f alsa -ac 1 -ar 11025 -i hw:0,0 -acodec aac -f v4l2 -framerate 10 -i /dev/video1 -q 10 -f flv rtmp://127.0.0.1/live/ming</p>
<p>拉流http flv协议<br><a href="http://192.168.0.50/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://192.168.0.50/test?app=live&amp;stream=ming</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习方案二</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/</url>
    <content><![CDATA[<p><strong>数据的认识</strong></p>
<p>mp4指的是音频视频封装格式。</p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/1.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/2.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/3.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/4.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/5.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/6.JPG" class="">

<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/ffmeg%E5%8F%82%E6%95%B0.JPG" class="">

<p><strong>ffmpeg</strong></p>
<p>buildroot 下载 ffmpeg</p>
<p>根文件文件目录输入命令<br>摄像头读取数据转化为MP4格式。<br>ffmpeg -f v412 -framerate 10 -i /dev/video -q 10 my.mp4</p>
<p>注：有windows版的ffmpeg可以用来实验学习。</p>
<p><strong>ngnix</strong></p>
<p>新建目录/dl/nginx，加载模块</p>
<p>git clone <a href="https://github.com/winshining/nginx-http-flv-module.git">https://github.com/winshining/nginx-http-flv-module.git</a></p>
<p>buildroot 配置nginx,添加第三模块路径。</p>
 

<p> 注意：流媒体服务器一个就够了，lighthttp要关掉。</p>
 

<p> $(TOPDIR)/dl/nginx/nginx-http-flv-module</p>
<p> nginx version: nginx/1.16.1<br> vi /etc/nginx/ngixn.conf<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #user  nobody;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp&#123;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">  application live&#123;</span><br><span class="line">        allow publish 127.0.0.1;</span><br><span class="line">        allow play all;</span><br><span class="line">        live on ;</span><br><span class="line">        record off;</span><br><span class="line">        meta copy;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">       location  &#x2F;test&#123;</span><br><span class="line">           flv_live on;</span><br><span class="line">           chunked_transfer_encoding on; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">     #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">  #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">  #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 修改后重启<br> /etc/init.d/S50nginx  restart</p>
<p> 在线摄像头推流</p>
<p>ffmpeg -f v4l2 -framerate 10 -i /dev/video1 -q 10 -f flv rtmp://127.0.0.1/live/ming<br>//1 秒10帧，质量10</p>
<p> 下载播放器<br> <a href="https://www.videolan.org/" target="_blank" rel="noopener">https://www.videolan.org/</a></p>
<p> 播放器在线拉流：</p>
<p> 1、rtmp协议 (延时太大)—imx6ull性能差<br> rtmp://192.168.0.50/live/ming</p>
<p> 2、http flv协议<br> <a href="http://192.168.0.50/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://192.168.0.50/test?app=live&amp;stream=ming</a></p>
<p> <a href="http://31z6571r71.zicp.vip/test?app=live&amp;stream=ming" target="_blank" rel="noopener">http://31z6571r71.zicp.vip/test?app=live&amp;stream=ming</a></p>
<p>推送mp4文件（绝对路径）<br>ffmpeg -re -i ./test.mp4 -vcodec copy -acodec copy -f flv rtmp://127.0.0.1/live/ming</p>
<p>安装插件 flv.js<br>在线： <a href="http://player.pingos.io/flv/" target="_blank" rel="noopener">http://player.pingos.io/flv/</a></p>
<p>自定义<br>参考：<a href="https://www.cnblogs.com/saysmy/p/7851911.html" target="_blank" rel="noopener">https://www.cnblogs.com/saysmy/p/7851911.html</a><br>参考：<a href="https://blog.csdn.net/string_kai/article/details/100598268" target="_blank" rel="noopener">https://blog.csdn.net/string_kai/article/details/100598268</a></p>
<p>原理：<br>ngnix把flv流传给flv.js插件，转换为html语言，我们就可以用浏览器访问。<br>妙！QAQ</p>
<p>my.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; http-equiv&#x3D;&quot;Content-Type&quot;&gt;</span><br><span class="line">    &lt;title&gt;flv.js demo&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .mainContainer &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 1024px;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .urlInput &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-top: 8px;</span><br><span class="line">            margin-bottom: 8px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .centeredVideo &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 576px;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-bottom: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .controls &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            text-align: left;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">            margin-top: 8px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .logcatBox &#123;</span><br><span class="line">            border-color: #CCCCCC;</span><br><span class="line">            font-size: 11px;</span><br><span class="line">            font-family: Menlo, Consolas, monospace;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            text-align: left;</span><br><span class="line">            margin-left: auto;</span><br><span class="line">            margin-right: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class&#x3D;&quot;mainContainer&quot;&gt;</span><br><span class="line">        &lt;video name&#x3D;&quot;videoElement&quot; class&#x3D;&quot;centeredVideo&quot; id&#x3D;&quot;videoElement&quot; controls width&#x3D;&quot;1024&quot; height&#x3D;&quot;576&quot; autoplay&gt;</span><br><span class="line">            Your browser is too old which doesn&#39;t support HTML5 video.</span><br><span class="line">        &lt;&#x2F;video&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;flv.js&#x2F;1.5.0&#x2F;flv.js&quot;&gt;&lt;&#x2F;script&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         if (flvjs.isSupported()) &#123;</span><br><span class="line">            startVideo()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function startVideo()&#123;</span><br><span class="line">            var videoElement &#x3D; document.getElementById(&#39;videoElement&#39;);</span><br><span class="line">            var flvPlayer &#x3D; flvjs.createPlayer(&#123;</span><br><span class="line">                type: &#39;flv&#39;,</span><br><span class="line">                isLive: true,</span><br><span class="line">                hasAudio: true,</span><br><span class="line">                hasVideo: true,</span><br><span class="line">                enableStashBuffer: true,</span><br><span class="line">                url: &#39; http:&#x2F;&#x2F;192.168.0.50&#x2F;test?app&#x3D;live&amp;stream&#x3D;ming&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">            flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">            flvPlayer.load();</span><br><span class="line">            flvPlayer.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        videoElement.addEventListener(&#39;click&#39;, function()&#123;</span><br><span class="line">            alert( &#39;是否支持点播视频：&#39; + flvjs.getFeatureList().mseFlvPlayback + &#39; 是否支持httpflv直播流：&#39; + flvjs.getFeatureList().mseLiveFlvPlayback )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        function destoryVideo()&#123;</span><br><span class="line">            flvPlayer.pause();</span><br><span class="line">            flvPlayer.unload();</span><br><span class="line">            flvPlayer.detachMediaElement();</span><br><span class="line">            flvPlayer.destroy();</span><br><span class="line">            flvPlayer &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function reloadVideo()&#123;</span><br><span class="line">            destoryVideo()</span><br><span class="line">            startVideo()</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%BA%8C/9.JPG" class="">

<p>放在ARM板子上，nginx 192.168.0.50访问<br>cd /usr/html</p>
<blockquote>
<p>index.html //清空</p>
</blockquote>
<p>index.html -&gt;my.html</p>
<p>成功了！（没推送不能看哦O v O）</p>
<p>👉👉<a href="http://31z6571r71.zicp.vip/test?app=live&stream=ming" target="_blank" rel="noopener">点击此处链接观看视频链接</a></p>
<p>👉👉<a href="/my.html">点击此处博客观看视频链接</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习方案一</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E4%B8%80/</url>
    <content><![CDATA[<p>JPEG(简称JPG，小，静态图片)</p>
<p>MJPG(动态的视频编码格式，大，近似多个JPEG的组合)<br>传递完整的两个帧格式，所以处理器性能要求不高。</p>
<p>buildroot 安装mjpg-streamer</p>
<p>根目录运行命令</p>
<p>在线传输<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_uvc.so -d /dev/video0 -f 30 -q 90 -n” -o “/usr/lib/mjpg-streamer/output_http.so -w /usr/share/mjpg-streamer/www”</p>
<p>存储在tmp文件<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_uvc.so -d /dev/video0 -f 30 -q 90 -n” -o “/usr/lib/mjpg-streamer/output_file.so -f /tmp”</p>
<p>推送tmp文件里的<br>mjpg_streamer -i “/usr/lib/mjpg-streamer/input_file.so -e -f /tmp” -o “/usr/lib/mjpg-streamer/output_http.so -w /usr/share/mjpg-streamer/www”</p>
<p><a href="http://192.168.0.50:8080/" target="_blank" rel="noopener">http://192.168.0.50:8080/</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>视频监控项目学习</title>
    <url>/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>不错的网站：<a href="https://www.te.com.cn/" target="_blank" rel="noopener">https://www.te.com.cn/</a><br>达尔闻<a href="https://course.darwinlearns.com/detail/v_5e9e57c0c81f5_w4Ey3mm9/3" target="_blank" rel="noopener">https://course.darwinlearns.com/detail/v_5e9e57c0c81f5_w4Ey3mm9/3</a></p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/1.JPG" class="">

<p><strong>方案一：</strong></p>
<p>mjpg-streamer 运行在开发板，手机浏览器直接看。ARM性能要求不高。<br>缺点：<br>1、要实现内网穿透。<br>2、一款免费基于IP地址的视频流服务,声音不能传，不维护，只做学习。</p>
<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/2.JPG" class="">

<p><strong>方案二:</strong><br>流媒体方案（一边下载一边观看）<br>互联网 -服务器-推送拉取— 》涉及流媒体协议</p>


<img src="/Linux-Lover/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/4.JPG" class="" title="特点区别">


<p>选择开源软件方案：</p>
<p>推流段：ffmpeg<br>（rtmp协议）<br>流媒体服务器：nginx<br>(http flv协议)<br>拉流端：浏览器/播放器</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux CAN</title>
    <url>/Linux-Lover/Linux-CAN/</url>
    <content><![CDATA[<p><strong>CAN总线</strong></p>
<p>CAN 的全称为 Controller Area Network，也就是控制局域网络，简称为 CAN。</p>
<p>CAN 的特点主要有一下几点：<br>①、多主控制<br>在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元同时开始发送消<br>息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而<br>是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个<br>位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的<br>单元则立刻停止发送而进行接收工作。</p>
<p>③、通信速度快，距离远<br>最高 1Mbps（距离小于 40M），最远可达 10KM（速率低于 5Kbps）。<br>④、具有错误检测、错误通知和错误恢复功能</p>
<p>⑥、连接节点多</p>
<p>CAN 总线使用两根线来连接各个单元：CAN_H 和 CAN_L.</p>
<p>显性电平表示逻<br>辑“0”，此时 CAN_H 电平比 CAN_L 高，分别为 3.5V 和 1.5V，电位差为 2V。隐形电平表示<br>逻辑“1”，此时 CAN_H 和 CAN_L 电压都为 2.5V 左右，电位差为 0V。</p>
<p><strong>CAN协议</strong></p>
<p>CAN 协议提供了 5 种帧格式来传输<br>数据：数据帧、遥控帧、错误帧、过载帧和帧间隔。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-IIC</title>
    <url>/Linux-Lover/nux-IIC/</url>
    <content><![CDATA[<p><strong>IIC 总线</strong></p>
<p>内核也将 I2C 驱动分为两部分：<br>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c_adapter&#x2F;* I2C 适配器(控制器)抽象*&#x2F;</span><br><span class="line">  -&gt;i2c_algorithm&#x2F;*  总线访问算法 *&#x2F;</span><br><span class="line">		-&gt;master_xfer&#x2F;* I2C 适配器的传输函数*&#x2F;</span><br><span class="line"></span><br><span class="line">两个函数向系统注册设置好</span><br><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">int i2c_add_numbered_adapter(struct i2c_adapter *adap)</span><br><span class="line"></span><br><span class="line">删除 I2C 适配器的话使用 i2c_del_adapter 函数即可，函数原型如下：</span><br><span class="line">void i2c_del_adapter(struct i2c_adapter * adap)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用 i2c_imx_start 函数开启 I2C 通信。</span><br><span class="line">如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数。</span><br><span class="line">向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来</span><br><span class="line">完成写数据。</span><br><span class="line">如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。</span><br><span class="line">I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap,</span><br><span class="line">struct i2c_msg *msgs,</span><br><span class="line">int num</span><br></pre></td></tr></table></figure>


<p>ls /sys/bus/i2c/devices</p>
<p>cd /sys/bus/i2c/devices</p>
<p>cat 0-001e/name //查看设备名字</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>RGB4.3寸触摸屏800*400</title>
    <url>/Linux-Lover/3%E5%AF%B8%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
    <content><![CDATA[<p>掌握 linux 下的触摸屏上报时序，大多数都是 Type B 类型</p>
<p>input_mt_init_slots  函数<br>input_mt_init_slots(gt9147.input, MAX_SUPPORT_POINTS, 0); //多少点数</p>
<p>input_mt_slot  函数<br>input_mt_slot(dev-&gt;input, id);</p>
<p>input_mt_report_slot_state 函数</p>
<p>函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE<br>事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，<br>ABS_MT_TOOL_TYPE 事件指定触摸类型（是笔还是手指等）。</p>
<p> input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、<br>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。</p>
<p>input_report_abs 函数<br> input_report_abs(dev-&gt;input, ABS_MT_POSITION_X, input_x);<br> input_report_abs(dev-&gt;input, ABS_MT_POSITION_Y, input_y);</p>
<p>input_mt_report_pointer_emulation 函数</p>
<p>input_mt_report_pointer_emulation(dev-&gt;input, true);</p>
<p>1、驱动文件<br>2、修改设备树</p>
<p>ls /dev/input</p>
<p>cat /dev/interrput  看中断触发次数</p>
<p>配置 tslib<br>打开/etc/ts.conf 文件，找到下面这一行：<br>module_raw input<br>如果上面这句前面有“#”的话就删除掉“#”。<br>打开/etc/profile 文件，在里面加入如下内容：<br>示例代码 64.5.1.1 /etc/profile 文件添加的内容<br>export TSLIB_TSDEVICE=/dev/input/event1 (不同设备可能不同)<br>export TSLIB_CALIBFILE=/etc/pointercal<br>export TSLIB_CONFFILE=/etc/ts.conf<br>export TSLIB_PLUGINDIR=/lib/ts<br>export TSLIB_CONSOLEDEVICE=none<br>export TSLIB_FBDEVICE=/dev/fb0</p>
<p>source /etc/profile<br>ts_calibrate<br>根文件目录输出：<br>input: gt9147 as /devices/platform/soc/2100000.aips-bus/21a4000.i2c/i2c-1/1-0014/input/input3</p>
<p>这是单点触摸的上报函数：<br>input_report_abs(ts-&gt;input_dev, ABS_X, x);<br>input_report_abs(ts-&gt;input_dev, ABS_Y, y);<br>input_report_abs(ts-&gt;input_dev, ABS_PRESSURE, 1);<br>input_sync(ts-&gt;input_dev);<br>这是多点触摸的上报函数：<br>input_report_abs(ts-&gt;input_dev, ABS_MT_POSITION_X, x);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_POSITION_Y, y);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_TOUCH_MAJOR, w);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_WIDTH_MAJOR, w);<br>input_report_abs(ts-&gt;input_dev, ABS_MT_TRACKING_ID, id);<br>input_mt_sync(ts-&gt;input_dev);</p>
<p><strong>血的教训</strong></p>
<p>在本实验中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而不是前面编译<br>为模块对应的 event2，这一点一定要注意！</p>
<p>qt环境变量设置：</p>
<p>arm-stlib环境变量设置：</p>
<p>hexdump触摸小计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x2f，为 ABS_MT_SLOT，value&#x3D;0，上报的是第一个触摸点坐标。</span><br><span class="line"> type 为 0x3 ，  一 个 EV_ABS 事 件 ， code 为 0x39 ，是ABS_MT_TRACKING_ID ，value&#x3D;5 说明给 SLOT0 分配的 ID 为 5</span><br><span class="line"></span><br><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x35，为 ABS_MT_POSITION_X，value&#x3D;0x03ec&#x3D;1004，说明触摸点 X 轴坐标为 1004，属于屏幕右上角区域。</span><br><span class="line">type 为 0x3，一个 EV_ABS 事件，code 为 0x36，为 ABS_MT_POSITION_Y，是触摸点的 Y 轴坐标。value&#x3D;0x17&#x3D;23，说明 Y 轴坐标为 23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</span><br><span class="line"></span><br><span class="line">type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x1 表</span><br><span class="line">示触摸屏被按下。</span><br><span class="line">type 为 0x0，是一个 EV_SYN 事件，由 input_sync 函数上报。type为0x3，是一个EV_ABS事件，code为0x39，也就是ABS_MT_TRACKING_ID，</span><br><span class="line">value&#x3D;0xffffffff&#x3D;-1，说明触摸点离开了屏幕。</span><br><span class="line">第 10 行，type 为 0x1，是一个 EV_KEY 事件，code&#x3D;0x14a，为 BTN_TOUCH，value&#x3D;0x0</span><br><span class="line">表示手指离开触摸屏，也就是触摸屏没有被按下了</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC驱动了解🏃</title>
    <url>/Linux-Lover/RTC%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>RTC 设备驱动是一个标准的字符设备驱动</p>
<p> rtc_device 结构体</p>
<p> rtc_class_ops 结构体</p>
<p>rtc_dev_ioctl() 函数就会执行，操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。</p>
<p>snvs_rtc_ops 操作集</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct rtc_device *rtc_device_register(const char *name,</span><br><span class="line">                  struct device *dev,</span><br><span class="line">                  const struct rtc_class_ops *ops,</span><br><span class="line">                  struct module *owner)</span><br><span class="line">                  </span><br><span class="line">struct rtc_device *rtc_device_register(const char *name,</span><br><span class="line">                      struct device *dev,</span><br><span class="line">                      const struct rtc_class_ops *ops,</span><br><span class="line">                      struct module *owner)</span><br></pre></td></tr></table></figure>
<p> platform_get_resource 函数从设备树中获取到 RTC 外设寄存器基地址</p>
<p> 函数 devm_ioremap_resource 完成内存映射，得到 RTC 外设寄存器物理基<br>地址对应的虚拟地址。</p>
<p>snvs-rtc.c 文件会采用 regmap 机制来读写RTC 底层硬件寄存器。<br>这里使用 devm_regmap_init_mmio 函数将 RTC 的硬件寄存器转化为regmap 形式，这样 regmap 机制的 regmap_write、regmap_read 等 API 函数才能操作寄存器。<br>devm_rtc_device_register 函数向系统注册 rtc_devcie</p>
<p>调用 rtc_read_lp_counter 获取 RTC 计数值，这个时间值是秒数</p>
<p>调用 rtc_time_to_tm 函数将获取到的秒数转换为时间值</p>
<p> rtc_read_lp_counter 函数，此函数用于读取 RTC 计数值</p>
<p>测试</p>
<p>设置当前时间为 2019 年 8 月 31 日 18:13:00<br>date -s “2019-08-31 18:13:00”</p>
<p>此时间还没有写入到I.MX6U 内部 RTC 里面或其他的 RTC 芯片里面<br>hwclock -w  //将当前系统时间写入到 RTC 里面</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Framebuffer驱动</title>
    <url>/Linux-Lover/ramebuffer-%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Framebuffer 抽象为一个叫做 fb_info 的结构体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info</p>
<p>内核内存分配函数<br>函数devm_kzalloc（）和kzalloc（）一样都是内核内存分配函数，但是devm_kzalloc（）是跟设备有关的，自动释放。当内存不在使用时，可以使用函数devm_kfree（）释放。<br>而kzalloc（）则需要手动释放使用kfree（），实现了kmalloc()+memset()的功能</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile报错记录</title>
    <url>/Makefile-Lover/Makefile%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错：</span><br><span class="line">Your display is too small to run Menuconfig!</span><br><span class="line">It must be at least 19 lines by 80 columns.</span><br><span class="line">Makefile:950: recipe for target &#39;menuconfig&#39; failed</span><br><span class="line">make[1]: *** [menuconfig] Error 1</span><br><span class="line">Makefile:84: recipe for target &#39;_all&#39; failed</span><br><span class="line">make: *** [_all] Error 2</span><br><span class="line"></span><br><span class="line">make menuconfig配置内核时出错</span><br><span class="line">Makefile:</span><br><span class="line">解决：</span><br><span class="line">窗口太小的原因，把terminal变大就可以显示。QaQ</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Wall表示显示编译的时候所有警告nostdib表示不链接系统标准启动文件和文件,否则编译可能会出错.-O2表示优等级,和MDK上的设置含义一样</span><br><span class="line"></span><br><span class="line">通过printf： @echo 调试变量值。</span><br></pre></td></tr></table></figure>

<img src="/Makefile-Lover/Makefile%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/1.jpg" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gcc编译时遇到&quot;inline function &#39;*** declared butnever defined&quot;问题</span><br><span class="line"></span><br><span class="line">解决：-fgnu89-inline</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-march&#x3D;armv7-a -mfpu&#x3D;neon-vfpv4 -mfloat-abi&#x3D;hard   浮点数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;浮点数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>#pragma pack</title>
    <url>/C-C-Lover/ragma-pack/</url>
    <content><![CDATA[<p>#pragma pack(push)保存对齐状态</p>
<p>#pram pack(4)设定4字节</p>
<p>voif func();</p>
<p>#pragma pack(pop)//恢复对齐</p>
<p>注意：from dalao  ！！！</p>
<p>c51 默认按照1字节对其，没有存在字节对齐问题.<br>keil工程编译不报错，语句无效。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断(正旭)</title>
    <url>/Linux-Lover/Linux%E4%B8%AD%E6%96%AD-%E6%AD%A3%E6%97%AD/</url>
    <content><![CDATA[<p>中断</p>
<p>Linux不用FIQ，只用到了IRQ</p>
<p>中断服务有没有参数主要是看中断发生在裸机上还是实时系统中</p>
<p>linux中断流程</p>
<p>Linux不用FIQ，只用到了IRQ</p>
<p>linux的中断处理都是在SVC模式下处理的。</p>
<p>当发生中断的时候，代码运行在内核空间</p>
<p>IRQ执行的时候很快</p>
<p>在IRQ回到SVC模式时候 R0存着irqnumber</p>
<p>在SVC模式的内核栈上保存中断时候正在执行任务的寄存器状态 R1-R12 。 R0保存在IRQ那边的内核栈。</p>
<p>随后会再搬到SVC的内核栈上</p>
<p>总结分为7点：</p>
<p>Linux对中断的扩展：硬件中断，软件中断</p>
<p>中断处理原则1：不能嵌套</p>
<p>中断处理原则2：越快越好</p>
<p>要处理的事情实在太多：拆分为：上半部，下半部</p>
<p>下半部的事情耗时不是太长：tasklet</p>
<p>下半部要做的事情太多并且很复杂：工作队列</p>
<p>新技术：threaded irq</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>交换两个变量的值，不使用第三个变量</title>
    <url>/C-C-Lover/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;</p>
<p>答案：有两种解法, 一种用算术算法, 一种用^(异或) </p>
<p>a = a + b; </p>
<p>b = a - b;</p>
<p> a = a - b;    //溢出问题</p>
<p>or</p>
<p> a = a^b;// 只能对int,char..</p>
<p> b = a^b; </p>
<p>a = a^b;</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt编译报错</title>
    <url>/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>报错make: Nothing to be done for ‘first’</p>
<p>可执行程序已经存在。<br>/usr/bin/ld: main.o：普通ELF重定位（M: 40）<br>make cc 修改</p>
<img src="/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/1.JPG" class="">

<img src="/QT-Lover/Qt%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/2.JPG" class="">


<p>非root用户运行无问题，切换到root用户或者以sudo方式运行出现问题。<br>QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to ‘/tmp/runtime-root’这个好像不影响页面显示</p>
<p>版本兼容问题<br>CONFIG += c++11  //添加标准</p>
<p>linux qt 不支持中文输入<br>/opt/Qt5.5.1/Tools/QtCreator/bin/plugins/platforminputcontexts/libcomposeplatforminputcontextplugin.so </p>
<p>cast from ‘void*’ to ‘int’ loses precision<br>数据类型变小如int long</p>
<p>图标报错<br>RC_ICONS += ming.ico<br><a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a><br>要用专业软件转化格式</p>
<p>字体不显示<br>usr文件夹-&gt;share文件夹-&gt;fronts文件夹-&gt;字体.otf</p>
<p>空指针引起报错，crash down </p>




]]></content>
      <categories>
        <category>QT Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>buildroot根文件 移植qt库</title>
    <url>/Linux-Lover/ildroots/</url>
    <content><![CDATA[<p>buildroot下配置 busybox </p>
<p>sudo make busybox-menuconfig<br>sudo make busybox<br>sudo make<br>两者关系：buildroot用busybox的命令</p>
<p>设置命令路径格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改&#x2F;etc&#x2F;profile 文件</span><br><span class="line">PS1&#x3D;&#39;[\u@\h]:\w$:&#39;</span><br><span class="line">export PS1</span><br><span class="line">设置 PS1 环境变量，格式就是：</span><br><span class="line">[user@hostname]:currentpath$:</span><br></pre></td></tr></table></figure>


<p>运行：<br> ./mytest -platform linuxfb<br> 静态编译全部</p>
<p>两个终端</p>
<p>打开开发板根文件系统中的/etc/inittab 文件，在里面加入下面这一行：<br>tty1::askfirst:-/bin/sh</p>
<p>echo hello ming &gt;/dev/tty1</p>
<p> LCD  自动关闭解决方法</p>
<p>1按键盘唤醒<br>2关闭10分钟熄屏功能<br>drivers/tty/vt/vt.c 这个文件<br>static int blankinterval = 10*60;  //0 则关闭<br>3 编写一个 APP 关闭10分钟熄屏功能</p>
<p>调节亮度<br>cd /sys/devices/platform/backlight/backlight/backligh<br>echo 5 &gt; brightness</p>
<p>eth0：link down？<br>vi /etc/init.d/rcs<br>ifconfig eth0 192.168.0.50<br>ifconfig eth0 up</p>
<p>注意三个文件：<br><code><br>/etc/passwd                存储用户的关键信息<br>/etc/group                存储用户组的关键信息<br>/etc/shadow                存储用户的密码信息<br></code></p>
<p>环境变量配置<br>vim /ect/profile<br>正点原子中将触摸屏驱动添加到 linux 内核里面以后触摸屏对应的是 event1，而驱动编译为模块对应的 event2，这一点一定要注意!!!!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin&quot;</span><br><span class="line"></span><br><span class="line">PS1&#x3D;&#39;[\u@\h]:\w$:&#39;</span><br><span class="line">export PS1</span><br><span class="line"></span><br><span class="line">#if [ &quot;$PS1&quot; ]; then</span><br><span class="line">#       if [ &quot;&#96;id -u&#96;&quot; -eq 0 ]; then</span><br><span class="line">#               export PS1&#x3D;&#39;# &#39;</span><br><span class="line">#       else</span><br><span class="line">#               export PS1&#x3D;&#39;$ &#39;</span><br><span class="line">#       fi</span><br><span class="line">#fi</span><br><span class="line"></span><br><span class="line">export PAGER&#x3D;&#39;&#x2F;bin&#x2F;more&#39;</span><br><span class="line">export EDITOR&#x3D;&#39;&#x2F;bin&#x2F;vi&#39;</span><br><span class="line"></span><br><span class="line">export TSLIB_ROOT&#x3D;&#x2F;arm-tslib</span><br><span class="line">export TSLIB_CONSOLEDEVICE&#x3D;none</span><br><span class="line">export TSLIB_FBDEVICE&#x3D;&#x2F;dev&#x2F;fb0</span><br><span class="line">export TSLIB_TSDEVICE&#x3D;&#x2F;dev&#x2F;input&#x2F;event2</span><br><span class="line">export TSLIB_CONFFILE&#x3D;$TSLIB_ROOT&#x2F;etc&#x2F;ts.conf</span><br><span class="line">export TSLIB_PLUGINDIR&#x3D;$TSLIB_ROOT&#x2F;lib&#x2F;ts</span><br><span class="line">export TSLIB_CALIBFILE&#x3D;&#x2F;etc&#x2F;pointercal</span><br><span class="line">export LD_PRELOAD&#x3D;$TSLIB_ROOT&#x2F;lib&#x2F;libts.so</span><br><span class="line">export QT_QPA_FB_TSLIB&#x3D;1QT_QPA_FB_TSLIB&#x3D;1</span><br><span class="line"></span><br><span class="line">echo &quot;tslib init success !!!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export QT_ROOT&#x3D;&#x2F;usr&#x2F;lib&#x2F;qt</span><br><span class="line">export QT_QPA_GENERIC_PLUGINS&#x3D;tslib:&#x2F;dev&#x2F;input&#x2F;event2</span><br><span class="line">export QT_QPA_FONTDIR&#x3D;&#x2F;arm-qt&#x2F;lib&#x2F;fonts</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH&#x3D;$QT_ROOT&#x2F;plugins</span><br><span class="line">export QT_QPA_PLATFORM&#x3D;linuxfb:tty&#x3D;&#x2F;dev&#x2F;fb0</span><br><span class="line">export QT_PLUGIN_PATH&#x3D;$QT_ROOT&#x2F;plugins</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$QT_ROOT&#x2F;lib:$QT_ROOT&#x2F;plugins&#x2F;platforms</span><br><span class="line">export QTWEBENGINE_DISABLE_SANDBOX&#x3D;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;qt env init success !!!&quot;</span><br><span class="line"></span><br><span class="line"># Source configuration files from &#x2F;etc&#x2F;profile.d</span><br><span class="line">for i in &#x2F;etc&#x2F;profile.d&#x2F;*.sh ; do</span><br><span class="line">        if [ -r &quot;$i&quot; ]; then</span><br><span class="line">                . $i</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">unset i</span><br></pre></td></tr></table></figure>
























<p>移植qt库：<a href="https://blog.csdn.net/jkl_wyl/article/details/103437465" target="_blank" rel="noopener">https://blog.csdn.net/jkl_wyl/article/details/103437465</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Qt应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串大小</title>
    <url>/C-C-Lover/%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>字符串”\\”A100\”\”的长度是多少？8个长度</p>
<p> \ 要用 \ 表示</p>
<p>‘’ 要用 &quot; 表示</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和栈</title>
    <url>/C-C-Lover/%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    <content><![CDATA[<p><strong>堆和栈的分别，优缺点，堆的大小是多少，栈的大小是多少？</strong></p>
<p><strong>栈区（stack）</strong></p>
<p>由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈<br>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
<p>优点：<br>1.高速，在栈上分配内存是非常快的。<br>2.简单，栈对象有自己的生命周期，你永远不可能发生内存泄露。<br>因为他总是在超出他的作用域时被自动销毁了。<br>缺点：栈对象严格的定义了生命周期也是其主要的缺点。</p>
<p><strong>堆区（heap）</strong></p>
<p>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。<br>这是由于系统是用链表来存储的空闲内存地址的，<br>自然是不连续的，而链表的遍历方向是由低地址向高地址。<br>堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>优点：可以自己控制对象的生命周期。<br>缺点：需要程序员手动释放，容易造成内存泄漏。</p>
<p>转载：网络</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>参考约束</title>
    <url>/MySql-Lover/%E8%80%83%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>6、假设有下面两个关系模式:<br>职工(职工号,姓名,年龄,职务,工资,部门号),其中职工号为主码;<br>部门(部门号,名称,经理名,电话),其中部门号为主码。<br>用SQL语言定义这两个关系模式,要求在模式中完成以下完整性约束条件的定义:<br>(1)定义每个模式的主码;<br>(2)定义参照完整性;<br>(3)定义职工年龄不得超过60岁；</p>
<p>CREATE TABLE 职工<br>(<br>职工号 CHAR(5) PRIMARY KEY,<br>姓名 CHAR(8) NOT NULL,<br>年龄 SMALLINT,<br>职务 CHAR(10),<br>工资 DECIMAL (7,2 ),<br>部门号 CHAR(5)<br>);</p>
<p>CREATE TABLE 部门<br>(<br>部门号 CHAR(5)PRIMARY KEY,<br>名称 CHAR(20),<br>经理名 CHAR(8)NOT NULL,<br>电话 CHAR(8)<br>);</p>
<p>ALTER TABLE 职工<br>ADD CONSTRAINT C1 CHECK(年龄 &lt; 60);</p>
<p>ALTER TABLE 职工<br>ADD CONSTRAINT C2 FOREIGN KEY (部门号) REFERENCES 部门(部门号);/<em>参考完整性约束</em>/</p>
<p>select * from 职工;<br>select * from 部门;</p>
<p>表级约束与列级约束？表级用于联合约束。</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>INPUT子系统</title>
    <url>/Linux-Lover/NPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>INPUT子系统</strong></p>
<p>   管理输入的子系统<br>   input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点.</p>
<p>   input 子系统的所有设备主设备号都为 13，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个<code>input_device</code> 即可</p>
<p>   input_dev 结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line"> const char *name;</span><br><span class="line"> const char *phys;</span><br><span class="line"> const char *uniq;</span><br><span class="line"> struct input_id id;</span><br><span class="line"></span><br><span class="line"> unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line"> unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; /* 事件类型的位图 */</span><br><span class="line"> unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; /* 按键值的位图 */</span><br><span class="line"> unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; /* 相对坐标的位图 */</span><br><span class="line"> unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; /* 绝对坐标的位图 */</span><br><span class="line"> unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; /* 杂项事件的位图 */</span><br><span class="line"> unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; /*LED 相关的位图 */</span><br><span class="line"> unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];/* sound 有关的位图 */</span><br><span class="line"> unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; /* 压力反馈的位图 */</span><br><span class="line"> unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; /*开关状态的位图 */</span><br><span class="line">......</span><br><span class="line"> bool devres_managed;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其中，evbit()输入事件类型</p>
<p>#define EV_SYN 0x00 /* 同步事件 <em>/<br>#define EV_KEY 0x01 /</em> 按键事件 <em>/<br>#define EV_REL 0x02 /</em> 相对坐标事件 <em>/<br>#define EV_ABS 0x03 /</em> 绝对坐标事件 <em>/<br>#define EV_MSC 0x04 /</em> 杂项(其他)事件 <em>/<br>#define EV_SW 0x05 /</em> 开关事件 <em>/<br>#define EV_LED 0x11 /</em> LED <em>/<br>#define EV_SND 0x12 /</em> sound(声音) <em>/<br>#define EV_REP 0x14 /</em> 重复事件 <em>/<br>#define EV_FF 0x15 /</em> 压力事件 <em>/<br>#define EV_PWR 0x16 /</em> 电源事件 <em>/<br>#define EV_FF_STATUS 0x17 /</em> 压力状态事件 */</p>
<p>按键连按：EV_KEY 、EV_REP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、申请一个 input_dev 结构体</span><br><span class="line">struct input_dev *input_allocate_device(void)</span><br><span class="line">注销</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*********第一种设置事件和事件值的方法***********&#x2F;</span><br><span class="line"> __set_bit(EV_KEY, inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F;</span><br><span class="line"> __set_bit(EV_REP, inputdev-&gt;evbit); &#x2F;* 重复事件 *&#x2F;</span><br><span class="line"> __set_bit(KEY_0, inputdev-&gt;keybit); &#x2F;*设置产生哪些按键值 *&#x2F;</span><br><span class="line"> &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*********第二种设置事件和事件值的方法***********&#x2F;</span><br><span class="line"> keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |</span><br><span class="line">BIT_MASK(EV_REP);</span><br><span class="line"> keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D;</span><br><span class="line">BIT_MASK(KEY_0);</span><br><span class="line"> &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*********第三种设置事件和事件值的方法***********&#x2F; keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |</span><br><span class="line">BIT_MASK(EV_REP);</span><br><span class="line">input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">&#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、上报输入事件</span><br><span class="line">但是具体是什么样的输入值 Linux 内核是不知道的.,我们需要获取到具体</span><br><span class="line">的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核</span><br><span class="line"></span><br><span class="line">void input_event(struct input_dev *dev,</span><br><span class="line">            unsigned int type,</span><br><span class="line">            unsigned int code,</span><br><span class="line">            int value)</span><br><span class="line">其他函数都是基于上面的函数而来。</span><br><span class="line"></span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_switch(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_mt_sync(struct input_dev *dev) </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">input_sync 函数来告诉 Linux 内核 input 子系统上报结束</span><br><span class="line"></span><br><span class="line">void input_sync(struct input_dev *dev)&#x2F;* 同步事件 *&#x2F;</span><br><span class="line"></span><br><span class="line">3、input_event  结构体</span><br><span class="line"></span><br><span class="line">struct input_event &#123;</span><br><span class="line"> struct timeval time;   &#x2F;*事件发生的时间*&#x2F;</span><br><span class="line"> __u16 type;          &#x2F;*事件类型*&#x2F;</span><br><span class="line"> __u16 code;			&#x2F;*事件码*&#x2F;</span><br><span class="line"> __s32 value;			&#x2F;*值*&#x2F;</span><br><span class="line"> &#125;;</span><br><span class="line">所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">驱动层</span><br><span class="line">#if  0</span><br><span class="line">    &#x2F;*  初始化 input_dev ，设 置产生哪些事件 *&#x2F;</span><br><span class="line">        __set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit); &#x2F;* 按键事件 *&#x2F;</span><br><span class="line">        __set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit); &#x2F;*  重复事件 *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;*  初始化 input_dev ，设置产生哪些按键 *&#x2F;</span><br><span class="line">        __set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);</span><br><span class="line">        ret &#x3D; input_register_device(keyinputdev.inputdev);</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">    #if  0</span><br><span class="line">        keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY)|BIT_MASK(EV_REP);</span><br><span class="line"></span><br><span class="line">        keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D;BIT_MASK(KEY_0);</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |BIT_MASK(EV_REP);</span><br><span class="line"></span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    应用层</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 定义一个 input_event 变量，存放输入事件信息 *&#x2F;</span><br><span class="line"> static struct input_event inputevent;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MISC驱动实验</title>
    <url>/Linux-Lover/SC%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>MISC 驱动也叫做杂项驱动，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。<br>所有的 MISC 设备驱动的主设备号都为<code>10</code>，不同的设备使用不同的从设备号。</p>
<p>miscdevice 结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct miscdevice &#123;</span><br><span class="line">     int minor; /* 子设备号 */</span><br><span class="line">     const char *name; /* 设备名字 */</span><br><span class="line">     const struct file_operations *fops; /* 设备操作集 */</span><br><span class="line">     struct list_head list;</span><br><span class="line">     struct device *parent;</span><br><span class="line">     struct device *this_device;</span><br><span class="line">     const struct attribute_group **groups;</span><br><span class="line">     const char *nodename;</span><br><span class="line">     umode_t mode;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义。</p>
<p>int misc_register(struct miscdevice * misc);<br>int misc_deregister(struct miscdevice *misc);</p>
<p>ls /dev/miscbeep -l    查看主次设备号</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树自带driver</title>
    <url>/Linux-Lover/%E5%A4%87%E6%A0%91%E8%87%AA%E5%B8%A6driver/</url>
    <content><![CDATA[<p>打开 RED 这个 LED<br>echo 1 &gt; /sys/class/leds/red/brightness //打开 LED0<br>关闭 RED 这个 LED<br>echo 0 &gt; /sys/class/leds/red/brightness //关闭 LED0</p>
<p>linux,default-trigger = “heartbeat”; //系统闪烁</p>
<p>//开机自闪烁<br>linux,default-trigger = “heartbeat”;<br>default-state = “on”;</p>
<p>函数了解：</p>
<p>count = device_get_child_node_count(dev);函数统计子节点数量</p>
<p>device_for_each_child_node(dev, child) //遍历</p>
<p>led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);</p>
<p>fwnode_property_read_string（）；</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb与gdbserver</title>
    <url>/Linux-Lover/gdb%E4%B8%8Egdbserver/</url>
    <content><![CDATA[<p><strong>GDB移植</strong></p>
<p>arm-linux-gnueabihf-gcc 就自带了主机使用的 arm-linux-gnueabihf-gdb 和开发板所使用的 gdbserver。</p>
<p>arm-linux-gnueabihf-gcc gdbtest.c -o gdbtest -g //编译测试程序，注意-g 选项<br>arm-linux-gnueabihf-gdb gdbtest<br>target remote 192.168.0.50:2001 //连接到开发板上</p>
<p>gdbserver 192.168.0.128：2001 gdbtest //开发板连接主机</p>
<p>命令：</p>
<p>l 命令(list)用于列出所有程序源码<br>b 命令(break)用于设置断点<br>c 命令用于运行到断点出，输入 c 命令程序就会运行<br>s 命令(step)是单步运行执行，此函数会进入到函数里面。<br>n 命令(next)也是单步运行，但是 n 命令不会进入到函数里面。<br>p 命令(print)用于打印某个变量值。<br>q 命令(quit)用于退出调试，开发板上的 gdbserver 也会停止。</p>
<p>查看断点：</p>
<p>info break ;</p>
<p> VSCode+gdbserver  图形化调试</p>
<p> .vscode文件launch.json 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"gdbtest"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"<span class="variable">$&#123;workspaceFolder&#125;</span>/gdbtest"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"<span class="variable">$&#123;workspaceFolder&#125;</span>"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gdb"</span>,</span><br><span class="line">            <span class="string">"miDebuggerServerAddress"</span>: <span class="string">"192.168.0.50:2001"</span></span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>platform框架</title>
    <url>/Linux-Lover/platform-%E4%BB%A3%E7%A0%81%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<p>无设备树platform</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//device.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CCM_CCGR1_BASE (0X020C406C)</span></span><br><span class="line"><span class="comment">#define SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span></span><br><span class="line"><span class="comment">#define SW_PAD_GPIO1_IO03_BASE (0X020E02F4)</span></span><br><span class="line"><span class="comment">#define GPIO1_DR_BASE (0X0209C000)</span></span><br><span class="line"><span class="comment">#define GPIO1_GDIR_BASE (0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define REGISTER_LENGTH 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void led_release(struct device *dev)</span><br><span class="line"> &#123;</span><br><span class="line">    printk(<span class="string">"led device released!\r\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct resource led_resources[] = </span><br><span class="line">&#123;</span><br><span class="line">    [0] = &#123;</span><br><span class="line">    .start = CCM_CCGR1_BASE,</span><br><span class="line">    .end = (CCM_CCGR1_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] = &#123;</span><br><span class="line">    .start = SW_MUX_GPIO1_IO03_BASE,</span><br><span class="line">    .end = (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [2] = &#123;</span><br><span class="line">    .start = SW_PAD_GPIO1_IO03_BASE,</span><br><span class="line">    .end = (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [3] = &#123;</span><br><span class="line">    .start = GPIO1_DR_BASE,</span><br><span class="line">    .end = (GPIO1_DR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [4] = &#123;</span><br><span class="line">    .start = GPIO1_GDIR_BASE,</span><br><span class="line">    .end = (GPIO1_GDIR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    static struct platform_device leddevice = &#123;</span><br><span class="line">            .name = <span class="string">"imx6ul-led"</span>,</span><br><span class="line">            .id = -1,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">            .release = &amp;led_release,</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        .num_resources = ARRAY_SIZE(led_resources),</span><br><span class="line">        .resource = led_resources,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddevice_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_device_register(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> static void __exit leddevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddevice_init);</span><br><span class="line">module_exit(leddevice_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//driver.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEDDEV_CNT 1 /* 设备号长度 */</span></span><br><span class="line"><span class="comment">#define LEDDEV_NAME "platled" /* 设备名字 */</span></span><br><span class="line"><span class="comment">#define LEDOFF 0</span></span><br><span class="line"><span class="comment">#define LEDON 1</span></span><br><span class="line"></span><br><span class="line">static void __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line">static void __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line">static void __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line">static void __iomem *GPIO1_DR;</span><br><span class="line">static void __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct leddev_dev&#123;</span><br><span class="line">    dev_t devid;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    int  major;</span><br><span class="line">    int minor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct leddev_dev leddev ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*LED 打开关闭*/</span><br><span class="line">static void led_switch(u8 sta)</span><br><span class="line">&#123;</span><br><span class="line">    u32 val = 0;</span><br><span class="line">    <span class="keyword">if</span>(sta == LEDOFF)</span><br><span class="line">    &#123;</span><br><span class="line">            val = readl(GPIO1_DR);  /*打开灯*/</span><br><span class="line">            val &amp;= ~(1 &lt;&lt; 3 ) ;</span><br><span class="line">            writel(val,GPIO1_DR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDON)</span><br><span class="line">    &#123; </span><br><span class="line">            val = readl(GPIO1_DR);  /*打开灯*/</span><br><span class="line">            val |= (1 &lt;&lt; 3 ) ;</span><br><span class="line">            writel(val,GPIO1_DR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode,</span><br><span class="line">                     struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    filp-&gt;private_data = &amp;leddev ;</span><br><span class="line">    //printk(<span class="string">"chrdevbase open!\r\n"</span>);</span><br><span class="line">     <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">size_t cnt, loff_t *offt)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> int retvalue;</span><br><span class="line"> unsigned char databuf[1];</span><br><span class="line"> unsigned char ledstat;</span><br><span class="line"></span><br><span class="line"> retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; 0) &#123;</span><br><span class="line"> <span class="built_in">return</span> -EFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ledstat = databuf[0]; /* 获取状态值 */</span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line"> led_switch(LEDON); /* 打开 LED 灯 */</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line"> led_switch(LEDOFF); /* 关闭 LED 灯 */</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations led_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = led_open,</span><br><span class="line">            .write = led_write,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int ressize[5];</span><br><span class="line">    u32 val = 0;</span><br><span class="line">    struct resource *ledsource[5];</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"led driver and device has matched!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    /*获取资源*/</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; 5 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ledsource[i] =  platform_get_resource(dev,IORESOURCE_MEM,i);</span><br><span class="line">        <span class="keyword">if</span> (!ledsource[i]) &#123;</span><br><span class="line">                dev_err(&amp;dev-&gt;dev, <span class="string">"No MEM resource for always on\r\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ressize[i] = resource_size(ledsource[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        IMX6U_CCM_CCGR1  = ioremap(ledsource[0]-&gt;start, ressize[0]);</span><br><span class="line">        SW_MUX_GPIO1_IO03 = ioremap(ledsource[1]-&gt;start, ressize[1]);</span><br><span class="line">        SW_PAD_GPIO1_IO03 = ioremap(ledsource[2]-&gt;start, ressize[2]);</span><br><span class="line">        GPIO1_DR = ioremap(ledsource[3]-&gt;start, ressize[3]);</span><br><span class="line">        GPIO1_GDIR = ioremap(ledsource[4]-&gt;start, ressize[4]);</span><br><span class="line">    val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">    val &amp;= ~(3 &lt;&lt; 26); /* 清除以前的设置  */</span><br><span class="line">    val |= (3 &lt;&lt; 26); /* 设置新值 */</span><br><span class="line">    writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        writel(5, SW_MUX_GPIO1_IO03);</span><br><span class="line">        writel(0x10B0, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line">        val = readl(GPIO1_GDIR);</span><br><span class="line">        val &amp;= ~(1 &lt;&lt; 3); </span><br><span class="line">        val |= (1 &lt;&lt; 3);</span><br><span class="line">        writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">        val = readl(GPIO1_DR);</span><br><span class="line">        val |= (1 &lt;&lt; 3) ;</span><br><span class="line">        writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"> /* 注册字符设备驱动 */</span><br><span class="line">/*1、创建设备号 */</span><br><span class="line"> <span class="keyword">if</span> (leddev.major) &#123; /* 定义了设备号 */</span><br><span class="line"> leddev.devid = MKDEV(leddev.major, 0);</span><br><span class="line"> register_chrdev_region(leddev.devid, LEDDEV_CNT,LEDDEV_NAME);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; /* 没有定义设备号 */</span><br><span class="line"> alloc_chrdev_region(&amp;leddev.devid, 0, LEDDEV_CNT,</span><br><span class="line">LEDDEV_NAME);</span><br><span class="line"> leddev.major = MAJOR(leddev.devid);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 2、初始化 cdev */</span><br><span class="line"> leddev.cdev.owner = THIS_MODULE;</span><br><span class="line"> cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line"></span><br><span class="line"> /* 3、添加一个 cdev */</span><br><span class="line"> cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line"> /* 4、创建类 */</span><br><span class="line"> leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line"> <span class="built_in">return</span> PTR_ERR(leddev.class);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 5、创建设备 */</span><br><span class="line"> leddev.device = device_create(leddev.class, NULL, leddev.devid,</span><br><span class="line">NULL, LEDDEV_NAME);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line"> <span class="built_in">return</span> PTR_ERR(leddev.device);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">    iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">    iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">    iounmap(GPIO1_DR);</span><br><span class="line">    iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;leddev.cdev);</span><br><span class="line">    unregister_chrdev_region(leddev.devid, LEDDEV_CNT);</span><br><span class="line">    device_destroy(leddev.class, leddev.devid);</span><br><span class="line">    class_destroy(leddev.class);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static struct platform_driver led_driver = &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">"imx6ul-led"</span>, /* 驱动名字，用于和设备匹配 */</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe = led_probe,</span><br><span class="line">        .remove = led_remove,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void __exit leddriver_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>


<p>设备树版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/poll.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/platform_device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEDDEV_CNT 1 /* 设备号长度 */</span></span><br><span class="line"><span class="comment">#define LEDDEV_NAME "dtsplatled" /* 设备名字 */</span></span><br><span class="line"><span class="comment">#define LEDOFF 0</span></span><br><span class="line"><span class="comment">#define LEDON 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct leddev_dev&#123;</span><br><span class="line">    dev_t devid;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    struct device_node *node ;</span><br><span class="line">    int  major;</span><br><span class="line">    int minor;</span><br><span class="line">    int led0;  /* LED 灯 GPIO 标号 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct leddev_dev leddev ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*LED 打开关闭*/</span><br><span class="line">static void led_switch(u8 sta)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta == LEDON)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            gpio_set_value(leddev.led0,0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDOFF)</span><br><span class="line">        &#123;</span><br><span class="line">            gpio_set_value(leddev.led0,1); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode,</span><br><span class="line">                     struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    filp-&gt;private_data = &amp;leddev ;</span><br><span class="line">    //printk(<span class="string">"chrdevbase open!\r\n"</span>);</span><br><span class="line">     <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">size_t cnt, loff_t *offt)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> int retvalue;</span><br><span class="line"> unsigned char databuf[1];</span><br><span class="line"> unsigned char ledstat;</span><br><span class="line"></span><br><span class="line"> retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; 0) &#123;</span><br><span class="line"> <span class="built_in">return</span> -EFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ledstat = databuf[0]; /* 获取状态值 */</span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line"> led_switch(LEDON); /* 打开 LED 灯 */</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line"> led_switch(LEDOFF); /* 关闭 LED 灯 */</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations led_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = led_open,</span><br><span class="line">            .write = led_write,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">"led driver and device has matched!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        /* 注册字符设备驱动 */</span><br><span class="line">        /*1、创建设备号 */</span><br><span class="line">        <span class="keyword">if</span> (leddev.major) &#123; /* 定义了设备号 */</span><br><span class="line">        leddev.devid = MKDEV(leddev.major, 0);</span><br><span class="line">        register_chrdev_region(leddev.devid, LEDDEV_CNT,LEDDEV_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; /* 没有定义设备号 */</span><br><span class="line">        alloc_chrdev_region(&amp;leddev.devid, 0, LEDDEV_CNT,</span><br><span class="line">        LEDDEV_NAME);</span><br><span class="line">        leddev.major = MAJOR(leddev.devid);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        /* 2、初始化 cdev */</span><br><span class="line">        leddev.cdev.owner = THIS_MODULE;</span><br><span class="line">        cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">        /* 3、添加一个 cdev */</span><br><span class="line">        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line">        /* 4、创建类 */</span><br><span class="line">        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(leddev.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 5、创建设备 */</span><br><span class="line">        leddev.device = device_create(leddev.class, NULL, leddev.devid,</span><br><span class="line">        NULL, LEDDEV_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(leddev.device);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*初始化IO*/</span><br><span class="line"></span><br><span class="line">        leddev.node = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">        <span class="keyword">if</span> (leddev.node == NULL)&#123;</span><br><span class="line">            printk(<span class="string">"gpioled node nost find!\r\n"</span>);</span><br><span class="line">             <span class="built_in">return</span> -EINVAL;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        leddev.led0 = of_get_named_gpio(leddev.node,<span class="string">"led-gpios"</span>,0);</span><br><span class="line">        <span class="keyword">if</span> (leddev.led0 &lt; 0) &#123;</span><br><span class="line">        printk(<span class="string">"can't get led-gpio\r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gpio_request(leddev.led0, <span class="string">"led0"</span>);</span><br><span class="line"></span><br><span class="line">        gpio_direction_output(leddev.led0, 1); /*设置为输出，默认高电平 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    gpio_set_value(leddev.led0,1);</span><br><span class="line">    cdev_del(&amp;leddev.cdev);</span><br><span class="line">    unregister_chrdev_region(leddev.devid, LEDDEV_CNT);</span><br><span class="line">    device_destroy(leddev.class, leddev.devid);</span><br><span class="line">    class_destroy(leddev.class);</span><br><span class="line">    printk(<span class="string">"driver  release!\r\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 匹配列表 */</span><br><span class="line">static const struct of_device_id  led_of_match[] =&#123;</span><br><span class="line">    &#123; .compatible = <span class="string">"ming,gpioled"</span> &#125;,</span><br><span class="line">    &#123; /* Sentinel */ &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*驱动匹配*/</span><br><span class="line">static struct platform_driver led_driver = &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">"imx6ul-led"</span>, /* 驱动名字，用于和设备匹配 */</span><br><span class="line">        .of_match_table = led_of_match,</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe = led_probe,</span><br><span class="line">        .remove = led_remove,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void __exit leddriver_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*注册驱动函数*/</span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>伺服与检测</title>
    <url>/Circuit-Lover/%E4%BC%BA%E6%9C%8D%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p><strong>伺服系统</strong></p>
<p>伺服系统，即随动系统，是能够跟踪输入指令信号进行动作，从而获得精确位置、速度或力输出的自动控制系统。</p>
<p>进给伺服系统（ Feed Servo System ）的定义及组成<br>定义：以移动部件的位置和速度作为控制量的自动控制系统。<br>组成：位置控制单元；速度控制单元；驱动元件(电机)；检测与反馈单元；机械执行部件。</p>
<p>伺服系统的分类<br>（1）开环伺服系统<br>（2）闭环伺服系统<br>脉冲编码器<br>（3）半闭环伺服系统<br>位置检测传感器</p>
<p><strong>三个环</strong></p>
<p> 力环，电流反馈，取样电阻<br> 速度环  速度反馈；测速发电机，光电编码器，旋转变压器等<br> 位置环  位置反馈；光电编码器，旋转变压器，光栅等</p>
<p><strong>检测元件的分类</strong></p>
<img src="/Circuit-Lover/%E4%BC%BA%E6%9C%8D%E4%B8%8E%E6%A3%80%E6%B5%8B/%E6%A3%80%E6%B5%8B%E8%A3%85%E7%BD%AE.jpg" class="">


<p><strong>旋转变压器与感应同步器</strong></p>
<p><strong>光电编码器</strong></p>
<p><strong>光栅尺</strong></p>
<p>莫尔条纹特点：<br>1.放大作用<br>2.平均效应(误差均化)<br>3.信息变换<br>4.光强分布规律</p>
<p>同步、异步电机：<br>异步电动机的转速时刻跟随负载大小的变化而变化。</p>
<p><strong>扩展：</strong></p>
<p><strong>日系驱动器</strong></p>
<p>日系伺服品牌众多，其中比较有代表性的产品主要是<br> YASKAWA 的 Σ （ SIGMA ）—-安川电机<br> Mitsubishi 的 MELSERVO<br> Panasonic 的 MINAS A</p>
<p>这三个可配置数字量输入输出：<br>MINAS A6：10 入 / 6 出；<br>Σ-7： 8 入 / 7 出；<br>MR-J4：3 入 / 3 出；</p>
<p>模拟量输入输出：<br>MINAS A6：3 入 / 2 出；<br>Σ-7： 1 入 / 2 出；<br>MR-J4：1 入 / 2 出；</p>
<p><strong>欧系伺服驱动</strong></p>
<p>比如我们熟知的 SINAMICS S210、HCS01等<br>从驱动器外型上看，大部分主流的欧系伺服驱动，都会采用高、深、薄的书本式设计，并且普遍支持无缝并列的安装样式。这一点可以从几款经典的产品很明显的看出来。</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>platform  设备驱动</title>
    <url>/Linux-Lover/latform-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>驱动的分离与分层这样的软件思路</p>
<p>分离：主机驱动和设备驱动分隔开来。</p>
<p>分层：input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。</p>
<p>主机驱动-》API函数接口-》设备驱动</p>
<p>每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)。</p>
<p><strong>platform  总线</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct bus_type！！！</span><br><span class="line"></span><br><span class="line">static int platform_match(struct device *dev,</span><br><span class="line">struct device_driver *drv)</span><br><span class="line">匹配方式</span><br><span class="line">1、<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较,probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行</span><br><span class="line">2、<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">ACPI 匹配方式。</span><br><span class="line">3、<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">id_table 匹配，每个 platform_driver 结构体有一个 id_table</span><br><span class="line">成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱</span><br><span class="line">动类型。</span><br><span class="line">4、<span class="built_in">return</span> (strcmp(pdev-&gt;name, drv-&gt;name) == 0);</span><br><span class="line">直接比较驱动和设备的 name 字段</span><br></pre></td></tr></table></figure>
<p><strong>platform  驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include/linux/platform_device.h </span><br><span class="line"></span><br><span class="line">定义并初始化好 platform_driver 结构体变量-&gt; 入口注册Linux 内核注册一个 platform 驱动，platform_driver_register -&gt;出口卸载void platform_driver_unregister(struct platform_driver *drv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。</span><br></pre></td></tr></table></figure>

<p><strong>platform  设备</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/platform_device.h</span><br><span class="line">不支持设备树的 Linux 版本中使用的</span><br><span class="line">int platform_device_register(struct platform_device *pdev</span><br><span class="line">void platform_device_unregister(struct platform_device *pdev)</span><br><span class="line"></span><br><span class="line">支持设备数版本，从设备树中读取设备信息，然后将其组织成 platform_device 形式</span><br></pre></td></tr></table></figure>
<p>ls /sys/bus/platform/ 根文件系统目录下查看device、driver</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>异步通知</title>
    <url>/Linux-Lover/%E6%AD%A5%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p><strong>复习：阻塞IO与非阻塞IO</strong></p>
<p>Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况，如果能提供一种类似中断的机制，当驱动程序可以访问的时候主动告诉应用程序那就最好了。</p>
<p>驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据。<br>异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">34 <span class="comment">#define SIGHUP 1 /* 终端挂起或控制进程终止 */</span></span><br><span class="line">35 <span class="comment">#define SIGINT 2 /* 终端中断(Ctrl+C 组合键) */</span></span><br><span class="line">36 <span class="comment">#define SIGQUIT 3 /* 终端退出(Ctrl+\组合键) */</span></span><br><span class="line">37 <span class="comment">#define SIGILL 4 /* 非法指令 */</span></span><br><span class="line">38 <span class="comment">#define SIGTRAP 5 /* debug 使用，有断点指令产生  */</span></span><br><span class="line">39 <span class="comment">#define SIGABRT 6 /* 由 abort(3)发出的退出指令 */</span></span><br><span class="line">40 <span class="comment">#define SIGIOT 6 /* IOT 指令 */</span></span><br><span class="line">41 <span class="comment">#define SIGBUS 7 /* 总线错误 */</span></span><br><span class="line">42 <span class="comment">#define SIGFPE 8 /* 浮点运算错误 */</span></span><br><span class="line">43 <span class="comment">#define SIGKILL 9 /* 杀死、终止进程 */</span></span><br><span class="line">44 <span class="comment">#define SIGUSR1 10 /* 用户自定义信号 1 */</span></span><br><span class="line">45 <span class="comment">#define SIGSEGV 11 /* 段违例(无效的内存段) */</span></span><br><span class="line">46 <span class="comment">#define SIGUSR2 12 /* 用户自定义信号 2 */</span></span><br><span class="line">47 <span class="comment">#define SIGPIPE 13 /* 向非读管道写入数据 */</span></span><br><span class="line">48 <span class="comment">#define SIGALRM 14 /* 闹钟 */</span></span><br><span class="line">49 <span class="comment">#define SIGTERM 15 /* 软件终止 */</span></span><br><span class="line">50 <span class="comment">#define SIGSTKFLT 16 /* 栈异常 */</span></span><br><span class="line">51 <span class="comment">#define SIGCHLD 17 /* 子进程结束 */</span></span><br><span class="line">52 <span class="comment">#define SIGCONT 18 /* 进程继续 */</span></span><br><span class="line">53 <span class="comment">#define SIGSTOP 19 /* 停止进程的执行，只是暂停 */</span></span><br><span class="line">54 <span class="comment">#define SIGTSTP 20 /* 停止进程的运行(Ctrl+Z 组合键) */</span></span><br><span class="line">55 <span class="comment">#define SIGTTIN 21 /* 后台进程需要从终端读取数据  */</span></span><br><span class="line">56 <span class="comment">#define SIGTTOU 22 /* 后台进程需要向终端写数据 */</span></span><br><span class="line">57 <span class="comment">#define SIGURG 23 /* 有"紧急"数据 */</span></span><br><span class="line">58 <span class="comment">#define SIGXCPU 24 /* 超过 CPU 资源限制 */</span></span><br><span class="line">59 <span class="comment">#define SIGXFSZ 25 /* 文件大小超额 */</span></span><br><span class="line">60 <span class="comment">#define SIGVTALRM 26 /* 虚拟时钟信号 */</span></span><br><span class="line">61 <span class="comment">#define SIGPROF 27 /* 时钟信号描述 */</span></span><br><span class="line">62 <span class="comment">#define SIGWINCH 28 /* 窗口大小改变 */</span></span><br><span class="line">63 <span class="comment">#define SIGIO 29 /* 可以进行输入/输出操作 */</span></span><br><span class="line">64 <span class="comment">#define SIGPOLL SIGIO</span></span><br><span class="line">65 /* <span class="comment">#define SIGLOS 29 */</span></span><br><span class="line">66 <span class="comment">#define SIGPWR 30 /* 断点重启 */</span></span><br><span class="line">67 <span class="comment">#define SIGSYS 31 /* 非法的系统调用 */</span></span><br><span class="line">68 <span class="comment">#define SIGUNUSED 31 /* 未使用信号 */</span></span><br></pre></td></tr></table></figure>

<p><strong>信号</strong></p>
<p>1、信号处理函数<br>sighandler_t signal(int signum, sighandler_t handler)<br>参数：signum：要设置处理函数的信号、handler ：信号的处理函数</p>
<p>2、驱动中的信号处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主要：struct fasync_struct *async_queue; /* 异步相关结构体 */ </span><br><span class="line"></span><br><span class="line">框架：</span><br><span class="line"> struct xxx_dev &#123;</span><br><span class="line"> ......</span><br><span class="line"> struct fasync_struct *async_queue; /* 异步相关结构体 */</span><br><span class="line"> &#125;;</span><br><span class="line"> static int xxx_fasync(int fd, struct file *filp, int on)</span><br><span class="line"> &#123;</span><br><span class="line"> struct xxx_dev *dev = (xxx_dev)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)</span><br><span class="line"> <span class="built_in">return</span> -EIO;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line">static struct file_operations xxx_ops = &#123;</span><br><span class="line"> ......</span><br><span class="line"> .fasync = xxx_fasync,</span><br><span class="line">......</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /*释放*/</span><br><span class="line"> static int xxx_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">return</span> xxx_fasync(-1, filp, 0); /*  删除异步通知 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3、kill_sync函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 、kill_fasync  函数</span><br><span class="line">当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync</span><br><span class="line">函数负责发送指定的信号，kill_fasync 函数原型如下所示：</span><br><span class="line">void kill_fasync(struct fasync_struct **fp, int sig, int band)</span><br><span class="line">函数参数和返回值含义如下：</span><br><span class="line">fp：要操作的 fasync_struct。</span><br><span class="line">sig ：要发送的信号。</span><br><span class="line">band ：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure>

<p>4、应用层</p>
<p>1、注册信号函数-&gt;signal()<br>2、将进程号告诉给内核-&gt; fcntl(fd, F_SETOWN, getpid())<br>3、开启异步通知<br>-&gt;&gt;flags = fcntl(fd, F_GETFL); /* 获取当前的进程状态<em>/<br>-&gt;&gt;fcntl(fd, F_SETFL, flags | FASYNC); /</em> 开启当前进程异步通知功能 */</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>container_of函数🏃</title>
    <url>/Linux-Lover/container-of%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>offsetof  宏  判断结构体中成员的偏移位置<br>使用 offsetof 宏需要包含 stddef.h 头文件，实例可以参考<br>offsetof 宏的定义如下：<br>#define offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member)<br>巧妙之处在于将地址 0 强制转换为 type 类型的指针，从而定位到 member 在结构体中偏移位置。编译<br>器认为 0 是一个有效的地址，从而认为 0 是 type 指针的起始地址。</p>
<p>参考：<a href="http://www.cnblogs.com/Anker/p/3472271.html。" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/p/3472271.html。</a></p>
<p>Container_of在Linux内核中是一个常用的宏，inux/kernel.h 。<br> 通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #define container_of(ptr, type, member) (&#123; \</span><br><span class="line">      const typeof( ((type *)0)-&gt;member ) *__mptr &#x3D; (ptr); \</span><br><span class="line">      (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line">      </span><br><span class="line">第一部分：const typeof( ((type *)0)-&gt;member ) *__mptr &#x3D; (ptr);</span><br><span class="line">通过 typeof 定义一个 member 指针类型的指针变量__mptr， （即__mptr 是指向 member 类型的指针），并将__mptr 赋值为 ptr。第一部分的目的是为了将统一转换为 member 类型指针。</span><br><span class="line">第二部分： (type *)( (char *)__mptr - offsetof(type,member) )，通过 offsetof 宏计算出member 在 type 中的偏移，然后用 member 的实际地址__mptr 减去偏移，得到 type 的起始地址，即指</span><br><span class="line">向 type 类型的指针。</span><br></pre></td></tr></table></figure>




 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">hanshucontainer_of(ptr, <span class="built_in">type</span>, member) </span><br><span class="line">ptr:表示结构体中member的地址</span><br><span class="line"><span class="built_in">type</span>:表示结构体类型</span><br><span class="line">member:表示结构体中的成员</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void key_work(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">"work 调用处理下半区\r\n"</span>);</span><br><span class="line">    struct imx6uirq_dev *dev = container_of(work,struct imx6uirq_dev,work);</span><br><span class="line">      </span><br><span class="line">    /*消除抖动处理 10ms*/</span><br><span class="line">    dev-&gt;timer.data = (unsigned long)dev; /*指定设备*/</span><br><span class="line">    mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体不能强制转换类型，但是地址（指针可以）!!!!🏌️</p>
<p>参考：<a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-chain" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/kernel/l-chain</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>向量，链表，队列？</title>
    <url>/C-C-Lover/%E9%87%8F%EF%BC%8C%E9%93%BE%E8%A1%A8%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>向量，链表，队列？</strong></p>
<p><strong>vector</strong></p>
<p>存储特点：连续存储的容器，动态数组，在堆上分配空间<br>底层实现：数组<br>两倍容量增长：空间不够<br>插入方式：<br>        （1）在最后插入（空间够）：很快，（空间不够）需要内存申请和释放，以及对之前数据进行拷贝。<br>        （2）在中间插入（空间够）：内存拷贝，（空间不够）需要内存申请和释放，以及对之前数据进行拷贝。<br>使用场景：支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率</p>
<p><strong>List</strong></p>
<p>存储特点：动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。<br>底层：双向链表<br>插入特性：<br>        插入：很快，一般是常数开销<br>        删除：很快，一般是常数开销<br>适用场景：list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。<br>区别：vector支持随机访问（数组），list不支持（链表）。<br>    vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p><strong>Deque</strong></p>
<p>存储特点： deque相对vector较为有优势。<br>底层： 数组<br>插入特性：<br>        deque头部和尾部添加或移除元素都非常快速，可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。<br>        中间insert()函数。iterator erase(iteratorpos);<br>适用场景：支持随机访问和存取，支持下标访问，而且插入和删除的效率高的容器。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞IO与非阻塞IO</title>
    <url>/Linux-Lover/%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</url>
    <content><![CDATA[<p><strong>阻塞IO与非阻塞IO</strong></p>
<p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃.</p>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int fd;</span><br><span class="line">int data = 0;</span><br><span class="line">fd = open(<span class="string">"/dev/xxx_dev"</span>, O_RDWR); /* 阻塞方式打开 */</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data)); /* 读取数据 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fd;</span><br><span class="line">int data = 0;</span><br><span class="line">fd = open(<span class="string">"/dev/xxx_dev"</span>, O_RDWR | O_NONBLOCK);  /* 非阻塞方式打开 */</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data)); /* 读取数据 */</span><br></pre></td></tr></table></figure>
<p><strong>等待队列头 -&gt; 阻塞</strong></p>
<p>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。</p>
<p>1、等待队列头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct __wait_queue_head &#123;</span><br><span class="line"> spinlock_t lock;</span><br><span class="line"> struct list_head task_list;</span><br><span class="line"> &#125;;</span><br><span class="line">typedef struct __wait_queue_head wait_queue_head_t;</span><br><span class="line">定义好等待队列头以后需要初始化 </span><br><span class="line">void init_waitqueue_head(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure>
<p>2、等待队列项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct __wait_queue &#123;</span><br><span class="line">unsigned int flags;</span><br><span class="line">void *private;</span><br><span class="line">wait_queue_func_t func;</span><br><span class="line">struct list_head task_list;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct __wait_queue wait_queue_t;</span><br><span class="line"></span><br><span class="line">使用宏 DECLARE_WAITQUEUE 定义并初始化一个等待队列项，宏的内容如下：</span><br><span class="line">DECLARE_WAITQUEUE(name, tsk);</span><br><span class="line">name 等待队列项的名字，tsk 等待队列项所属进程</span><br></pre></td></tr></table></figure>
<p>3、添加移除等待队列头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">设备不可访问，只有添加到等待队列头中以后进程才能进入休眠态</span><br><span class="line">可以访问以后再将进程对应的等待队列项从等待队列头中移除即可。</span><br><span class="line"></span><br><span class="line">void add_wait_queue(wait_queue_head_t *q,wait_queue_t *<span class="built_in">wait</span>)</span><br><span class="line"></span><br><span class="line">void remove_wait_queue(wait_queue_head_t *q,</span><br><span class="line">wait_queue_t *<span class="built_in">wait</span>)</span><br></pre></td></tr></table></figure>

<p>4 、等待唤醒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void wake_up(wait_queue_head_t *q)</span><br><span class="line">void wake_up_interruptible(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure>

<p>5、等待事件唤醒</p>
<img src="/Linux-Lover/%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0.jpg" class="">

<p> 实验小结：wait_event()不能被kill- 9 ,建议使用wait_event_iterruptible()</p>
<p>wait_event(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));<br>wake_up(&amp;dev-&gt;r_wait);</p>
<p>-分割线-</p>
<p>wait_event_interruptible(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));<br>wake_up_interruptible(&amp;dev-&gt;r_wait);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if 0</span></span><br><span class="line">     wait_event(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if 0</span></span><br><span class="line">    wait_event_interruptible(dev-&gt;r_wait,atomic_read(&amp;dev-&gt;releasekey));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    DECLARE_WAITQUEUE(<span class="built_in">wait</span>, current); /*  定义一个等待队列 */</span><br><span class="line">    add_wait_queue(&amp;dev-&gt;r_wait,&amp;<span class="built_in">wait</span>); /*加入队列*/</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);/*设置为可打断*/</span><br><span class="line">        schedule();  /*切换*/</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(signal_pending(current))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            goto  wait_error;</span><br><span class="line">        &#125;</span><br><span class="line">         __set_current_state(TASK_RUNNING); /*  设置任务为运行态 */</span><br><span class="line">         remove_wait_queue(&amp;dev-&gt;r_wait, &amp;<span class="built_in">wait</span>); /*  将等待队列移除 */</span><br><span class="line">    keyvalue = atomic_read(&amp;dev-&gt;keyvalue);</span><br><span class="line">    releasekey = atomic_read(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasekey)</span><br><span class="line">     &#123; /* 有按键按下 */</span><br><span class="line">        <span class="keyword">if</span> (keyvalue &amp; 0x80)  /*判断有效1000 0000 标志位*/</span><br><span class="line">            &#123;</span><br><span class="line">            keyvalue &amp;= ~0x80;</span><br><span class="line">            ret = copy_to_user(buf, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            goto data_error;</span><br><span class="line">            &#125;</span><br><span class="line">            atomic_set(&amp;dev-&gt;releasekey, 0);  /* 按下标志清零 */</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       goto data_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">wait_error:</span><br><span class="line">    __set_current_state(TASK_RUNNING); /*  设置任务为运行态 */</span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;r_wait, &amp;<span class="built_in">wait</span>); /*  将等待队列移除 */</span><br><span class="line">    data_error:</span><br><span class="line">    <span class="built_in">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>






<p><strong>轮询 -&gt; 非阻塞</strong></p>
<p>应用程序通过 select、epoll 或 poll 使用函数，设备驱动程序中的 poll 函数就会执行。</p>
<p>1、select函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int select(int nfds,</span><br><span class="line">        fd_set *readfds,</span><br><span class="line">        fd_set *writefds,</span><br><span class="line">        fd_set *exceptfds,</span><br><span class="line">        struct timeval *timeout)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">nfds ：要操作的文件描述符个数</span><br><span class="line">readfds 用于监视指定描述符集的读变化</span><br><span class="line">writefs 用于监视这些文件是否可以进行写操</span><br><span class="line">exceptfds 用于监视这些文件的异常</span><br><span class="line">timeout超时时间</span><br><span class="line">定义一个 fd_set 变量</span><br><span class="line">void FD_ZERO(fd_set *<span class="built_in">set</span>)    	  全部清零</span><br><span class="line">void FD_SET(int fd, fd_set *<span class="built_in">set</span>)   某位加1</span><br><span class="line">void FD_CLR(int fd, fd_set *<span class="built_in">set</span>)	某位清0</span><br><span class="line">int FD_ISSET(int fd, fd_set *<span class="built_in">set</span>)	是否可以进行操作</span><br><span class="line"></span><br><span class="line">select框架</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int ret, fd; /* 要监视的文件描述符 */</span><br><span class="line">  fd_set readfds; /* 读操作文件描述符集 */</span><br><span class="line">  struct timeval timeout; /* 超时结构体 */</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">"dev_xxx"</span>, O_RDWR | O_NONBLOCK); </span><br><span class="line">  /* 非阻塞式访问 */</span><br><span class="line">   FD_ZERO(&amp;readfds); /* 清除 readfds */</span><br><span class="line">   FD_SET(fd, &amp;readfds);/* 将 fd 添加到 readfds 里面 */</span><br><span class="line">   /* 构造超时时间 */</span><br><span class="line">   timeout.tv_sec = 0;</span><br><span class="line">   timeout.tv_usec = 500000; /* 500ms */</span><br><span class="line">   ret = select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">   switch (ret) &#123;</span><br><span class="line">   <span class="keyword">case</span> 0: /* 超时 */</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"timeout!\r\n"</span>);</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   <span class="keyword">case</span> -1: /* 错误 */</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"error!\r\n"</span>);</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   default: /* 可以读取数据 */</span><br><span class="line">   <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; /* 判断是否为 fd 文件描述符 */</span><br><span class="line">   /* 使用 <span class="built_in">read</span> 函数读取数据 */</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>2 、poll函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，</span><br><span class="line">poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制。</span><br><span class="line">int poll(struct pollfd *fds,</span><br><span class="line">          nfds_t nfds,</span><br><span class="line">          int timeout)</span><br><span class="line">fds要监视的文件描述符集合以及要监视的事件    </span><br><span class="line">struct pollfd &#123;</span><br><span class="line">      int fd; /* 文件描述符 */</span><br><span class="line">      short events; /* 请求的事件 */</span><br><span class="line">      short revents; /* 返回的事件 */</span><br><span class="line">&#125;;          </span><br><span class="line">nfds：poll 函数要监视的文件描述符数量  </span><br><span class="line">timeout ：超时时间，单位为 ms。</span><br><span class="line">可监视的事件类型:</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT  可以写数据。</span><br><span class="line">    POLLERR  指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP  指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM  等同于 POLLIN</span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret;</span><br><span class="line">int fd; /* 要监视的文件描述符 */</span><br><span class="line">struct pollfd fds;</span><br><span class="line">fd = open(filename, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */</span><br><span class="line"></span><br><span class="line">fds.fd = fd;</span><br><span class="line">fds.events = POLLIN; /* 监视数据是否可以读取*/</span><br><span class="line"></span><br><span class="line">ret = poll(&amp;fds, 1, 500); /* 轮询文件是否可操作，超时 500ms */</span><br><span class="line"><span class="keyword">if</span> (ret) &#123; /* 数据有效 */</span><br><span class="line"> ......</span><br><span class="line">/* 读取数据 */</span><br><span class="line"> ......</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == 0) &#123; /* 超时 */</span><br><span class="line"> ......</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; 0) &#123; /* 错误 */</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 、epoll  函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll因运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int epoll_create(int size)</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd,</span><br><span class="line">          int op,</span><br><span class="line">          int  fd,</span><br><span class="line">          struct epoll_event *event)</span><br><span class="line"></span><br><span class="line">nt epoll_wait(int epfd,</span><br><span class="line">          struct epoll_event *events,</span><br><span class="line">          int maxevents,</span><br><span class="line">          int timeout)</span><br></pre></td></tr></table></figure>

<p><strong>查询实验</strong></p>
<p>``bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__Linux  驱动下的 poll__</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line"></span><br><span class="line">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line"></span><br><span class="line">参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table，就是</span><br><span class="line">file_operations 中 poll 函数的 wait 参数</span><br></pre></td></tr></table></figure>
<p><strong>实验部分</strong></p>
<p>1、驱动层部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static struct file_operations imx6uirq_fops = &#123;</span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">            .open = imx6uirq_open,</span><br><span class="line">            .<span class="built_in">read</span> = imx6uirq_read,</span><br><span class="line">            .poll = imx6uirq_poll,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static unsigned int imx6uirq_poll(struct file *filp ,struct poll_table_struct *<span class="built_in">wait</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int mask = 0;</span><br><span class="line">    struct  imx6uirq_dev *dev = filp -&gt;private_data;</span><br><span class="line"></span><br><span class="line">    poll_wait(filp,&amp;dev-&gt;r_wait,<span class="built_in">wait</span>);</span><br><span class="line">    /*返回应用层是否可读*/</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(atomic_read(&amp;dev-&gt;releasekey))</span><br><span class="line">    &#123;</span><br><span class="line">        mask = POLL_IN | POLLRDNORM ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> mask ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、应用层</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ioctl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "poll.h"</span></span><br><span class="line"> <span class="comment">#include "sys/select.h"</span></span><br><span class="line"> <span class="comment">#include "sys/time.h"</span></span><br><span class="line"> <span class="comment">#include "linux/ioctl.h"</span></span><br><span class="line">/*</span><br><span class="line"> *argc:应用程序参数个数</span><br><span class="line"> *argv[]:具体的参数内容，字符串形式 </span><br><span class="line"> *./ledAPP  &lt;filename&gt;  &lt;0:1&gt; 0表示关灯，1表示开灯</span><br><span class="line"> * ./ledAPP /dev/dtsled 0    关灯</span><br><span class="line"> * ./ledAPP /dev/dtsled 1    开灯</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*IOctrl 命令*/</span><br><span class="line"><span class="comment">#define CLOSE_CMD (_IO(0XEF, 0x1)) /* 关闭定时器 */</span></span><br><span class="line"><span class="comment">#define OPEN_CMD (_IO(0XEF, 0x2)) /* 打开定时器 */</span></span><br><span class="line"><span class="comment">#define SETPERIOD_CMD (_IO(0XEF, 0x3)) /* 设置定时器周期命令 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    int ret ;</span><br><span class="line">    char *filename;</span><br><span class="line"></span><br><span class="line">    /*select */</span><br><span class="line">    unsigned char data;</span><br><span class="line">    struct timeval timeout;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    /*poll*/</span><br><span class="line">    struct pollfd  fds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error Usage!\r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    filename = argv[1];</span><br><span class="line">    fd = open(filename,O_RDWR|O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"file %s open failed!\r\n"</span>, argv[1]);</span><br><span class="line">         <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fds.fd = fd ;</span><br><span class="line">        fds.events = POLLIN;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (1)</span><br><span class="line">    &#123;</span><br><span class="line">       ret = poll(&amp;fds,1,2000);/*事件、数量1、超时2s*/</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(data)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"read error !!! \r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"key value = %d \r\n"</span>,data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">" time out!!!\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">"poll error\r\n"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#if 0</span></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">            FD_ZERO(&amp;readfds);</span><br><span class="line">            FD_SET(fd, &amp;readfds);</span><br><span class="line">            timeout.tv_sec = 0;</span><br><span class="line">            timeout.tv_usec = 5000000;</span><br><span class="line"></span><br><span class="line">        ret = select(fd+1,&amp;readfds,NULL,NULL,&amp;timeout);</span><br><span class="line">        switch (ret)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> 0:</span><br><span class="line">            /* 用户自定义超时处理 */</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"time out !!!\r\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -1:</span><br><span class="line">            /* 用户错误 */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select error!!!\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds))</span><br><span class="line">            &#123;</span><br><span class="line">                    ret = <span class="built_in">read</span>(fd, &amp;data, sizeof(data));</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">               &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"rwad error !!!"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(data)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">"key value = %d \r\n"</span>,data);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>热电式传感器</title>
    <url>/Circuit-Lover/%E7%83%AD%E7%94%B5%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>压电式传感器</title>
    <url>/Circuit-Lover/%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据理论🏃</title>
    <url>/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><strong>关系模式由五部分组成</strong></p>
<p>它是一个五元组：R(U, D, DOM, F)<br>R：      关系名<br>U：       组成该关系的属性名集合<br>D：       属性组U中属性所来自的域<br>DOM： 属性向域的映象集合<br>F：       属性间数据的依赖关系集合<br>简化为一个三元组：R（U, F）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[例1]建立一个描述学校教务的数据库：</span><br><span class="line">	学生的学号（Sno）、所在系（Sdept）</span><br><span class="line">	系主任姓名（Mname）、课程名（Cname）</span><br><span class="line">	成绩（Grade）</span><br><span class="line"></span><br><span class="line">单一的关系模式 ：   Student &lt;U、F&gt;</span><br><span class="line">U ＝｛ Sno, Sdept, Mname, Cname, Grade ｝</span><br><span class="line">属性组U上的一组函数依赖F：</span><br><span class="line">    F ＝｛ Sno → Sdept,  Sdept → Mname, (Sno, Cname) → Grade ｝</span><br><span class="line"></span><br><span class="line">存在问题：</span><br><span class="line">数据冗余太大</span><br><span class="line">更新异常（Update Anomalies）</span><br><span class="line">插入异常（Insertion Anomalies）</span><br><span class="line">删除异常（Deletion Anomalies</span><br></pre></td></tr></table></figure>
<p>把这个单一模式分成3个关系模式：<br>     S（Sno，Sdept，Sno → Sdept）;<br>     SC（Sno，Cno，Grade，（Sno，Cno） → Grade）;<br>     DEPT（Sdept，Mname，Sdept→ Mname）</p>
<p><strong>函数依赖</strong></p>
<p>依赖：Y函数依赖于X”，记作X→Y。  </p>
<p>平凡函数依赖与非平凡函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例：在关系SC(Sno, Cno, Grade)中，</span><br><span class="line">   非平凡函数依赖： (Sno, Cno) → Grade</span><br><span class="line">   平凡函数依赖：     (Sno, Cno) → Sno </span><br><span class="line">                                          (Sno, Cno) → Cno</span><br></pre></td></tr></table></figure>
<p>完全函数依赖与部分函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[例1] 中(Sno,Cno)→Grade是完全函数依赖，</span><br><span class="line">   (Sno,Cno)→Sdept是部分函数依赖</span><br><span class="line">   因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集</span><br></pre></td></tr></table></figure>

<p>传递函数依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例: 在关系Std(Sno, Sdept, Mname)中，有：</span><br><span class="line">	  Sno → Sdept，Sdept → Mname</span><br><span class="line">      Mname传递函数依赖于Sno</span><br></pre></td></tr></table></figure>

<p><strong>码</strong></p>
<p>主属性与非主属性</p>
<p>整个属性组是码，称为全码（All-key） </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[例2]</span><br><span class="line">    关系模式S(Sno,Sdept,Sage)，单个属性Sno是码，</span><br><span class="line">    SC（Sno，Cno，Grade）中，（Sno，Cno）是码</span><br><span class="line">[例3]</span><br><span class="line">       关系模式R（P，W，A）</span><br><span class="line">       P：演奏者     W：作品    A：听众</span><br><span class="line">       一个演奏者可以演奏多个作品</span><br><span class="line">       某一作品可被多个演奏者演奏</span><br><span class="line">       听众可以欣赏不同演奏者的不同作品</span><br></pre></td></tr></table></figure>

<p><strong>范式</strong></p>
<p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化 </p>
<p>1NF<br>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF,第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库但是满足第一范式的关系模式并不一定是一个好的关系模式.<br>原因：部分函数依赖于码</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/1NF.jpg" class="">

<p>2NF</p>
<p>每一个非主属性完全函数依赖于码</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/2NF.jpg" class="">

<p>3NF<br>消除传递函数依赖</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/3NF.jpg" class="">

<p>BCNF<br>1、所有非主属性对每一个码都是完全函数依赖<br>2、所有的主属性对每一个不包含它的码，也是完全函数依赖<br>3、没有任何属性完全函数依赖于非码的任何一组属性</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/BCNF.jpg" class="">

<p>多值依赖</p>
<p>4NF</p>
<img src="/MySql-Lover/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/%E5%B0%8F%E8%8A%82.jpg" class="">

<p>并不是规范化程度越高，模式就越好</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell报错🌝</title>
    <url>/Other-Lover/Powershell%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><strong>powershell不能执行脚本</strong></p>
<img src="/Other-Lover/Powershell%E6%8A%A5%E9%94%99/%E6%8A%A5%E9%94%99.jpg" class="" title="报错">



<img src="/Other-Lover/Powershell%E6%8A%A5%E9%94%99/shell.jpg" class="" title="管理员方式打开">]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 内核中断（设备树）🏊</title>
    <url>/Linux-Lover/inux-%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD%EF%BC%88%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p><strong>设备树中断信息节点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">简单总结一下与中断有关的设备树属性信息：</span><br><span class="line">①、interrupt-cells，指定中断源的信息 cells 个数。</span><br><span class="line">②、interrupt-controller，表示当前节点为中断控制器。</span><br><span class="line">③、interrupts，指定中断号，触发方式等。</span><br><span class="line">④、interrupt-parent，指定父中断，也就是中断控制器。</span><br><span class="line"></span><br><span class="line"> 获取中断号</span><br><span class="line">1、从 interupts 属性中提取到对应的设备号</span><br><span class="line">unsigned int irq_of_parse_and_map(struct device_node *dev,int index)</span><br><span class="line"></span><br><span class="line">2、GPIO 的话，可以使用 gpio_to_irq 函数来获取 gpio 对应的中断号</span><br><span class="line"> int gpio_to_irq(unsigned int gpio)</span><br></pre></td></tr></table></figure>
<p><strong>GIC控制器</strong></p>
<p>在DTS中，外设的interrupt type有两种，一种是SPI，另外一种是PPI。<br>SGI用于processor之间的通信，和外设无关。</p>
<p>（1）外设中断（Peripheral interrupt）。根据目标CPU的不同，外设的中断可以分成PPI（Private Peripheral Interrupt）和SPI（Shared Peripheral Interrupt）。PPI只能分配给一个确定的processor，而SPI可以由Distributor将中断分配给一组Processor中的一个进行处理。外设类型的中断一般通过一个interrupt request line的硬件信号线连接到中断控制器，可能是电平触发的（Level-sensitive），也可能是边缘触发的（Edge-triggered）。</p>
<p>（2）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。</p>
<p>具体的ID分配情况如下：</p>
<p>ID0<del>ID15用于SGI，ID16</del>ID31用于PPI，ID32~ID1019用于SPI。<br>PPI类型的中断会送到指定的process上，和其他的process无关。<br>SGI是通过写GICD_SGIR寄存器而触发的中断。Distributor通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode常见问题</title>
    <url>/Other-Lover/scode%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>常用扩展</strong></p>
<p>我们需要按照的插件有下面几个：<br>1)、C/C++，这个肯定是必须的。<br>2)、C/C++ Snippets，即 C/C++重用代码块。<br>3)、C/C++ Advanced Lint,即 C/C++静态检测 。<br>4)、Code Runner，即代码运行。<br>5)、Include AutoComplete，即自动头文件包含。<br>6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。<br>7)、One Dark Pro，VSCode 的主题。<br>8)、GBKtoUTF8，将 GBK 转换为 UTF8。<br>9)、ARM，即支持 ARM 汇编语法高亮显示。<br>10)、Chinese(Simplified)，即中文环境。<br>11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。<br>12)、compareit，比较插件，可以用于比较两个文件的差异。<br>13)、DeviceTree，设备树语法插件。<br>14)、TabNine，一款 AI 自动补全插件</p>
<p>15)、remote-ssh远程控制</p>
<p><strong>远程控制不能跳转命令</strong></p>
<p>修改f12键绑定的参数<br>将editorHasDefinitionProvider &amp;&amp; editorTextFocus &amp;&amp;!isInEmbeddedEditor<br>改为editor.action.revealDefinition</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-admin</title>
    <url>/Other-Lover/hexo-admin/</url>
    <content><![CDATA[<p><strong>安装npm install –save hexo-admin</strong></p>
<p><strong>打不开Cannot GET /admin</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改.config</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"></span><br><span class="line">url: https://github.com/hsm0409/hsm0409.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+gitee</title>
    <url>/Other-Lover/xo-gitee/</url>
    <content><![CDATA[<p>github网速不够快，换成gitees试试？</p>
<p><a href="https://gitee.com/hsm0409/hsm0409.git" target="_blank" rel="noopener">https://gitee.com/hsm0409/hsm0409.git</a><br>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p>如果同时部署：</p>
<p>先关联GitHub的远程库：<br>git remote rm origin<br>git remote add github <a href="mailto:git@github.com">git@github.com</a>:hsm0409/hsm0409.github.io.git<br>接着，再关联Gitee的远程库：<br>git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:hsm0409/hsm0409.git</p>
<p><a href="mailto:ssh-Tgit@github.com">ssh-Tgit@github.com</a></p>
<p><a href="mailto:ssh-Tgit@gitee.com">ssh-Tgit@gitee.com</a></p>
<p>git push github master<br>如果要推送到Gitee，使用命令：</p>
<p>git push gitee master</p>
<p>不错的参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712</a></p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+github</title>
    <url>/Other-Lover/hexo-github/</url>
    <content><![CDATA[<p>换电脑或者换系统重新部署hexo</p>
<p>ssh-keygen –t rsa -C “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>   </p>
<p>git config –global user.name “hsm0409”  </p>
<p>//有时候系统没.ssh/id_rsa.pub，输入命令ssh-keygen -o<br>//生成新的密钥</p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a>      //ssh密钥</p>
<p>yes</p>
<p> git config –global user.email “<a href="mailto:1260925116@qq.com">1260925116@qq.com</a>“</p>
<p> git config –global user.name “hsm0409”</p>
<p> 就可以了。</p>
<p> //详细参考<a href="https://blog.annieyu.com/posts/207737771.html" target="_blank" rel="noopener">https://blog.annieyu.com/posts/207737771.html</a></p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>使用PE系统重装win10QvQ</title>
    <url>/Other-Lover/%E7%94%A8PE%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85win10QvQ/</url>
    <content><![CDATA[<p><strong>1、工具：U盘+白菜PE系统</strong>   </p>
<p><strong>2、系统：win10 解压放在U盘 GHO 目录下。</strong></p>
<p><strong>3、电脑关机，开机启动按住“esc”,选择进入U盘，进入PE系统，我们可以先备份好C盘的资料到其他U盘中，然后点击C盘，还原分区，选择U盘中GHO目录下的镜像文件.gho,点击确定即可。</strong></p>
<p><strong>4、拔出U盘，重启电脑。</strong></p>
<p>(DiskGenius 数据恢复软件)</p>
]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>电容传感器</title>
    <url>/Circuit-Lover/%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>电容式传感器是把被测量的变化转换为电容量变化的一类传感器。实质上是一个具有可变参数的电容器。最常用的是平行板电容传感器和圆柱形电容传感器。可用来测量压力、力、位移、振动、液位、成份含量等。</p>
<p>①变极距型（变间隙型）：改变极板距离d0 。<br>②变面积型：改变极板相对面积S 。<br>③变介电常数型：改变介电常数ε。</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>ABCD类ip</title>
    <url>/Linux-Lover/CD%E7%B1%BBip/</url>
    <content><![CDATA[<p>A类地址：一个A类地址由一字节的网络地址和三字节的主机地址组成（网+主+主+主），网络地址的最高位必须为0（二进制即为00000000<del>01111111），即0</del>127。</p>
<p>B类地址：一个B类地址由二字节的网络地址和二字节的主机地址组成（网+网+主+主）,网络地址最高位必须为10（二进制即10000000~10111111）,即128 ~191</p>
<p>C类地址：一个C类地址由三字节的网络地址和一字节的主机地址组成（网+网+网+主），网络地址最高位必须为110（二进制即为11000000<del>11011111），即192</del>223</p>
<p>D类地址：网络—网络—-网络—-网络—主机(11100000<del>11101111)<br>224</del>240<br>224.0.0.0–240.255.255.255  组播（Multicast），这样可以节约网络资源。</p>
<p>E 类 地址属于保留地址。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编基础常用</title>
    <url>/ARM-Lover/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%B8%B8%E7%94%A8/</url>
    <content><![CDATA[<p><strong>伪操作</strong></p>
<p>.section  【段名】<br>.text代码段<br>.data数据<br>.bss未初始化<br>.rodata只读<br>.section   .textsection @定义一个数据段</p>
<p>imx6ull start.S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> SECTIONS&#123;</span><br><span class="line"> . &#x3D; 0X87800000;</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line"> start.o</span><br><span class="line"> main.o</span><br><span class="line"> *(.text)</span><br><span class="line"> &#125;</span><br><span class="line"> .rodata ALIGN(4) : &#123;*(.rodata*)&#125;</span><br><span class="line"> .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line"> __bss_start &#x3D; .;</span><br><span class="line"> .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line">__bss_end &#x3D; .;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">注：</span><br><span class="line">COMMON未初始化的全局变量</span><br><span class="line">.bss未初始化的静态变量，以及初始化为0的全局变量或静态变量</span><br><span class="line">包含data和BSS段的整个区段此时通常称为数据区。</span><br><span class="line">.bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；</span><br><span class="line">.data却需要占用，其内容由程序初始化。</span><br></pre></td></tr></table></figure>

<p>常见的伪操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.byte 定义单字节数据，比如.byte 0x12</span><br><span class="line">.short  定义双字节数据，比如.byte 0x1234。</span><br><span class="line">.long 定义一个 4 字节数如.long0x12345678。</span><br><span class="line">.equ 表达式，比如.equ num, 0x12  num&#x3D;0x12</span><br><span class="line">.align  数据字节对齐，比如：.align 4 表示 4 字节对齐</span><br><span class="line">.end  表示源文件结束</span><br><span class="line">.global  定义一个全局符号，格式为：.global symbol，比如：.global _start。</span><br></pre></td></tr></table></figure>
<p>Cortex-A7常用汇编指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、处理器内部数据传输指令</span><br><span class="line">使用处理器做的最多事情就是在处理器内部来回的传递数据，常见的操作有：</span><br><span class="line">①、将数据从一个寄存器传递到另外一个寄存器。</span><br><span class="line">MOV R1,R2</span><br><span class="line">②、将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。</span><br><span class="line">MRS R0,CPSR</span><br><span class="line">或者：MSR CPSR,R1</span><br><span class="line">③、将立即数传递到寄存器。</span><br><span class="line">MOV R1,#0X12</span><br><span class="line"></span><br><span class="line">2、储存器访问指令   RAM</span><br><span class="line">从存储器 Rn+offset 的位置读取数据存放到 Rd 中</span><br><span class="line">LDR  Rd,[Rn,#offset]    @eg:</span><br><span class="line">LDR R0,&#x3D;0X0209C004@将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1,[R0]@读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br><span class="line">将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</span><br><span class="line">STR Rd,[Rn,#offset]</span><br><span class="line">LDR R0, &#x3D;0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1, &#x3D;0X20000002 @R1 保存要写入到寄存器的值，即 R1&#x3D;0X20000002</span><br><span class="line">STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br><span class="line"></span><br><span class="line">3、压栈和出栈</span><br><span class="line">PUSH &lt;reg list&gt; 将寄存器列表存入栈中。</span><br><span class="line">POP &lt;reg list&gt;  从栈中恢复寄存器列表。</span><br><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br><span class="line">PUSH &#123;LR&#125;</span><br><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br><span class="line">第二种写法：  FD 是 Full Descending 的缩写，即满递减的意思。</span><br><span class="line">STMFD SP！   LDMFD SP!</span><br><span class="line">STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈      右边高地址</span><br><span class="line">STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br><span class="line"></span><br><span class="line">4、跳转指令</span><br><span class="line"></span><br><span class="line">B &lt;label&gt;如果跳转范围超过了+&#x2F;-2KB，可以指定，不用返回</span><br><span class="line">_start:</span><br><span class="line">ldr sp,&#x3D;0X80200000 @设置栈指针</span><br><span class="line">b main @跳转到 main 函数</span><br><span class="line"></span><br><span class="line">BL &lt;label&gt;  跳转到标号地址，并将返回地址保存在 LR 中。</span><br><span class="line">push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line">bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line">cps #0x12 @进入 IRQ 模式</span><br><span class="line">pop &#123;r0, r1&#125;</span><br><span class="line">str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br><span class="line"></span><br><span class="line">L连接寄存器</span><br><span class="line">一是用来保存子程序返回地址；二是当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。</span><br><span class="line"></span><br><span class="line">B.W&lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的跳转</span><br><span class="line">BX &lt;Rm&gt;  间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</span><br><span class="line">BLX &lt;Rm&gt;结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地</span><br><span class="line">址保存在 LR 中，切换指令集。</span><br><span class="line"></span><br><span class="line">5、算数指令</span><br><span class="line"></span><br><span class="line">ADD Rd,Rn,Rm  @ Rd&#x3D;Rn+Rm</span><br><span class="line">DD Rd, Rn, #immed @Rd &#x3D; Rn + #immed</span><br><span class="line">ADC Rd, Rn, Rm Rd &#x3D; Rn + Rm + 进位</span><br><span class="line">ADC Rd, Rn, #immed  Rd &#x3D; Rn + #immed +进位</span><br><span class="line"></span><br><span class="line">SUB Rd, Rn, Rm @Rd &#x3D; Rn – Rm</span><br><span class="line">SUB Rd, #immed  @Rd &#x3D; Rd - #immed</span><br><span class="line">SUB Rd, Rn, #immed @Rd &#x3D; Rn - #immed</span><br><span class="line">SBC Rd, Rn, #immed Rd &#x3D; Rn - #immed – 借位</span><br><span class="line">SBC Rd, Rn ,Rm  Rd &#x3D; Rn – Rm – 借位</span><br><span class="line"></span><br><span class="line">MUL Rd, Rn, Rm    Rd &#x3D; Rn * Rm  乘法(32 位)</span><br><span class="line"></span><br><span class="line">UDIV Rd, Rn, Rm   Rd &#x3D; Rn &#x2F; Rm  无符号除法</span><br><span class="line">SDIV Rd, Rn, Rm   Rd &#x3D; Rn &#x2F; Rm  有符号除法</span><br><span class="line"></span><br><span class="line">6、逻辑指令</span><br><span class="line"></span><br><span class="line">AND Rd, Rn    	@  Rd &#x3D; Rd &amp;Rn</span><br><span class="line">AND Rd, Rn, #immed 	 @Rd &#x3D; Rn &amp;#immed</span><br><span class="line">AND Rd, Rn, Rm	 @Rd &#x3D; Rn &amp; Rm</span><br><span class="line"></span><br><span class="line">ORR Rd, Rn	 @Rd &#x3D; Rd | Rn </span><br><span class="line">ORR Rd, Rn, #immed	 @Rd &#x3D; Rn | #immed</span><br><span class="line">ORR Rd, Rn, Rm 	 @Rd &#x3D; Rn | Rm</span><br><span class="line"></span><br><span class="line">BIC Rd, Rn 	@Rd &#x3D; Rd &amp; (~Rn)   位清除  </span><br><span class="line">BIC Rd, Rn, #immed	 @Rd &#x3D; Rn &amp; (~#immed)</span><br><span class="line">BIC Rd, Rn , Rm 	 @Rd &#x3D; Rn &amp; (~Rm)</span><br><span class="line"></span><br><span class="line">ORN Rd, Rn, #immed    @Rd &#x3D; Rn | (#immed) 按位或非</span><br><span class="line">ORN Rd, Rn, Rm     Rd &#x3D; Rn | (Rm)</span><br><span class="line"></span><br><span class="line">EOR Rd, Rn               Rd &#x3D; Rd ^ Rn按位异或 </span><br><span class="line">EOR Rd, Rn, #immed        Rd &#x3D; Rn ^ #immed</span><br><span class="line">EOR Rd, Rn, Rm            Rd &#x3D; Rn ^ Rm</span><br></pre></td></tr></table></figure>

<p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。<br>MRC 就是读 CP15 寄存器， MCR 就是写 CP15 寄存器，MCR 指令格式如下：</p>
<p>cps   #0x13   模式切换为SVC<br>adr<br>可实际上adr是将基于PC相对偏移的地址值或基于寄存器相对地址值读取的为指令,<br>而ldr用于加载32为立即数或一个地址到指定的寄存器中。</p>
<p><strong>隔离指令</strong><br>DMB<br>数据存储器隔离。 仅当所有在它前面的存储器访问操作都执行完毕后，才提交在它后面的存储器访问操作。<br>DSB<br>数据同步隔离。 仅当所有在它前面的存储器访问操作都执行完毕后，才执行在它后面的指令<br>ISB<br>指令同步隔离。它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。</p>
<p>题外话：<br>今天,差不多所有编程都是基于高级语言的,所以,大程序很少采用这里介绍的汇编语言编程。然而,有时可能需要用汇编语言开发小的软件组件,以达到关键应用所需”的最佳性能。因此,了解如何编写汇编代码是很有用处的。</p>
]]></content>
      <categories>
        <category>ARM Lover</category>
      </categories>
      <tags>
        <tag>ARM汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile小记</title>
    <url>/Makefile-Lover/Makefile%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>学习Makefie,最重要的是搞清楚<code>目标和依赖</code>!!!<br>自动变量</p>
<img src="/Makefile-Lover/Makefile%E5%B0%8F%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F.jpg" class="" title="自动化变量">



<p>命令前加@即为不显示<br>make -s  不输出<br>V=1“来实现完整的命令输出<br>.PHONY 意思表示 clean 是一个“伪目标”<br>Makefile 特定文件命名 make -f Make.Linux</p>
<p>在linux中和编译有关的配置文件有：<br>makefile:<br>Kconfig:<br>.config:全局的配置文件，由它决定makefile来编译哪些文件，一般是自动生成。</p>
<p>执行make menuconfig就会读取源码目录下所有Kconfig内容，并生成界面中的选项菜单</p>
]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile调试参考</title>
    <url>/Makefile-Lover/Makefile%E8%B0%83%E8%AF%95%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>led.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">TARGET         ?= uart</span><br><span class="line"></span><br><span class="line">CC            := $(CROSS_COMPILE)gcc</span><br><span class="line">LD            := $(CROSS_COMPILE)ld</span><br><span class="line">OBJCOPY       := $(CROSS_COMPILE)objcopy</span><br><span class="line">OBJDUMP       := $(CROSS_COMPILE)objdump</span><br><span class="line"></span><br><span class="line">LIBPATH      := -lgcc -L /usr/<span class="built_in">local</span>/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCUDIRS     := stdio/include\</span><br><span class="line">				imx6ul \</span><br><span class="line">			    bsp/clk\</span><br><span class="line">				bsp/delay\</span><br><span class="line">				bsp/beep\</span><br><span class="line">				bsp/key\</span><br><span class="line">				bsp/gpio\</span><br><span class="line">				bsp/int\</span><br><span class="line">				bsp/led\</span><br><span class="line">				bsp/<span class="built_in">exit</span>\</span><br><span class="line">				bsp/epit\</span><br><span class="line">				bsp/keyfilter\</span><br><span class="line">				bsp/uart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SRCUDIRS     := stdio/lib\</span><br><span class="line">				project\</span><br><span class="line">			    bsp/clk\</span><br><span class="line">				bsp/delay\</span><br><span class="line">				bsp/beep\</span><br><span class="line">				bsp/key\</span><br><span class="line">				bsp/gpio\</span><br><span class="line">				bsp/int\</span><br><span class="line">				bsp/led\</span><br><span class="line">				bsp/<span class="built_in">exit</span>\</span><br><span class="line">				bsp/epit\</span><br><span class="line">				bsp/keyfilter\</span><br><span class="line">				bsp/uart</span><br><span class="line"></span><br><span class="line">INCLUDE       := $(patsubst %, -I % , $(INCUDIRS))</span><br><span class="line"></span><br><span class="line">SFILES        := $(foreach dir,$(SRCUDIRS),$(wildcard $(dir)/*.S))</span><br><span class="line">CFILES        := $(foreach dir,$(SRCUDIRS),$(wildcard $(dir)/*.c)) </span><br><span class="line"></span><br><span class="line">SFILESNDIR        := $(notdir $(SFILES))</span><br><span class="line">CFILESNDIR        := $(notdir $(CFILES))</span><br><span class="line"></span><br><span class="line">SOBJS              := $(patsubst %,obj/%,$(SFILESNDIR:.S=.o))</span><br><span class="line">COBJS             := $(patsubst %,obj/%,$(CFILESNDIR:.c=.o))</span><br><span class="line"></span><br><span class="line">OBJS              := $(SOBJS) $(COBJS)</span><br><span class="line"></span><br><span class="line">VPATH             := $(SRCUDIRS)</span><br><span class="line">.PHONY:clean</span><br><span class="line"></span><br><span class="line">$(TARGET).bin : $(OBJS)</span><br><span class="line">	$(LD) -Timx6u.lds -o $(TARGET).elf $^ $(LIBPATH)</span><br><span class="line">	$(OBJCOPY) -O binary -S $(TARGET).elf <span class="variable">$@</span></span><br><span class="line">	$(OBJDUMP) -D -m arm $(TARGET).elf &gt;$(TARGET).dis</span><br><span class="line"></span><br><span class="line">$(COBJS):obj/%.o:%.c</span><br><span class="line">	$(CC) -Wall -Wa,-mimplicit-it=thumb -nostdlib -fno-builtin -c -O2 $(INCLUDE)-o <span class="variable">$@</span> $&lt;</span><br><span class="line">$(SOBJS):obj/%.o:%.S</span><br><span class="line">	$(CC) -Wall -nostdlib -fno-builtin -c -O2 $(INCLUDE)-o <span class="variable">$@</span> $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(TARGET).elf $(TARGET).bin $(TARGET).dis $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile Lover</category>
      </categories>
      <tags>
        <tag>Makefile基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中断</title>
    <url>/Linux-Lover/Linux-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p>Linux 内核中也提供了大量的中断相关的 API 函数</p>
<p>1、知道中断号<br>2 、申请函数request_irq<br>3 、free_irq 释放函数<br>4、request_irq 函数申请中断的时候需要设置中断处理函数<br>5、中断使能与禁止函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使能或者禁止某一个中断</span><br><span class="line"></span><br><span class="line">void enable_irq(unsigned int irq)</span><br><span class="line">void disable_irq(unsigned int irq)-&gt;void disable_irq_nosync(unsigned int irq)</span><br><span class="line"></span><br><span class="line">使能或者禁止当前处理器中断系统</span><br><span class="line">local_irq_enable()</span><br><span class="line">local_irq_disable()</span><br><span class="line">推荐：</span><br><span class="line">local_irq_save(flags) </span><br><span class="line">local_irq_restore(flags)</span><br></pre></td></tr></table></figure>
<p><strong>上半部与下半部</strong></p>
<p>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可<br>以放在上半部完成。<br>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部<br>去执行，这样中断处理函数就会快进快出</p>
<p>哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断?<br>正点原子参考：<br>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。<br>②、如果要处理的任务对时间敏感，可以放到上半部。<br>③、如果要处理的任务与硬件有关，可以放到上半部<br>④、除了上述三点以外的其他任务，优先考虑放到下半部。</p>
<p><strong>Linux内核下半部中断机制</strong></p>
<p>buttom half -&gt;软中断和 tasklet </p>
<p><strong>软中断</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">示例代码 51.1.2.1 softirq_action 结构体</span><br><span class="line">433 struct softirq_action</span><br><span class="line">434 &#123;</span><br><span class="line">435 void (*action)(struct softirq_action *);</span><br><span class="line">436 &#125;;</span><br><span class="line">在 kernel/softirq.c 文件中一共定义了 10 个软中断，如下所示：</span><br><span class="line">示例代码 51.1.2.2 softirq_vec 数组</span><br><span class="line">static struct softirq_action softirq_vec[NR_SOFTIRQS];</span><br><span class="line">NR_SOFTIRQS 是枚举类型，定义在文件 include/linux/interrupt.h 中，定义如下：</span><br><span class="line">示例代码 51.1.2.3 softirq_vec 数组</span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">HI_SOFTIRQ=0, /* 高优先级软中断 */</span><br><span class="line">TIMER_SOFTIRQ, /* 定时器软中断 */</span><br><span class="line">NET_TX_SOFTIRQ, /* 网络数据发送软中断 */</span><br><span class="line">NET_RX_SOFTIRQ, /* 网络数据接收软中断 */</span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ, /* tasklet 软中断 */</span><br><span class="line">SCHED_SOFTIRQ, /* 调度软中断 */</span><br><span class="line">HRTIMER_SOFTIRQ, /* 高精度定时器软中断  */</span><br><span class="line">RCU_SOFTIRQ, /* RCU 软中断  */</span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open_softirq 函数注册对应的软中断处理函数</span><br><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br><span class="line"></span><br><span class="line">例：open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line"></span><br><span class="line">raise_softirq 调用函数触发</span><br><span class="line">void raise_softirq(unsigned int nr)</span><br><span class="line"></span><br><span class="line">注意:软中断必须在编译的时候静态注册  kernel/softirq.c</span><br></pre></td></tr></table></figure>

<p><strong>tasklet</strong></p>
<p>前言：tasklet 是利用软中断来实现的另t外一种下半部机制，在软中断和 tasklet 之间，建议使用 tasklet</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct tasklet_struct</span><br><span class="line">&#123;</span><br><span class="line">struct tasklet_struct *next; /* 下一个 tasklet */</span><br><span class="line"> unsigned long state; /* tasklet 状态 */</span><br><span class="line"> atomic_t count; /* 计数器，记录对 tasklet 的引用数 */</span><br><span class="line">void (*func)(unsigned long); /* tasklet  执行的函数 */</span><br><span class="line"> unsigned long data; /* 函数 func 的参数 */</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">tasklet_init 函数初始化</span><br><span class="line"></span><br><span class="line">void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long),unsigned long data)</span><br><span class="line"></span><br><span class="line">也可以初始-》DECLARE_TASKLET(name, func, data)</span><br><span class="line"></span><br><span class="line">void tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line"></span><br><span class="line">t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name tasklet 的参考使用示例如下所示</span><br><span class="line"></span><br><span class="line">/* 定义 taselet */</span><br><span class="line">struct tasklet_struct testtasklet;</span><br><span class="line"></span><br><span class="line">void testtasklet_func(unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">/* tasklet 具体处理内容 */</span><br><span class="line">&#125;</span><br><span class="line">/* 中断处理函数 */</span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 调度 tasklet */</span><br><span class="line">tasklet_schedule(&amp;testtasklet);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">/* 驱动入口函数 */</span><br><span class="line">static int __init xxxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 初始化 tasklet */</span><br><span class="line">tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line">/* 注册中断处理函数 */</span><br><span class="line">request_irq(xxx_irq, test_handler, 0, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作队列</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">工作队列是另外一种下半部执行方式：推后的工作可以睡眠</span><br><span class="line">表示一个工作结构函数</span><br><span class="line">struct work_struct &#123;</span><br><span class="line">atomic_long_t data;</span><br><span class="line">struct list_head entry;</span><br><span class="line">work_func_t func; /* 工作队列处理函数 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">工作组织成工作队列结构</span><br><span class="line">struct workqueue_struct &#123;</span><br><span class="line">struct list_head pwqs;</span><br><span class="line">struct list_head list;</span><br><span class="line">struct mutex mutex;</span><br><span class="line">int work_color;</span><br><span class="line">int flush_color;</span><br><span class="line">atomic_t nr_pwqs_to_flush;</span><br><span class="line">struct wq_flusher *first_flusher;</span><br><span class="line">struct list_head flusher_queue;</span><br><span class="line">struct list_head flusher_overflow;</span><br><span class="line">struct list_head maydays;</span><br><span class="line">struct worker *rescuer;</span><br><span class="line">int nr_drainers;</span><br><span class="line">int saved_max_active;</span><br><span class="line">struct workqueue_attrs *unbound_attrs;</span><br><span class="line">struct pool_workqueue *dfl_pwq;</span><br><span class="line">char name[WQ_NAME_LEN];</span><br><span class="line">struct rcu_head rcu;</span><br><span class="line">unsigned int flags ____cacheline_aligned;</span><br><span class="line">struct pool_workqueue __percpu *cpu_pwqs;</span><br><span class="line">struct pool_workqueue __rcu *numa_pwq_tbl[];</span><br><span class="line">&#125;；</span><br><span class="line">LLinux 内核使用工作者线程(worker thred)来处理工作队列中的各个工作结构</span><br><span class="line">struct worker &#123;</span><br><span class="line">union &#123;</span><br><span class="line">struct list_head entry;</span><br><span class="line">struct hlist_node hentry;</span><br><span class="line">&#125;;</span><br><span class="line">struct work_struct *current_work;</span><br><span class="line">work_func_t current_func;</span><br><span class="line">struct pool_workqueue *current_pwq;</span><br><span class="line">bool desc_valid;</span><br><span class="line">struct list_head scheduled;</span><br><span class="line">struct task_struct *task;</span><br><span class="line">struct worker_pool *pool;</span><br><span class="line">struct list_head node;</span><br><span class="line">unsigned long last_active;</span><br><span class="line">unsigned int flags;</span><br><span class="line">int id;</span><br><span class="line">char desc[WORKER_DESC_LEN];</span><br><span class="line">struct workqueue_struct *rescue_wq;</span><br><span class="line">&#125;;</span><br><span class="line">总结：每个 worker 都有一个工作队列</span><br><span class="line">和 tasklet 一样，工作也是需要调度才能运</span><br><span class="line"></span><br><span class="line">例子</span><br><span class="line">/* 定义工作(work) */</span><br><span class="line">struct work_struct testwork;</span><br><span class="line">void testwork_func_t(struct work_struct *work);</span><br><span class="line">&#123;</span><br><span class="line">/* work 具体处理内容 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 调度 work */</span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">static int __init xxxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">/* 初始化 work */</span><br><span class="line">INIT_WORK(&amp;testwork, testwork_func_t);</span><br><span class="line">/* 注册中断处理函数 */</span><br><span class="line">request_irq(xxx_irq, test_handler, 0, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>c和c++中struct的主要区别</title>
    <url>/C-C-Lover/c%E5%92%8Cc-%E4%B8%ADstruct%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。</p>
<p>c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下函数常见报错随记</title>
    <url>/Linux-Lover/nux%E4%B8%8B%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>gets(str)<br>函数报错：warning: the ‘gets’ function is dangerous and should not be used.<br>原因：<br>注意，gets的行为与fgets使用stdin作为参数时的行为不完全相同:首先，在使用fgets时，结束换行字符不包含在gets中，而在使用fgets时，它包含在fgets中。其次，gets不允许您指定要读取的字符数限制，因此必须小心使用str指向的数组的大小，以避免缓冲区溢出。<br>解决办法：采用<br>fgets(cmd,100,stdin);//100为size</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ioctl函数</title>
    <url>/Linux-Lover/ctl%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>ioctl 系统调用主要用于增加系统调用的硬件控制能力，它可以构建自己的命令，也能接受参数.<br>应用程序 ioctl 函数<br>int ioctl (int fd, unsigned long cmd, arg)<br>fd 是被打开的设备文件， cmd 是操作设备的命令，“ …”代表可变数目的参数表，通常用 char *argp 来定义，如果 cmd 命令不需要参数，则传入 NULL 即可。</p>
<p>内核空间 iotcl 函数<br>int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);</p>
<p>ioctl 操作与硬件平台相关，使用 ioctl 的驱动需要包含&lt;linux/ioctl.h&gt;文件。每个 ioctl 命令cmd实际上都是一个 32 位整型数，各字段和含义如下表所示。<br>已经被使用的幻数列表详见内核源码目录Documentation/ioctl/ioctl-number.txt文件。</p>
<p>|一般形式<br>|-|-|<br>|_IO(type,nr) 构造无参数的命令编号<br>|_IOW(type,nr,size) 构造往驱动写入数据的命令编号<br>|_IOR(type,nr,size) 构造从驱动中读取数据的命令编号<br>|_IOWR(type,nr,size)构造双向传输的命令编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach/map.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"></span><br><span class="line">/*0XFE---幻数，1.2.3.---功能号*/</span><br><span class="line">/*IOctrl 命令*/</span><br><span class="line"><span class="comment">#define CLOSE_CMD (_IO(0XEF, 0x1)) /* 关闭定时器 */</span></span><br><span class="line"><span class="comment">#define OPEN_CMD (_IO(0XEF, 0x2)) /* 打开定时器 */</span></span><br><span class="line"><span class="comment">#define SETPERIOD_CMD (_IO(0XEF, 0x3)) /* 设置定时器周期命令 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TIMER_NAME  "timer"</span></span><br><span class="line"><span class="comment">#define TIMER_CNT  1</span></span><br><span class="line">struct timer_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid;</span><br><span class="line"></span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct device_node *nd;</span><br><span class="line">    struct class * class;</span><br><span class="line">    struct device * device;</span><br><span class="line"></span><br><span class="line">    int led_gpio;</span><br><span class="line">    int timeperiod;</span><br><span class="line">    struct timer_list timer;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct timer_dev timer;</span><br><span class="line"></span><br><span class="line">static int led_init (struct timer_dev * dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    dev-&gt;nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;nd == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;led_gpio = of_get_named_gpio(dev-&gt;nd,<span class="string">"led-gpios"</span>,0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;led_gpio &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't get led \r\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*申请注册IO*/</span><br><span class="line"></span><br><span class="line">    gpio_request(dev-&gt;led_gpio,<span class="string">"led"</span>);</span><br><span class="line"></span><br><span class="line">    ret = gpio_direction_output(dev-&gt;led_gpio,1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"can't set gpion\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int timer_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;timer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static long timer_unlocked_ioctl(struct file *filp, unsigned int cmd,</span><br><span class="line">						unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        struct timer_dev *dev = (struct timer_dev *)filp-&gt;private_data;</span><br><span class="line">        int ret  = 0;</span><br><span class="line">        int timeperiod ;</span><br><span class="line">        unsigned long flags;</span><br><span class="line">        switch (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CLOSE_CMD:</span><br><span class="line">                del_timer(&amp;dev-&gt;timer);</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> OPEN_CMD:</span><br><span class="line">                spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">                timeperiod = dev-&gt;timeperiod;</span><br><span class="line">                spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line">                mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">            <span class="built_in">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> SETPERIOD_CMD:</span><br><span class="line">            dev-&gt;timeperiod = arg;</span><br><span class="line">            mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg));</span><br><span class="line">            <span class="built_in">break</span> ;     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int timer_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct file_operations timer_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">    .open  = timer_open ,</span><br><span class="line">    .release = timer_release,</span><br><span class="line">	.unlocked_ioctl	= timer_unlocked_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void  timer_function(unsigned long arg )</span><br><span class="line">&#123;</span><br><span class="line">    struct timer_dev *dev = (struct timer_dev*)arg;</span><br><span class="line">    static int sta = 1 ;</span><br><span class="line">    int timeperiod;</span><br><span class="line">     unsigned long flags;</span><br><span class="line">    sta = !sta ;</span><br><span class="line">    gpio_set_value(dev-&gt;led_gpio,sta);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     spin_lock_irqsave(&amp;dev-&gt;lock,flags);</span><br><span class="line">     timeperiod = dev-&gt;timeperiod;</span><br><span class="line">     spin_unlock_irqrestore(&amp;dev-&gt;lock,flags);</span><br><span class="line"></span><br><span class="line">   mod_timer(&amp;dev-&gt;timer,jiffies+msecs_to_jiffies(timeperiod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init timer_init(void )</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    </span><br><span class="line">    spin_lock_init(&amp;timer.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer.major)</span><br><span class="line">    &#123;</span><br><span class="line">    timer.devid = MKDEV(timer.devid,0);</span><br><span class="line">    register_chrdev_region(timer.devid,TIMER_CNT,TIMER_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;timer.devid, 0, TIMER_CNT,TIMER_NAME);</span><br><span class="line">        timer.major = MAJOR(timer.devid);</span><br><span class="line">        timer.minor = MINOR(timer.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    timer.cdev.owner = THIS_MODULE ;</span><br><span class="line">	cdev_init(&amp;timer.cdev, &amp;timer_fops);</span><br><span class="line">    cdev_add(&amp;timer.cdev, timer.devid,TIMER_CNT);</span><br><span class="line">	</span><br><span class="line">    /*自动设备节点*/</span><br><span class="line">    timer.class = class_create(THIS_MODULE, TIMER_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.class))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.class);</span><br><span class="line"></span><br><span class="line">    timer.device = device_create(timer.class, NULL, timer.devid, NULL, TIMER_NAME);</span><br><span class="line">				  </span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(timer.device))</span><br><span class="line">		<span class="built_in">return</span> PTR_ERR(timer.device);</span><br><span class="line"></span><br><span class="line">        ret  = led_init(&amp;timer);</span><br><span class="line">        <span class="keyword">if</span>(ret  &lt;  0)</span><br><span class="line">        &#123;</span><br><span class="line">            goto fail_ledinit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    init_timer(&amp;timer.timer);</span><br><span class="line">    timer.timer.function = timer_function;</span><br><span class="line">    timer.timer.data = (unsigned long ) &amp; timer;</span><br><span class="line">    timer.timer.expires = jiffies + msecs_to_jiffies(5000);/*500ms*/</span><br><span class="line">    add_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0 ;</span><br><span class="line"></span><br><span class="line">    fail_ledinit:</span><br><span class="line">    <span class="built_in">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit timer_exit(void )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    gpio_set_value(timer.led_gpio,1);</span><br><span class="line">    del_timer(&amp;timer.timer);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;timer.cdev);</span><br><span class="line">    unregister_chrdev_region(timer.devid,TIMER_CNT);</span><br><span class="line">    device_destroy(timer.class,timer.devid);</span><br><span class="line">    class_destroy(timer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ioctl(fd,cmd,arg);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>电感式传感器</title>
    <url>/Circuit-Lover/%E7%94%B5%E6%84%9F%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>电感式传感器是利用被测量的变化引起线圈自感或互感系数的变化，从而导致线圈电感量改变这一物理现象来实现测量的。因此根据转换原理，电感式传感器可以分为自感式和互感式两大类。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 电感式传感器与其它传感器相比，具有以下优点：</span><br><span class="line"> 1) 结构简单，工作可靠，寿命长；</span><br><span class="line"> 2) 灵敏度好、分辨率高。能测量0.1μm甚至更小的机械位移，能感受0.1角秒的微小角位移；</span><br><span class="line"> 3) 重复性好，线性度优良。在一定位移范围 (最小几十微米，最大可达数十至数百毫米) 内，输出线性度可达±0.1%，且比较稳定。</span><br><span class="line"> 4) 输出信号强。电压灵敏度一般可达数百毫伏每毫米，因此，有利于信号的传输和放大。</span><br><span class="line"></span><br><span class="line">主要缺点：</span><br><span class="line"> 1）存在零点残余电压；</span><br><span class="line"> 2）灵敏度、线性度和测量范围相互制约；</span><br><span class="line"> 3）传感器自身频率响应低，不适用于快速动态测量。</span><br></pre></td></tr></table></figure></p>
<p>自感：闭磁路型、开磁路型</p>
<p>互感：差动变压器、涡流式</p>
<img src="/Circuit-Lover/%E7%94%B5%E6%84%9F%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="">]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核定时器</title>
    <url>/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p><strong>节拍率</strong><br>中断周期性产生的频率就是系统频率，<br>也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz<br>高节拍率和低节<br>拍率的优缺点：<br>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。<br>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz的系统节拍率相比，中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率，本教程我们全部采用默认的 100Hz 系统节拍率。<br>方法一：make menuconfig<br>-&gt; Kernel Features<br>-&gt; Timer frequency (<choice> [=y])<br>方法二： param.h文件 # define USER_HZ    100    </p>
<p><strong>节拍数 jiffies</strong></p>
<p>extern u64 __jiffy_data jiffies_64; /<em>64系统</em>/<br>extern unsigned long volatile __jiffy_data jiffies;/<em>32系统</em>/</p>
<p>不管是 32 位还是 64 位的 jiffies，都有溢出的风险<br>假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 为的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。</p>
<p> HZ 表示一秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies/HZ 就<br>是系统运行时间，单位为秒。</p>
<img src="/uncategorized/ux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E8%8A%82%E6%8B%8D%E5%87%BD%E6%95%B0.jpg" class="">


<p>timer.h总结构体 timer_list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">struct list_head entry;</span><br><span class="line">unsigned long expires; /* 定时器超时时间，单位是节拍数 */</span><br><span class="line">struct tvec_base *base;</span><br><span class="line">void (*<span class="keyword">function</span>)(unsigned long); /* 定时处理函数 */</span><br><span class="line">unsigned long data; /* 要传递给 <span class="keyword">function</span> 函数的参数 */</span><br><span class="line">int slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct timer_list timer; /* 定义定时器 */</span><br><span class="line">/* 定时器回调函数 */</span><br><span class="line"> void <span class="keyword">function</span>(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">* 定时器处理代码</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* 如果需要定时器周期性运行的话就使用 mod_timer</span><br><span class="line"> * 函数重新设置超时值并且启动定时器。</span><br><span class="line"> */</span><br><span class="line"> mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(2000));</span><br><span class="line"> &#125;</span><br><span class="line"> /* 初始化函数 */</span><br><span class="line"> void init(void)</span><br><span class="line"> &#123;</span><br><span class="line"> init_timer(&amp;timer); /* 初始化定时器 */</span><br><span class="line"></span><br><span class="line"> timer.function = <span class="keyword">function</span>; /* 设置定时处理函数 */</span><br><span class="line"> timer.expires=jffies + msecs_to_jiffies(2000);/* 超时时间 2 秒 */</span><br><span class="line"> timer.data = (unsigned long)&amp;dev; /* 将设备结构体作为参数 */</span><br><span class="line"></span><br><span class="line">add_timer(&amp;timer); /* 启动定时器 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /* 退出函数 */</span><br><span class="line"> void <span class="built_in">exit</span>(void)</span><br><span class="line"> &#123;</span><br><span class="line"> del_timer(&amp;timer); /* 删除定时器 */</span><br><span class="line"> /* 或者使用 */</span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">参考正点原子</span><br></pre></td></tr></table></figure>
<p><strong>纳秒、微秒和毫秒延时函数</strong><br>void ndelay(unsigned long nsecs)<br>void udelay(unsigned long usecs)<br>void mdelay(unsigned long mseces)</p>
]]></content>
  </entry>
  <entry>
    <title>Uboot常用命令</title>
    <url>/Linux-Lover/oot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>2.1、help命令</strong></p>
<p>查看某一个命令帮助信息，？命令名</p>
<p><strong>2.2、信息查询</strong></p>
<p>1、bdinfo 板子信息<br>2、printenv命令 重要</p>
<p><strong>2.3、setenv命令</strong></p>
<p>设置环境变量，也可以自定义环境变量，也可以删除环境变量<br>setenv xx = 空<br><strong>2.4、saveenv命令 重点</strong><br> 保存环境变量。</p>
<p> <strong>2.5、内存操作命令</strong></p>
<p> （.b 一个字节,.w两个字节，.l四个字节）<br>1、md命令   显示<br>2、nm命令  写入<br>3、mm命令  持续写入<br>4、mw命令   填充写入 mw.l 0a0a0a0a 10(0x10即为16个)<br>5、cp命令   复制<br>6、cmp命令   只输出一样与否</p>
<p><strong>2.8、网络操作命令</strong><br>网线插如到ENET2上，保证开发板和电脑处于同一个网段内。</p>
<p>1、ping命令 重点</p>
<p>2、dhcp命令</p>
<p>3、nfs命令 重点</p>
<p>4、tftp命令 重点</p>
<p><strong>2.9 EMMC/SD卡操作命</strong></p>
<p>1、mmc命令</p>
<p>2、mmc info命令</p>
<p>3、mmc rescan命令</p>
<p>4、mmc list命令</p>
<p>5、mmc dev命令</p>
<p>6、mmc part命令</p>
<p>7、mmc read命令</p>
<p>8、mmc write命令</p>
<p>9、mmc erase命令最好不要使用！！</p>
<p><strong>2.10 FAT格式文件系统操作命令</strong></p>
<p> 对于I.MX6U来说，SD/EMMC分为三个分区：<br>第一个：存放uboot<br>第二个:存放Linux zImage，.dtb。FAT<br>第三个：系统的根文件系统，EXT4</p>
<p>1、fatinfo命令</p>
<p>2、fatls命令</p>
<p>3、fstype命令</p>
<p>4、fatload命令    命令用于将指定的文件读取到 DRAM 中</p>
<p>5、fatwrite命令     命令用于将 DRAM 中的数据写入到 MMC 设备中</p>
<p>fatwrite mmc 1:1 80800000 zImage 0x5c2720</p>
<p><strong>2.11 EXT格式文件系统操作命令</strong></p>
<p>1、ext4ls命令(略)</p>
<p>2.13 BOOT操作命令</p>
<p>1、booz命令<br>要启动Linux必须将zImage，dtb放到DRAM。</p>
<p>2、bootm命令</p>
<p>3、boot命令</p>
<p>2.14 其他命令</p>
<p>1、reset命令</p>
<p>2、go命令</p>
<p>3、run命令</p>
<p>setenv mybooyemmc</p>
<p>run mybootemmc</p>
<p>4、mtest命令</p>
<h4 id="IMX6ULL-我的常用小记"><a href="#IMX6ULL-我的常用小记" class="headerlink" title="IMX6ULL 我的常用小记"></a>IMX6ULL 我的常用小记</h4><p><strong>挂载打不开？</strong><br>1、先ping下网络，然后再ubuntu下ifconfig 检查是否存在。<br>2、局域网络<br>3、文件的损坏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bootcmd 的 默 认 值 就 是 CONFIG_BOOTCOMMAND </span><br><span class="line">bootargs 的 默 认 值 就 是CONFIG_BOOTARGS</span><br><span class="line"></span><br><span class="line">4.1 从EMMC启动</span><br><span class="line"></span><br><span class="line">1、首先查看EMMC里面是否有系统，linux镜像zImage和.dtb文件。先将当前设备切换到EMMC：</span><br><span class="line"></span><br><span class="line">mmc dev 1     &#x2F;&#x2F;切换到EMMC  mmc dev 0 SD 卡</span><br><span class="line"></span><br><span class="line">fatls mmc 1:1  &#x2F;&#x2F;查看EMMC分区1里面的文件</span><br><span class="line">fatload mmc 1:1 80800000 zImage &#x2F;&#x2F;将zimage下载到DDR的0x80800000处</span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;将dtb读取到0X83000000</span><br><span class="line">bootz 80800000 – 83000000 &#x2F;&#x2F;启动内核</span><br><span class="line"></span><br><span class="line">如果内核启动成功，说明uboot支持emmc启动，验证成功。</span><br><span class="line"></span><br><span class="line">4.2 从网络启动</span><br><span class="line"></span><br><span class="line"> tftp 80800000 zImage         &#x2F;&#x2F;从tftp服务器下载zimage</span><br><span class="line"> tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;从tftp服务器下载.dtb     </span><br><span class="line"> bootz 80800000 – 83000000 &#x2F;&#x2F;启动系统</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;系统烧写</span><br><span class="line">tftp   确保开启！！！！不要从外不复制粘贴，会乱码</span><br><span class="line"></span><br><span class="line">setenv bootcmd  &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-ming-emmc.dtb;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;setenv bootcmd  &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb;bootz 80800000 - 83000000;&#39;</span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">tftp 80800000 zImage</span><br><span class="line"></span><br><span class="line">tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 80800000 zImage</span><br><span class="line"></span><br><span class="line">fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line"></span><br><span class="line">bootz 80800000 - 83000000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#39;tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dt;bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">saveenv</span><br><span class="line"></span><br><span class="line">boot</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">tftp 87800000 uart.bin</span><br><span class="line"></span><br><span class="line">go 87800000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">grep -nr  xxxx</span><br><span class="line"></span><br><span class="line">查找当前目录下包含关键字“NEON”的所有文件，并列出行号。</span><br><span class="line"></span><br><span class="line">QAQ--------&#x2F;修改bootargs进入根系统&#x2F;----------</span><br><span class="line"></span><br><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.0.128:&#x2F;home&#x2F;ming&#x2F;linux&#x2F;nfs&#x2F;rootfs ip&#x3D;192.168.0.50:192.168.0.128:192.168.0.1:255.255.255.0::eth0:off&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buildrootfs 根文件系统</span><br><span class="line">setenv bootargs &#39;console&#x3D;tty1 console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.0.128:&#x2F;home&#x2F;ming&#x2F;linux&#x2F;nfs&#x2F;rootfs rw ip&#x3D;192.168.0.50:192.168.0.128:192.168.0.1:255.255.255.0::eth0:off&#39;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统根目录空间不足</title>
    <url>/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/1.jpg" class="">


<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/2.jpg" class="">





<img src="/Linux-Lover/ubuntu%E7%B3%BB%E7%BB%9F%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/4.jpg" class="">

<p>参考<br><a href="https://blog.csdn.net/daemon_2017/article/details/80660372" target="_blank" rel="noopener">https://blog.csdn.net/daemon_2017/article/details/80660372</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库完整性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<p><strong>数据库的完整性</strong></p>
<p>数据库的正确性和相容性。</p>
<p>注：数据的完整性和安全性是两个不同概念<br>数据的完整性<br>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据<br>防范对象：不合语义的、不正确的数据<br>数据的安全性<br>保护数据库防止恶意的破坏和非法的存取<br>防范对象：非法用户和非法操作</p>
<p>为维护数据库的完整性，DBMS必须：<br>1.提供定义完整性约束条件的机制<br>2.提供完整性检查的方法<br>3.违约处理</p>
<p><strong>实体完整性</strong></p>
<p>定义为列级约束条件     (Sno  CHAR(9)  PRIMARY KEY<br>定义为表级约束条件     PRIMARY KEY (Sno)</p>
<p><strong>参照完整性</strong></p>
<p> FOREIGN KEY (Cno) REFERENCES Course(Cno)    </p>
<p><strong>用户定义的完整性</strong></p>
<p>列值非空（NOT NULL）<br>列值唯一（UNIQUE）<br>检查列值是否满足一个布尔表达式（CHECK）<br> CHECK (Ssex=’女’ OR Sname NOT LIKE ‘Ms.%’)</p>
<p><em>_完整性约束命名字句</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONSTRAINT &lt;完整性约束条件名&gt;</span><br><span class="line">［PRIMARY KEY短语</span><br><span class="line">   |FOREIGN KEY短语</span><br><span class="line">   |CHECK短语］</span><br><span class="line"></span><br><span class="line">可以先删除原来的约束条件，再增加新的约束条件</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999)，</span><br></pre></td></tr></table></figure>
<p><strong>域中的完整性限制</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">［例15］建立一个性别域GenderDomain，并对其中的限制命名</span><br><span class="line">           CREATE DOMAIN GenderDomain CHAR(2)</span><br><span class="line">           CONSTRAINT GD CHECK ( VALUE IN (<span class="string">'男'</span>，<span class="string">'女'</span>) );</span><br><span class="line"></span><br><span class="line">在域GenderDomain上增加限制条件GDD。</span><br><span class="line">          ALTER  DOMAIN  GenderDomain  </span><br><span class="line">         ADD CONSTRAINT GDD CHECK (VALUE IN ( <span class="string">'1'</span>，<span class="string">'0'</span>) ); </span><br><span class="line">	就把性别的取值范围由(<span class="string">'男'</span>，<span class="string">'女'</span>)改为 ( <span class="string">'1'</span>，<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>触发器</strong></p>
<p>定义触发器 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER语法格式</span><br><span class="line">	   </span><br><span class="line">	  CREATE TRIGGER &lt;触发器名&gt;  </span><br><span class="line">       &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">        FOR EACH  &#123;ROW | STATEMENT&#125;</span><br><span class="line">      ［WHEN &lt;触发条件&gt;］</span><br><span class="line">        &lt;触发动作体&gt;</span><br><span class="line"></span><br><span class="line">［例18］  定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</span><br><span class="line">    CREATE TRIGGER Insert_Or_Update_Sal </span><br><span class="line">         BEFORE INSERT OR UPDATE ON Teacher  </span><br><span class="line">        /*触发事件是插入或更新操作*/</span><br><span class="line">         FOR EACH ROW                      /*行级触发器*/</span><br><span class="line">        AS BEGIN                                  /*定义触发动作体，是PL/SQL过程块*/</span><br><span class="line">              IF (new.Job=<span class="string">'教授'</span>) AND (new.Sal &lt; 4000) THEN   </span><br><span class="line">              new.Sal :=4000;                </span><br><span class="line">              END IF;</span><br><span class="line">        END;</span><br></pre></td></tr></table></figure>


<p>激活触发器<br>同一个表上的多个触发器激活时遵循如下的执行顺序：<br>（1） 执行该表上的BEFORE触发器；<br>（2） 激活触发器的SQL语句；<br>（3） 执行该表上的AFTER触发器。</p>
<p>删除触发器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">DROP TRIGGER Insert_Sal ON Teacher;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>union的用法及应用场景</title>
    <url>/C-C-Lover/nion%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>union的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">大小一块内存选最大的那个声明。</span><br><span class="line">struct&#123;</span><br><span class="line">	char name[20];</span><br><span class="line">    int num ;</span><br><span class="line">    char sex;</span><br><span class="line">    char profession;</span><br><span class="line">    union &#123;</span><br><span class="line">    <span class="built_in">float</span> score;</span><br><span class="line">    char course[20];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>共用体还真是贴切——完全就是共用一个内存首地址。<br>nion成员共享同一块大小的内存，一次只能使用其中的一个成员；<br>应用场景：</p>
<p>1、一个学生与老师的数据表中，有一项共用的（老师所教课程与学生课程分数）<br>2、union量的存放顺序是所有成员都从低地址开始存放的，可以用来判断大端和小端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int checkCPU()</span><br><span class="line">&#123;</span><br><span class="line">     union cpu</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        char b;</span><br><span class="line">     &#125;c;</span><br><span class="line">    c.a = 1;</span><br><span class="line">    <span class="built_in">return</span> ( c.b == 1 );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器算法小结</title>
    <url>/C-C-Lover/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>头文件</strong><br>#include <algorithm> //算法<br>#include <numeric> //数学<br>#include <functional>//模板<br>#include <memory>//智能指针 auto_ptr</p>
<p><strong>概念</strong><br>一元函数对象：函数参数1个；<br>二元函数对象：函数参数2个；<br>一元谓词对象：函数参数1个,返回bool；<br>二元谓词对象：函数参数2个,返回bool；</p>
<p>遍历算法 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">for_each(v1.begin(),v1.end(), show)   //容器为int</span><br><span class="line"></span><br><span class="line">void show(const int &amp;iItem)  </span><br><span class="line"></span><br><span class="line">&#123;         cout&lt;&lt; iItem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">transform() //转移容器，用于合并，函数返回值</span><br><span class="line">transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase);      </span><br><span class="line">int increase (int i) </span><br><span class="line"></span><br><span class="line">&#123;     <span class="built_in">return</span> i+1;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找算法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adjacent_find()；查找相邻重复元素，返回指向这对元素的第一个元素的迭代器。</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt;::iterator it = adjacent_find(v.begin(),vend());</span><br><span class="line"></span><br><span class="line">binary_search（）;在有序序列中查找value,无序不可</span><br><span class="line"></span><br><span class="line">bool bFind = binary_search(setInt.begin(),setInt.end(),5);</span><br><span class="line"></span><br><span class="line">count（）；计算个数</span><br><span class="line"></span><br><span class="line">intiCount = count(vecInt.begin(),vecInt.end(),2);  </span><br><span class="line"></span><br><span class="line">count_if()；</span><br><span class="line"></span><br><span class="line">bool GreaterThree(int iNum)</span><br><span class="line"></span><br><span class="line">&#123;  <span class="keyword">if</span>(iNum&gt;=3)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int iCount = count_if(vecIntA.begin(),vecIntA.end(), GreaterThree);</span><br><span class="line"></span><br><span class="line">find()；find顺序查找O(n)</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5);</span><br><span class="line"></span><br><span class="line">find_if()；</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree);</span><br></pre></td></tr></table></figure>
<p>排序算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">merge();合并排序</span><br><span class="line"></span><br><span class="line">merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin();</span><br><span class="line"></span><br><span class="line">sort();内省排序O(n*log2n)</span><br><span class="line"></span><br><span class="line">sort(vecStu.begin(),vecStu.end(),Compare);//bool()函数</span><br><span class="line"></span><br><span class="line">random_shuffle();随机排序</span><br><span class="line"></span><br><span class="line">random_shuffle(str.begin(),str.end());   </span><br><span class="line"></span><br><span class="line">reverse()；反序</span><br><span class="line"></span><br><span class="line">拷贝和替换算法</span><br><span class="line"></span><br><span class="line">copy()；</span><br><span class="line"></span><br><span class="line">replace()；</span><br><span class="line"></span><br><span class="line">replace(vecIntA.begin(), vecIntA.end(), 3,8);          //（1,3，5,3,9）&#123;1,8,5,8,9&#125;</span><br><span class="line"></span><br><span class="line">replace_if(vecIntA.begin(),vecIntA.end(), GreaterThree, 8);           </span><br><span class="line"></span><br><span class="line">swap();</span><br><span class="line"></span><br><span class="line">swap(vecIntA,vecIntB);</span><br></pre></td></tr></table></figure>

<p>算术和生成算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accumulate()；</span><br><span class="line"></span><br><span class="line">int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100);</span><br><span class="line"></span><br><span class="line">fill()；</span><br><span class="line"></span><br><span class="line"> fill(vecIntA.begin(), vecIntA.end(),8);</span><br></pre></td></tr></table></figure>
<p>集合算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">set_union()  并集有序</span><br><span class="line"></span><br><span class="line">set_intersection()交集有序</span><br><span class="line"></span><br><span class="line">set_difference()第一个有第二个没有的差集</span><br><span class="line"></span><br><span class="line">set_difference(vecIntA.begin(), vecIntA.end(),vecIntB.begin(), vecIntB.end(), vecIntC.begin());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器结构小结</title>
    <url>/C-C-Lover/%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>vector 单端，尾插</p>
<p>deque 双端，首部尾部插</p>
<p>stack  先进后出（deques首部闭合）  pop push</p>
<p>quece 队列，先进先出          </p>
<p>list   链表，随时插入</p>
<p>set 唯一值，数值顺序排顺序</p>
<p>map/multimap    关联式map&lt;T1,T2&gt; map TT;</p>
<p>map.insert(map&lt;int,string&gt;::value_type(1,”小李”)）</p>
<p>map.insert(pair &lt;int , string &gt;(3,”小张”))；</p>
<p>map.insert(make_pair(-1,”小张-1”))；</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多核处理器概念</title>
    <url>/Linux-Lover/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>这种架构在并发程序设计中，大致会引来两个问题。<br>一个是内存可见性，一个是Cache一致性流量。<br>内存可见性属于并发安全的问题，Cache一致性流量引起的是性能上的问题。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux并发与竞争</title>
    <url>/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<p><strong>Linux 系统并发产生的原因</strong><br>①、多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。<br>②、抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以<br>在任意时刻抢占正在运行的线程，从而运行其他的线程。<br>③、中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可<br>是很大的。<br>④、SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并<br>发访问。</p>
<p>临界区就是共享数据段<br>一般在编写驱动的时候就要考虑到并发与竞争，而不是驱动都编写完了然后再处理并发与竞争。</p>
<p><strong>原子操作</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/atomic.h&gt;</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line"> int counter;</span><br><span class="line">&#125; atomic_t;/*32位*/</span><br><span class="line">atomic_t v = ATOMIC_INIT(0); /* 定义并初始化原子变零 v=0 */</span><br><span class="line">atomic_set(10); /* 设置 v=10 */</span><br><span class="line">atomic_read(&amp;v); /* 读取 v 的值，肯定是 10 */</span><br><span class="line">atomic_inc(&amp;v); /*++v*/</span><br><span class="line">特点：原子操作只能对整形变量或者位进行保护</span><br><span class="line"></span><br><span class="line">操作一个atomic lock ; </span><br><span class="line">初始赋值为1，打开时判断， 0 错误返回 ， 1 atomic_dec(lock)，同时减1为0 ，（故一个时刻只能打开一次）</span><br><span class="line">关闭 atomic_inc(lock) +1 </span><br><span class="line">操作过程打不开，需等待第一个驱动任务完成，关闭函数atomic_inc(lock) +1 ，然后再次打开</span><br></pre></td></tr></table></figure>
<p><strong>自旋锁</strong><br>#include &lt;linux/atomic.h&gt;<br>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以<br>用，可以访问共享资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct spinlock &#123;</span><br><span class="line"> union &#123;</span><br><span class="line"> struct raw_spinlock rlock;</span><br><span class="line"> <span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"> <span class="comment"># define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"> struct &#123;</span><br><span class="line"> u8 __padding[LOCK_PADSIZE];</span><br><span class="line"> struct lockdep_map dep_map;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"> &#125; spinlock_t;</span><br><span class="line">特点：自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了</span><br><span class="line"></span><br><span class="line">死锁：</span><br><span class="line">被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数。自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，导致死锁现象的发生</span><br><span class="line"></span><br><span class="line">中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生</span><br><span class="line"></span><br><span class="line"> DEFINE_SPINLOCK(lock) /* 定义并初始化一个锁 */</span><br><span class="line"></span><br><span class="line">/* 线程 A */</span><br><span class="line">void <span class="function"><span class="title">functionA</span></span> ()&#123;</span><br><span class="line">unsigned long flags; /* 中断状态 */</span><br><span class="line">spin_lock_irqsave(&amp;lock, flags) /* 获取锁 推荐用这个*/</span><br><span class="line">/* 临界区 */</span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags)  /* 释放锁推荐用这个 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/* 中断服务函数 */ </span><br><span class="line">void <span class="function"><span class="title">irq</span></span>() &#123;</span><br><span class="line">spin_lock(&amp;lock) /* 获取锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line">spin_unlock(&amp;lock) /* 释放锁 */</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> 其他锁：</span><br><span class="line"> 读写锁》》》顺序锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E8%87%AA%E6%97%8B%E9%94%81.jpg" class="" title="自旋锁">


<p><strong>信号量</strong></p>
<p>（1）自旋锁，<strong>信号量可以使线程进入休眠状态</strong>，但信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。<br>（2）如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换<br>线程引起的开销要远大于信号量带来的那点优势<br>(3)计数型信号量不能用于互斥访问，因为它允许多个线程同时访问共享资源。(二值信号值)<br>自动唤醒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/semaphore.h&gt;</span></span><br><span class="line">struct semaphore &#123;</span><br><span class="line">raw_spinlock_t lock;</span><br><span class="line">unsigned int count;</span><br><span class="line">struct list_head wait_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct semaphore sem; /* 定义信号量 */</span><br><span class="line">sema_init(&amp;sem, 1)； /* 初始化信号量 */</span><br><span class="line">down(&amp;sem); /* 申请信号量 */</span><br><span class="line">/* 临界区 */</span><br><span class="line">up(&amp;sem);</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" class="" title="信号量">



<p><strong>互斥体-mutex</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct mutex &#123;</span><br><span class="line">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span><br><span class="line">atomic_t count;</span><br><span class="line">spinlock_t wait_lock;</span><br><span class="line">&#125;;</span><br><span class="line"> struct mutex lock; /* 定义一个互斥体 */</span><br><span class="line">mutex_init(&amp;lock); /* 初始化互斥体 */</span><br><span class="line"></span><br><span class="line"> mutex_lock(&amp;lock); /* 上锁 */</span><br><span class="line"> /* 临界区 */</span><br><span class="line"> mutex_unlock(&amp;lock); /* 解锁 *</span><br><span class="line">①、mutex 可以导致休眠，因此不能在中断中使用 mutex，__中断中只能使用自旋锁__。</span><br><span class="line">②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</span><br><span class="line">③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并</span><br><span class="line">且 mutex 不能递归上锁和解锁</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/%E4%BA%92%E6%96%A5%E4%BD%93.jpg" class="" title="互斥体">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>gpioled 基本框架</title>
    <url>/Linux-Lover/pioled-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>用来复习QvQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_address.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_irq.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/of_gpio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define GPIOLED_CNT   1       /*数量*/</span></span><br><span class="line"><span class="comment">#define GPIOLED_NAME  "gpioled"    /*名字*/</span></span><br><span class="line"><span class="comment">#define LEDOFF       0       /*关闭*/ </span></span><br><span class="line"><span class="comment">#define LEDON       1         /*开启*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*设备结构体*/</span><br><span class="line">struct gpioled_dev&#123;</span><br><span class="line"></span><br><span class="line">    dev_t devid ;</span><br><span class="line">    int major;</span><br><span class="line">    int minor;</span><br><span class="line">    struct cdev cdev;</span><br><span class="line">    struct class *class;</span><br><span class="line">    struct device *device;</span><br><span class="line">    struct device_node * nd;</span><br><span class="line">    int led_gpio;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct gpioled_dev gpioled;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled; /*传递结构*/</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line">			 size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    int ret ;</span><br><span class="line">    unsigned char databuf[1];</span><br><span class="line">    struct gpioled_dev *dev = filp-&gt;private_data;</span><br><span class="line">    ret = __copy_from_user(databuf,buf,count);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(databuf[0] == LEDON)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_value(dev-&gt;led_gpio,0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (databuf[0] == LEDOFF)</span><br><span class="line">    &#123;</span><br><span class="line">       gpio_set_value(dev-&gt;led_gpio, 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 操作集 */</span><br><span class="line">static const struct file_operations led_fops = &#123;</span><br><span class="line">    .owner		=	THIS_MODULE,</span><br><span class="line">	.write		=	led_write,</span><br><span class="line">	.open		=	led_open,</span><br><span class="line">	.release	=	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init led_init(void )</span><br><span class="line">&#123;</span><br><span class="line">int ret  ;</span><br><span class="line">    gpioled.major = 0;</span><br><span class="line">    <span class="keyword">if</span> (gpioled.major)</span><br><span class="line">    &#123;</span><br><span class="line">        gpioled.devid = MKDEV(gpioled.major,0);</span><br><span class="line">        register_chrdev_region(gpioled.devid,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alloc_chrdev_region(&amp;gpioled.devid,0,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">        gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">        gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"gpioled.major = %d ,gpioled.minor = %d\r\n"</span>,gpioled.major,gpioled.minor);</span><br><span class="line"></span><br><span class="line">*初始化cdev*/</span><br><span class="line">    gpioled.cdev.owner = THIS_MODULE ;</span><br><span class="line">    /*初始化*/</span><br><span class="line">    cdev_init(&amp;gpioled.cdev,&amp;led_fops);</span><br><span class="line">    </span><br><span class="line">  ret = cdev_add(&amp;gpioled.cdev,gpioled.devid,GPIOLED_CNT);</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; 0) </span><br><span class="line">        goto fail_cdev;  </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    /*创建class*/</span><br><span class="line">    gpioled.class = class_create(THIS_MODULE,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.class))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*创建device*/</span><br><span class="line">   gpioled.device = device_create(gpioled.class,NULL,gpioled.devid,NULL,GPIOLED_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(gpioled.device))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   /* 1，获取设备节点 */</span><br><span class="line">    gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    /* 2, 获取LED所对应的GPIO */</span><br><span class="line">    gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">    <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">        printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">    /* 3,申请IO */</span><br><span class="line">    ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpio"</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">        goto fail_findnode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* 4,使用IO，设置为输出 */</span><br><span class="line">    ret = gpio_direction_output(gpioled.led_gpio, 1);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		goto fail_setoutput;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 0);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">    fail_setoutput:</span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line">    fail_findnode:</span><br><span class="line">    fail_cdev:</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">static void __exit led_exit(void )</span><br><span class="line">&#123;</span><br><span class="line">      /* 关灯 */</span><br><span class="line">    gpio_set_value(gpioled.led_gpio, 1);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;gpioled.cdev);</span><br><span class="line">    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">    device_destroy(gpioled.class,gpioled.devid);</span><br><span class="line">    class_destroy(gpioled.class);</span><br><span class="line"></span><br><span class="line">    gpio_free(gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"ming"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树</title>
    <url>/Linux-Lover/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<p>Linux 内核中 ARM 架构下有太多的冗余的垃圾板</p>
<p>级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树</p>
<p>dts、dtbs、dtc、dtsi<br>设备树包括DTC（device tree compiler）,DTS(device tree source和DTB（device tree blob）。DTC为编译工具，它可以将.dts文件编译成.dtb文件。</p>
<p><strong>of 查找设备节点</strong></p>
<p>of_find_node_by_name 函数通过节点名字查找指定的节点</p>
<p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点</p>
<p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点</p>
<p>of_find_node_by_path 函数通过路径来查找指定的节点</p>
<p><strong>查找父/ 子节点的 OF 函数</strong></p>
<p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)</p>
<p>of_get_next_child 函数用迭代的查找子节点</p>
<p><strong>提取属的 性值的 OF 函数</strong></p>
<p>of_find_property 函数用于查找指定的属性</p>
<p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，</p>
<p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值</p>
<p>of_property_read_u8_array 函数</p>
<p>of_property_read_u16_array  函数</p>
<p>of_property_read_u32_array  函数</p>
<p>of_property_read_u64_array</p>
<p>of_property_read_string 函数用于读取属性中字符串值</p>
<p>of_n_addr_cells 函数用于获取#address-cells 属性值</p>
<p>of_size_cells 函数用于获取#size-cells 属性值</p>
<p>其他常用的 OF</p>
<p>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性</p>
<p>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性</p>
<p>值，函数属性如下</p>
<p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址</p>
<p>of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型</p>
<p>of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。</p>
<p>因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>yocto 根文件命令小记</title>
    <url>/Linux-Lover/octo-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>cat /proc/devices  设备</p>
<p>/lib/module</p>
<p>depmod //第一次加载驱动的时候需要运行此命令</p>
<p>modprobe chrdevbase</p>
<p>//可以看到“chrdevbase init！” chrdevbase_init 输出的信息，说明模块加载成功！</p>
<p>cat /proc/devices  //查看设备信息</p>
<p>mknod /dev/chrdevbase c 200 0//设备节点</p>
<p>原因如下<br>（注意：这里不要有后缀.ko，不然会找不到，如：ko文件名是chrdevbase.ko，那么modprobe chrdevbase） 就可以了。具体步骤：</p>
<p>rmmod beep.ko</p>
<p>···<br>cd /proc/device-tree  设备树信息</p>
<p>cat /proc/interrupts  设备中断</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动开发准备知识</title>
    <url>/Linux-Lover/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>学习 Linux驱动开发</strong></p>
<p>linaro（利纳罗） 5.4.0   交叉编译器<br>ubuntu 16.04.9<br>flash EMMC NAND——–ROM 8g<br>DDR3 ——RAM 512m<br>Linux 内核版本为 4.1.15，其支持设备树(Device tree)<br> Linux 中的三大类驱动：字符设备驱动（简单）、块设备驱动（储存有关）和网络设备驱动（上网功能）（过于复杂开发商写好）。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl +gpio系统</title>
    <url>/Linux-Lover/nctrl-gpio%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>pinctl子系统 设置GPIO复用电气属性</strong><br>imx6ull.dtsi文件</p>
<p>IO分类：<br>IOMUXC SNVS控制器<br>IOMUXC控制器<br>gpr控制器</p>
<p>添加一个PIN的信息 打开imx6ul-pinfunc.h</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pinctrl_hog_1: hoggrp-1 &#123;</span><br><span class="line">			fsl,pins = &lt;</span><br><span class="line">				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 </span><br><span class="line">			&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19  0x0090 0x031C 0x0000 0x5 0x0</span><br><span class="line">&lt;mux_reg 	conf_reg	 input_reg	 mux_mode	 input_val&gt;</span><br><span class="line">0x0090 		0x031C 	 0x0000 	  0x5 		 0x0</span><br></pre></td></tr></table></figure>
<p>mux_reg：IOMUXC父节点首地址0x020e0000，因此UART1_RTS_B这个PIN的mux寄存器地址 就是：0x020e0000+0x0090=0x020e 0090。<br>conf_reg：0x020e0000+0x031C=0x020e 031C，这个寄存器就是UART1_RTS_B的电气属性配置寄存器。<br>input_reg，为0，表示UART1_RTS_B这个PIN没有input功能。<br>mux_mode： 5表示复用为GPIO1_IO19，将其写入0x020e 0090<br>input_val：就是写入input_reg寄存器的值。</p>
<p><strong>pincrtl驱动原理？</strong><br>    全局搜索，设备节点里面的compatible属性的值，看看在哪个.c文件里面有，那么此.c文件就是驱动文件。<br>    找到pinctrl-imx6ul.c文件，那么此文件就是6UL/6ULL的pinctrl驱动文件。当驱动和设备匹配以后执行，probe函数。也就是imx6ul_pinctrl_probea函数，其中<br>imx_pinconf_set函数设置PIN的电气属性<br>imx_pmx_set函数设置PIN的复用</p>
<p><strong>gpio子系统 设置引脚属性</strong></p>
<p>文件devicetree\bindings\gpio<br>用法：<br>cd-gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_LOW&gt;;</p>
<p>设备数函数常用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.nd == NULL) &#123;</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 2, 获取LED所对应的GPIO */</span><br><span class="line">   gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, 0);</span><br><span class="line">   <span class="keyword">if</span>(gpioled.led_gpio &lt; 0) &#123;</span><br><span class="line">       printk(<span class="string">"can't find led gpio\r\n"</span>);</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"led gpio num = %d\r\n"</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">   /* 3,申请IO */</span><br><span class="line">   ret = gpio_request(gpioled.led_gpio, <span class="string">"led-gpios"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	printk(<span class="string">"Failed to request the led gpio\r\n"</span>);</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">       goto fail_findnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   /* 4,使用IO，设置为输出 */</span><br><span class="line">   ret = gpio_direction_output(gpioled.led_gpios, 1);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	goto fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   /* 5,输出底电平，点亮LED灯*/</span><br><span class="line">   gpio_set_value(gpioled.led_gpio, 0);</span><br></pre></td></tr></table></figure>





<p><strong>gpio驱动原理</strong><br>1、gpiolib<br>两部分，给原厂编写GPIO底层驱动的，给驱动开发人员使用GPIO操作函数的。<br>使用gpiochip_add向系统添加gpio_chip，这些都是半导体原厂做的，这部分就是最底层的GPIO驱动。<br>2、gpio驱动<br>在drivers/gpio目录下，gpio-xxx.c文件为具体芯片的驱动文件，</p>
<p>申请IO的时候失败，大部分原因是这个IO被其他外设占用了。检查设备树，查找有哪些使用同一IO的设备。<br>    1，检查复用，也就是pinctl设置。<br>    2，gpio使用</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>信号高级用法(sigaction与sigqueue)</title>
    <url>/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><strong>信号的高级用法</strong></p>
<p>sigaction函数注册信号处理函数<br>int  sigaction(int signum,const struct sigaction *act,const struct sigaction *old);</p>
<p>第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一 个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。<br>第二个参数是指向结构sigaction的一个实例的指针，在结构 sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理<br>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。<br>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigaction 结构体</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_sigaction &#x3D; myhandle;</span><br><span class="line">act.sa_flags &#x3D;SA_SIGINFO;&#x2F;&#x2F;表示能接受数据</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;recv a sig&#x3D;%d\n&quot;, sig);	</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;         </span><br><span class="line">	struct sigaction act;</span><br><span class="line">	sigset_t sa_mask;</span><br><span class="line">	act.sa_handler &#x3D; handler;</span><br><span class="line">	act.sa_flags &#x3D; 0;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	&#x2F;&#x2F;测试信号安装函数</span><br><span class="line">	sigaction(SIGINT, &amp;act, NULL);</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">	pause();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装my_signal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define ERR_EXIT(m) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        perror(m); \</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">    &#125; <span class="keyword">while</span>(0)void handler(int sig);/* 系统调用signal()实际上调用了sigaction() */</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler);int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    my_signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">for</span> (; ;)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">__sighandler_t my_signal(int sig, __sighandler_t handler)</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    struct sigaction oldact;</span><br><span class="line">    act.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;act, &amp;oldact) &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> SIG_ERR;</span><br><span class="line">    <span class="built_in">return</span> oldact.sa_handler; // 返回先前的处理函数指针&#125;void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rev sig=%d\n"</span>, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E5%8F%B7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/mysignal.jpg" class="" title="5s阻塞后到达">

<p>typedef union sigval<br>{<br>int sival_int;<br>void *sival_ptr;<br>}sigval_t; </p>
<p>sigqueue新的信号发送函数<br>原型:int sigqueue(pid_t pid, int sig, const union sigval value);<br> 第一个参数是指定接收信号的进程id<br> 第二个参数确定即将发送的信号<br> 第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line">pid_t pid_Array[10]; //pid 数组</span><br><span class="line">void myhandle(int sig,siginfo_t*st, void *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sig == SIGRTMIN)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子1收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[1] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">if</span>(sig == SIGRTMIN+1)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：孩子2收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			pid_Array[3] = st-&gt;si_int;   </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sig == SIGRTMIN+2)   //</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"处理函数：父亲收到信号%d\n"</span>,st-&gt;si_int);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"pid[0]:%d  pid[1]%d \n"</span>,pid_Array[0],pid_Array[1]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid;</span><br><span class="line">	</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_sigaction = myhandle;</span><br><span class="line">	act.sa_flags =SA_SIGINFO; //可传递数据</span><br><span class="line">	int i=0;</span><br><span class="line">	/*注册信号*/</span><br><span class="line">     <span class="keyword">if</span>(sigaction(SIGRTMIN, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+1, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGRTMIN+2, &amp;act,NULL)&lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error sigaction\n"</span>);</span><br><span class="line">	<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*fork两个进程*/</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid_Array[i] = pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">			perror(<span class="string">"fork fail"</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(pid&gt;0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"fork %d \n"</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid ==  0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"i:%d\n"</span>,i);</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*两个进程处理函数*/</span><br><span class="line">	<span class="keyword">if</span>( pid==0 &amp;&amp; i == 0)  //第一个子进程</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程1运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程1醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = getpid()*2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子1给子2发信号  %d \n"</span>,getpid()*2);</span><br><span class="line">		sigqueue(pid_Array[1],SIGRTMIN+1,value);     </span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid==0 &amp;&amp; i==1)//第二个子进程</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子进程2运行然后睡眠\n"</span>);</span><br><span class="line">		sleep(10);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"信号，子进程2醒来\n"</span>);</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[3];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子2给父进程发 %d \n"</span>,pid_Array[3]);</span><br><span class="line">		sigqueue(getppid(),SIGRTMIN+2,value);     //父进程pid</span><br><span class="line">			<span class="built_in">exit</span>(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//父进程</span><br><span class="line">		union sigval value;</span><br><span class="line">		value.sival_int = pid_Array[1]; //传递进程2 pid   给进程 1 </span><br><span class="line">		sigqueue(pid_Array[0],SIGRTMIN,value);    </span><br><span class="line"></span><br><span class="line">		sleep(10);</span><br><span class="line">		int mypid =0;</span><br><span class="line">		int  pidnum = 1 ;</span><br><span class="line">		<span class="keyword">while</span>((mypid = waitpid(-1,NULL,WNOHANG))&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"子进程：%d 退出%d\n"</span>,pidnum++,mypid); </span><br><span class="line">		&#125;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"父进程退出\n"</span>);</span><br><span class="line">	     <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> ---------------------------</span><br><span class="line"> ming@ubuntu:~/Day6/22$ ./3</span><br><span class="line">fork 0 </span><br><span class="line">i:0</span><br><span class="line">子进程1运行然后睡眠</span><br><span class="line">fork 1 </span><br><span class="line">i:1</span><br><span class="line">子进程2运行然后睡眠</span><br><span class="line">处理函数：孩子1收到信号5135</span><br><span class="line">信号，子进程1醒来</span><br><span class="line">子1给子2发信号  10268 </span><br><span class="line">处理函数：孩子2收到信号10268</span><br><span class="line">信号，子进程2醒来</span><br><span class="line">子2给父进程发 10268 </span><br><span class="line">处理函数：父亲收到信号10268</span><br><span class="line">pid[0]:5134  pid[1]5135 </span><br><span class="line">子进程：1 退出5134</span><br><span class="line">父进程退出</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>和kill函数相比Int kill(pid_t pid, int siq)多了参数<br>但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket-Api编程</title>
    <url>/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>多并发？</strong></p>
<p>每来一个客户，创建一个进程的思路。</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91.jpg" class="" title="基本框架">

<p><strong>流协议与粘包</strong></p>
<p>tcp    字节流 无边界<br>udp    消息、数据报 有边界<br>对等方，一次读操作，不能保证完全把消息读完。<br>对方接受数据包的个数是不确定的。</p>
<hr>
<p><strong>TCP/IP协议的11种状态</strong></p>
<p>两端同时关闭    将产生closing状态，最后双方都进入TIME_WAIT状态。<br>执行主动关闭的那一端，进入TIME_WAIT状态</p>
<img src="/Linux-Lover/ocket-Api%E7%BC%96%E7%A8%8B/11.jpg" class="" title="11种">


<p><strong>为什么TCP/IP要三次握手，和四次断开？</strong></p>
<p>全双工协议。（客户收发、服务收发确认）</p>
<p><em>_TIME_WAIT 时间是多长2MSL （2倍的最大生命期时间）</em></p>
<p>原因：（ACK y+1）如果发送失败可以重发。 最后 一个确认包的确认完成。<br>服务器端处于closed状态，不等于客户端也处于closed状态。。</p>
<p><strong>SIGPIPE</strong></p>
<p>如果对方socket已关闭，对等方再发写数据，则会产生SIGPIPE信号<br>常做忽略处理：<br>signal(SIGPIPE, SIG_IGN); </p>
<p><strong>close与shutdown区别</strong><br>refcnt 引用计数</p>
<p>close终止了数据传送的两个方向。<br>shutdown可以有选择的终止某个方向的数据传送或者终止数据传送的两个方向。<br>shutdown how=1就可以保证对等方接收到一个EOF字符，而不管其他进程是否已经打开了套接字（引用计数!）。而close不能保证，直到套接字引用计数减为0时才发送。也就是说直到所有的进程都关闭了套接字。</p>
<p><em>了解5种IO模型_</em></p>
<p>阻塞IO<br>非阻塞IO<br>复用IO<br>信号驱动IO<br>异步IO</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统移植问题</title>
    <url>/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>工具区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bootmgr  RAM空间  选择  windows下</span><br><span class="line">Grub  引导不同的内核启动 RAM空间  选择  支持多操作系统</span><br><span class="line">BIOS  初始化硬件不能引导OS内核   ROM芯片上的程序 开启时运行的第一个程序</span><br><span class="line">Bootloader 引导内核程序运行 RAM空间 内核运行前的程序 Bootloader =BIOS+Grub/Bootmgr </span><br><span class="line">U-boot  通用Bootloader</span><br><span class="line">U-Boot，全称为Universal Boot Loader，即通用Bootloader</span><br></pre></td></tr></table></figure>
<p><strong>ARM U-boot 内核传递参数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">•	U-boot引导程序，在启动的时候会给给Linux Kernel传递很多参数</span><br><span class="line">•	串口波特率，RAM大小，视频fb，MAC地址等</span><br><span class="line">•	设备树的入口地址</span><br><span class="line">•	u-boot如何进行传递的？</span><br><span class="line">•	U-boot把要传递给kernel的东西：保存在struct tag数据结构中</span><br><span class="line">•	启动kernel时，把这个结构体的物理地址传给kernel</span><br><span class="line">•	kernel解析传递的参数？</span><br><span class="line">•	Linux内核通过这个地址，用parse_tags分析出传递过来的参数</span><br><span class="line"></span><br><span class="line">1、内核引导程 arch/arm/lib/vectors.S   用完释放 kernel_entry()</span><br><span class="line">2、内核启动</span><br><span class="line">执行head-armv.S     关闭中断、关闭 MMU。②、关闭 </span><br><span class="line">ENTERY(stxet)      arch/arm/kernel/head.S</span><br><span class="line">Start_kernel();</span><br><span class="line"></span><br><span class="line">ARM架构上，u-boot向Linux内核传递参数利用了R0，R1和R2三个寄存器</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/nux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98/linux.jpg" class="">


<p>Linux驱动开发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主设备号</span><br><span class="line">•	主设备号标识设备对应的驱动程序。</span><br><span class="line">次设备号</span><br><span class="line">•	次设备号由内核使用，用于正确确定设备文件所指的设备。</span><br><span class="line">字符设备的两种注册方式</span><br><span class="line">void cdev_init(struct cdev *cdev, struct file_operations *fops)</span><br><span class="line">int register_chrdev(unsigned int major, const char *namem , struct file_operations *fopen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：insomd加载一个驱动模块，会执行模块中的那个函数？rmmod呢？这两个函数在设计上要注意什么？遇到过卸载驱动出现异常没？是什么问题引起的？</span><br><span class="line">$ insmod  hello.ko  // 模块加载函数 , 只加载hello.ko模块;</span><br><span class="line">$ modprobe  -r hello.ko	// 模块加载函数,  将加载hello.ko 依赖的所有模块;</span><br><span class="line">（1）insmod调用初始函数，rmmod调用退出函数；</span><br><span class="line">（2）卸载模块时曾出现卸载失败的原因：原因是存在进行中的使用模块，检查代码后发现产生了死锁的问题。</span><br><span class="line">（3）初始化函数中申请的资源在出口函数中要释放：也就是一个模块注册进内核，退出内核时要清理所带来的影响，带走一切不留下一点痕迹。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/Other-Lover/xo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>npm install hexo-asset-image –save</p>
<p>npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save</p>
<p>hexo new”postName” #新建文章</p>
<p>hexo new page”pageName” #新建页面</p>
<p>hexo new page categories 分类页面</p>
<p>hexo new page tags 分类页面</p>
<p>hexo new page about  关于页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #将.deploy目录部署到指定空间</p>
<p>hexo help # 查看帮助</p>
<p>hexo version #查看Hexo的版本</p>
<p>hexo server 本地</p>
<p>hexo deploy 部署</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>序号</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>5</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td></td>
<td>192</td>
</tr>
</tbody></table>
<p><strong>着重号</strong></p>
<p><em>这是斜体</em> 或 <em>这也是斜体</em></p>
<p><strong>这是粗体</strong></p>
<p><strong><em>这是加粗斜体</em></strong></p>
<p><del>这是删除线</del></p>
<p>内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>///</p>
<p>推荐链接：<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>背景清晰度：<a href="https://www.zhihu.com/question/268140594/answer/335335120" target="_blank" rel="noopener">https://www.zhihu.com/question/268140594/answer/335335120</a></p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6>]]></content>
      <categories>
        <category>Other Lover</category>
      </categories>
  </entry>
  <entry>
    <title>架构概念</title>
    <url>/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<img src="/Linux-Lover/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84.jpg" class="" title="架构概念">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>变量知识点</title>
    <url>/C-C-Lover/%E5%8F%98%E9%87%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>i.    预编译: 处理#开头的指令，比如拷贝 #include 包含的文件代码,#define 宏定义的替换 , 条件编译等,就是为编译做的预备工作的阶段。<br>ii.    编译: 分析代码的语法和语义, 将变量和关键字 翻译成中间代码或者汇编代码;<br>iii.    汇编: 将汇编语言翻译为机器可识别的二进制代码.o 是二进制文件<br>iv.    链接:将目标文件所需的库, 文件进行链接</p>
<p>volatile应该是在编译阶段，extern在链接阶段。<br>volatile：告诉编译器，修饰的变量不能优化，每次读取需要从内存中读取；</p>
<p>Static</p>
<ol>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>extern “C”<br>•    被 extern 限定的函数或变量是 extern 类型的<br>•    被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的<br>•    extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
</ol>
<p>#define dPS struct s *             // 宏定义 dPS 表示 struct s*<br>typedef struct s * tPS;            // typedef 表示，将struct *s 重命名为tPS</p>
<p>#define是一个预处理器令牌：编译器本身将永远看不到它。<br>typedef是一个编译器令牌：预处理器不关心它。</p>
<p>•    typedef以分号结尾，而#define不以分号结尾。<br>•    typedef用于为现有类型赋予新的符号名称，而#define用于创建任何类型和值的别名。</p>
<p> explicit关键字<br>只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).<br>  如下面写法是否被允许。<br>  CxString string1(24);<br> CxString string2 = 10;  </p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>串口、COM、RS232、RS485</title>
    <url>/MCU-Lover/%E5%8F%A3%E3%80%81COM%E3%80%81RS232%E3%80%81RS485/</url>
    <content><![CDATA[<p><strong>uart</strong> （Universal Asynchronous Receiver／Transmitter）<br><strong>usart</strong> （Universal Synchronous Asynchronous Receiver Transmitter）</p>
<p>Uart  异步。（预先知道波特率的大小,传输效率比同步通信要低。）  全双工方式<br>Usart <strong>同步多条时钟线</strong>，也可当做uart使用。</p>
<p>COM异步通信口，被USB取代</p>
<p>COM/USB -&gt; MAX232-&gt; 单片机UART/USART<br>COM/USB -&gt; CH340-&gt; 单片机UART/USART</p>
<p>需要注意的是,串口、UART/USART通常指的是硬件接口。</p>
<p>RS-232指的是属于物理层范畴的串行通信接口标准,RS-232就是个标准。<br>三种接口都是属于串口通信,主要有几个方面的区别。<br>1、通讯距离, RS232接口通讯距离为15米,而RS422/485最大通讯距离可以达到1200米。<br>2、所连设备数, RS232只能连接一个设备,而RS485可以同时连接多个设备。<br>3、端口定义, RS232为标准接口,一般为D型9针的DB9头,接口信号一般为标准默认的。而RS422/RS485为非标准接口,一般为15针串口接口(也可以做9针接口) ,每个设备的接口定义也不太一样, RS422一般为4线制全双工模式,而RS485为两线制,<strong>半双工模式</strong>。</p>
<table>
<thead>
<tr>
<th>SPI与IIC区别</th>
</tr>
</thead>
<tbody><tr>
<td>SPI 是同步串行接口，是一种高速、全双工的同步通信总线</td>
</tr>
<tr>
<td>IIC 是多主设备的总线 , 只有一根数据线，所以是半双工通信</td>
</tr>
<tr>
<td>1. SPI适合数据流应用，而IIC更适合“字节设备”的多主设备应用。</td>
</tr>
<tr>
<td>2. IIC 只需两根信号线，而标准SPI至少四根信号。</td>
</tr>
<tr>
<td>3. 数据吞吐/传输速度   SPI &gt; IIC 8M &gt; 400K</td>
</tr>
<tr>
<td>4、7位I2C总线可以挂接127个不同地址的I2C设备,0号”设备”作为群呼地址.</td>
</tr>
<tr>
<td>5、SPI接口的一个缺点：没有指定的流控制,没有应答机制确认是否接收到数据</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么说你了解过IIC</title>
    <url>/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/</url>
    <content><![CDATA[<p>8位IIC 最多连接127个器件。我们可以 2^8-最高位的广播(128)-1<br>IIC 速度能到达400K,接4.7k电阻</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/iic.JPG" class="">


<p><strong>起始位</strong></p>
<p>在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E8%B5%B7%E5%A7%8B%E4%BD%8D.JPG" class="">

<p><strong>停止位</strong></p>
<p>在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E5%81%9C%E6%AD%A2%E4%BD%8D.JPG" class="">

<p><strong>数据传输</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.JPG" class="">

<p><strong>应答信号</strong></p>
<p>应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p>



<p>通信不外乎两个操作：写和读</p>
<p><strong>I2C写时序</strong></p>


<p>1)、开始信号。<br>2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决<br>定访问哪个 I2C 器件。<br>3)、 高 7 位是设备地址,I2C 器件地址后面跟着一个读写位,为 0 表示写操作，为 1 表示读操作。<br>4)、从机发送的 ACK 应答信号。<br>5)、重新发送开始信号。<br>6)、发送要写写入数据的寄存器地址。<br>7)、从机发送的 ACK 应答信号。<br>8)、发送要写入寄存器的数据。<br>9)、从机发送的 ACK 应答信号。<br>10)、停止信号</p>
<p>注：先高位（MSB)后低位(LSB)？<br>通常，MSB位于二进制数的最左侧，LSB位于二进制数的最右侧。<br>首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。</p>
<p><strong>I2C读时序</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87IIC/%E8%AF%BB%E6%97%B6%E5%BA%8F.JPG" class="I2C">

<p>1)、主机发送起始信号。<br>2)、主机发送要读取的 I2C 从设备地址。<br>3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。<br>4)、从机发送的 ACK 应答信号。<br>5)、重新发送 START 信号。<br>6)、主机发送要读取的寄存器地址。<br>7)、从机发送的 ACK 应答信号。<br>8)、重新发送 START 信号。<br>9)、重新发送要读取的 I2C 从设备地址。<br>10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。<br>11)、从机发送的 ACK 应答信号。<br>12)、从 I2C 器件里面读取到的数据。<br>13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。<br>14)、主机发出 STOP 信号，停止 I2C 通信。</p>
<p><strong>基本I2C框架？</strong><br>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _BSP_I2C_H</span><br><span class="line">#define _BSP_I2C_H</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;* 相关宏定义 *&#x2F;</span><br><span class="line">#define I2C_STATUS_OK				(0)</span><br><span class="line">#define I2C_STATUS_BUSY				(1)</span><br><span class="line">#define I2C_STATUS_IDLE				(2)</span><br><span class="line">#define I2C_STATUS_NAK				(3)</span><br><span class="line">#define I2C_STATUS_ARBITRATIONLOST	(4)</span><br><span class="line">#define I2C_STATUS_TIMEOUT			(5)</span><br><span class="line">#define I2C_STATUS_ADDRNAK			(6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * I2C方向枚举类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">enum i2c_direction</span><br><span class="line">&#123;</span><br><span class="line">    kI2C_Write &#x3D; 0x0, 		&#x2F;* 主机向从机写数据 *&#x2F;</span><br><span class="line">    kI2C_Read &#x3D; 0x1,  		&#x2F;* 主机从从机读数据 *&#x2F;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 主机传输结构体</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_transfer</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char slaveAddress;      	&#x2F;* 7位从机地址 			*&#x2F;</span><br><span class="line">    enum i2c_direction direction; 		&#x2F;* 传输方向 			*&#x2F;</span><br><span class="line">    unsigned int subaddress;       		&#x2F;* 寄存器地址			*&#x2F;</span><br><span class="line">    unsigned char subaddressSize;    	&#x2F;* 寄存器地址长度 			*&#x2F;</span><br><span class="line">    unsigned char *volatile data;    	&#x2F;* 数据缓冲区 			*&#x2F;</span><br><span class="line">    volatile unsigned int dataSize;  	&#x2F;* 数据缓冲区长度 			*&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*函数集合*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_init(I2C_Type *base); &#x2F;*初始化*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_start(I2C_Type *base, unsigned char address, enum i2c_direction direction);&#x2F;*第一次start*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_repeated_start(I2C_Type *base, unsigned char address,  enum i2c_direction direction);&#x2F;*第二次start*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_check_and_clear_error(I2C_Type *base, unsigned int status);&#x2F;*检查并清除错误*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_stop(I2C_Type *base);&#x2F;*停止信号*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_master_write(I2C_Type *base, const unsigned char *buf, unsigned int size);&#x2F;*写*&#x2F;</span><br><span class="line"></span><br><span class="line">void i2c_master_read(I2C_Type *base, unsigned char *buf, unsigned int size); &#x2F;*读*&#x2F;</span><br><span class="line"></span><br><span class="line">unsigned char i2c_master_transfer(I2C_Type *base, struct i2c_transfer *xfer);&#x2F;*I2C数据传输，包括读和写*&#x2F;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>设备调用？</strong></p>
<p>AP3216:这颗芯片集成了光强传感器（ALS:AmbientLight Sensor），接近传感器（PS: Proximity Sensor），还有一个红外LED（IR LED）。这个芯片设计的用途是给手机之类的使用，比如：返回当前环境光强以便调整屏幕亮度；用户接听电话时，将手机放置在耳边后，自动关闭屏幕避免用户误触碰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _BSP_AP3216C_H</span><br><span class="line">#define _BSP_AP3216C_H</span><br><span class="line">&#x2F;***************************************************************</span><br><span class="line">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">文件名	: 	 bsp_ap3216c.h</span><br><span class="line">作者	   : 左忠凯</span><br><span class="line">版本	   : V1.0</span><br><span class="line">描述	   : AP3216C驱动头文件。</span><br><span class="line">其他	   : 无</span><br><span class="line">论坛 	   : www.wtmembed.com</span><br><span class="line">日志	   : 初版V1.0 2019&#x2F;3&#x2F;26 左忠凯创建</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line"></span><br><span class="line">#define AP3216C_ADDR    	0X1E	&#x2F;* AP3216C器件地址 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AP3316C寄存器 *&#x2F;</span><br><span class="line">#define AP3216C_SYSTEMCONG	0x00	&#x2F;* 配置寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_INTSTATUS	0X01	&#x2F;* 中断状态寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_INTCLEAR	0X02	&#x2F;* 中断清除寄存器 			*&#x2F;</span><br><span class="line">#define AP3216C_IRDATALOW	0x0A	&#x2F;* IR数据低字节 			*&#x2F;</span><br><span class="line">#define AP3216C_IRDATAHIGH	0x0B	&#x2F;* IR数据高字节 			*&#x2F;</span><br><span class="line">#define AP3216C_ALSDATALOW	0x0C	&#x2F;* ALS数据低字节 		*&#x2F;</span><br><span class="line">#define AP3216C_ALSDATAHIGH	0X0D	&#x2F;* ALS数据高字节			*&#x2F;</span><br><span class="line">#define AP3216C_PSDATALOW	0X0E	&#x2F;* PS数据低字节 			*&#x2F;</span><br><span class="line">#define AP3216C_PSDATAHIGH	0X0F	&#x2F;* PS数据高字节 			*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数声明 *&#x2F;</span><br><span class="line">unsigned char ap3216c_init(void);</span><br><span class="line">unsigned char ap3216c_readonebyte(unsigned char addr,unsigned char reg);</span><br><span class="line">&#x2F;*调用I2c读封装*&#x2F;</span><br><span class="line">unsigned char ap3216c_writeonebyte(unsigned char addr,unsigned char reg, unsigned char data);&#x2F;*调用I2c写封装*&#x2F;</span><br><span class="line">void ap3216c_readdata(unsigned short *ir, unsigned short *ps, unsigned short *als);&#x2F;*封装读和写数据*&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
















<p><em>_I2C读时序</em></p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么说你了解过SPI</title>
    <url>/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/</url>
    <content><![CDATA[<p><strong>四线SPI</strong></p>
<p>①、CS/SS，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可。<br>②、SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。<br>③、MOSI/SDO，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线<br>只能用于主机向从机发送数据，也就是主机输出，从机输入。<br>④、MISO/SDI，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。<br>SPI 通信都是由主机发起的，主机需要提供通信的时钟信号。</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/spi.JPG" class="">

<p><em>_SPI 有四种工作模式</em></p>
<p>通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：<br>①、CPOL=0，串行时钟空闲状态为低电平。<br>②、CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具<br>体的传输协议。<br>③、CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。<br>④、CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。<br>    SPI 的时序图很简单，不像 I2C 那样还要分为读时序和写时序，因为 SPI 是全双工的，所以读写时序可以一起完成.</p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/%E5%9B%9B%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.JPG" class="">


<p> <strong>时序图</strong></p>
<img src="/MCU-Lover/%E6%80%8E%E4%B9%88%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87SPI/%E6%97%B6%E5%BA%8F.JPG" class="">

<p> <strong>spi基本框架</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #ifndef _BSP_SPI_H</span><br><span class="line">#define _BSP_SPI_H</span><br><span class="line">#include &quot;imx6ul.h&quot;</span><br><span class="line">&#x2F;* 函数声明 *&#x2F;</span><br><span class="line">void spi_init(ECSPI_Type *base);</span><br><span class="line">unsigned char spich0_readwrite_byte(ECSPI_Type *base, unsigned char txdata);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p> mpu9250传感器包括 3 轴加速度和 3 轴陀螺仪</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql常见报错</title>
    <url>/MySql-Lover/MySql%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>外键约束报错？</p>
<p>SET foreign_key_checks = 0;<br>······<br>SET foreign_key_checks = 1;</p>
<p>update 修改报错？<br>这是因为MySql运行在safe-updates模式下，该模式会导致非主键条件下无法执行update或者delete命令，执行命令SET SQL_SAFE_UPDATES = 0;</p>
<p>限制执行完语句<br>DELIMITER $<br>····<br>$</p>
<p>referencing 在mysql中是不存在的，在mysql里面 等同的是NEW关键字 和OLD关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC_U(</span><br><span class="line">	Sno CHAR(9) NOT NULL,</span><br><span class="line">	Cno CHAR(4) NOT NULL,</span><br><span class="line">	Oldgrade SMALLINT,</span><br><span class="line">	Newgrade SMALLINT</span><br><span class="line">);</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE TRIGGER SC_T </span><br><span class="line">AFTER UPDATE  ON SC</span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">IF (NEW.Grade &gt;&#x3D; 1.1 * OLD.Grade)THEN</span><br><span class="line">	INSERT INTO SC_U(Sno,Cno,OldeGrade,NewGrade)</span><br><span class="line">    VALUES (OLD.Sno,OLD.Cno,OLD.Grade,NEW.Grade);</span><br><span class="line"> END IF;</span><br><span class="line"> END</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql+qt基本命令</title>
    <url>/MySql-Lover/mysql-qt%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>– 创建一个名称为info的数据库。</p>
<p>create database info;</p>
<p>– 删除数据库info</p>
<p>– drop database info;</p>
<p>– 使用数据库 info</p>
<p>use info;</p>
<p>– 创建表</p>
<p>– create table student(id int primary key auto_increment, name varchar(255), age int, score int);</p>
<p>create table student(id int primary key, name varchar(255), age int, score int);</p>
<p>– 删除student表</p>
<p>– drop table student;</p>
<p>– 插入数据</p>
<p>insert into student(id, name, age) values(1, ‘mike’, 18);</p>
<p>insert into student(id, name, age, score) values(2, ‘lucy’, 22, 90);</p>
<p>insert into student(id, name, age, score) values(3, ‘Tom’, 20, 78);</p>
<p>– 更新数据</p>
<p>update student set score = 90 where id = 3;</p>
<p>– 查找数据</p>
<p>select * from student;</p>
<p>select score from student where name = ‘mike’;</p>
<p>– 删除数据库</p>
<p>delete from student where name = ‘mike’;</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>原始套接字</title>
    <url>/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>对于一个自定义的IP包，或者一个ICMP协议包，又是如何实现传送的呢？<br>原始套接字就允许对这些较底层次的协议（IP、ICMP、IGMP）进行直接访问。</p>
<p><strong>原始套接字定义</strong></p>
<p>原始套接字编程是一种非面向连接的、C/S传输方式的网络编程，使用原始套接字编程进行服务器端与客户端的通信前，首先要创建各自的套接字，然后对相应的套接字进行数据传输，在数据传输过程中，需要使用sendto()函数和recvfrom()函数进行发送与接收，在发送与接收函数中设置相应的IP地址。</p>
<p>扩展：原始套接字往往应用于高级网络编程，如比较流行的网络嗅探器（sniffer）、拒绝服务攻击（DOS）、IP欺骗等等都可以实现，并且还可以通过原始套接字来模拟IP的一些实用工具，如Ping命令。</p>
<p>1.创建函数<br>，如TCP套接字编程选择的是SOCK_STREAM类型的套接字，UDP套接字编程选择的是SOCK_DGRAM类型的套接字，而原始套接字编程则需要选择SOCK_RAW类型的套接字。<br>上述代码创建了一个AF_INET协议族中的原始套接字，协议类型为protocol。<br>协议类型protocol通常设置0，可以取值还包括如下四种：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>IPPROTO_IP、IPPROTO_ICMP、IPPROTO_TCP、IPPROTO_UDP</td>
</tr>
</tbody></table>
<p>说明：创建完原始套接字后，可以通过向网络中定义自己的IP数据包，但是在Linux系统中，为了保护网络系统的安全，规定只有超级用户才有创建原始套接口的权限。</p>
<p>2.设置套接字选项<br>函数setsockopt()主要用于实现对套接字相关的选项设置当前值。</p>
<p>int setsockopt(int s, int  level,  int  optname,  const  void  *optval, socklen_t optlen);</p>
<p>|参数解释<br>|-|-|<br>|参数s表示套接字描述符；<br>|参数level代表的是选项定义的层次，如IPPROTO_IP；<br>|参数optname代表套接字选项的名称，例如IP_HDRINCL表示要构造IP头部；<br>|参数optval表示指向存放选项数据的缓冲区的指针；<br>|参数optlen表示optval参数指向的缓冲区的长度。</p>
<p>当使用套接字选项IP_HDRINCL设置套接字后，接收和发送数据的时候，接收到的数据包含IP数据的，包含IP的头部。用户之后需要对IP层相关的数据段进行处理，例如IP头部数据的设置和分析，校验和的计算等。设置方法如下：<br>int set = 1;<br>if(setsockopt(rawsock, IPPROTO_IP, IP_HDRINCL, &amp;set, sizeof(set))&lt;0)<br>{<br>/<em>错误信息提示</em>/<br>}</p>
<p><strong>了解报文</strong></p>
<img src="/Linux-Lover/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="报文结构">








]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/Linux-Lover/%E9%94%81/</url>
    <content><![CDATA[<p>产生死锁的必要条件是什么？解决死锁有几种方法？</p>
<p>安全状态与不安全状态：安全状态指系统能按某种进程顺序来为每个进程分配其所需资源，直 至最大需求，使每个进程都可顺利完成。若系统不存在这样一个， 则称系统处于不安全状态。</p>
<p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再 向前推进。<br>产生死锁的原因：（1）竞争系统资源 （2）进程的推进顺序不当<br>满足四个条件：</p>
<ol>
<li>互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</li>
<li>占有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；</li>
<li>不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</li>
<li>循环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</li>
</ol>
<p>解决死锁的基本方法：</p>
<p>预防死锁：<br>（1）资源一次性分配：（破坏请求和保持条件）<br>（2）可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）<br>（3）资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<p>避免死锁:最具有代表性的避免死锁算法是银行家算法。</p>
<p>解除死锁:<br>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
<p>检测死锁<br>有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:<br>1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来<br>2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求<br> 如果第二步返回真,表示出现了死锁</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/Linux-Lover/UDP/</url>
    <content><![CDATA[<p><strong>基于UDP的网络编程</strong></p>
<p>主要用到的函数有socket()、bind()、sendto()、recvfrom()和close()。<br>UDP是面向无连接的网络通信，并不需要像TCP套接字编程那样需要通过connect()与服务器建立连接，然后调用listen()函数使服务器处于监听状态，在通过accept()函数接收客户端的连接请求。</p>
<p>UDP套接字编程，只需要创建用于通信的套接字，然后在服务器端绑定端口，然后就可以实现数据的传输。<br>在绑定了地址信息之后，进行数据传输时，服务器会阻塞recvfrom()函数，等待客户端调用sendto()函数发送数据，同时客户端的recvfrom()被阻塞，然后，服务器会调用recvfrom()函数接收数据，接着向客户端作出应答，同时，服务端的recvfrom()被阻塞，接着，客户端调用recvfrom()接收数据。</p>
<p>1.发送数据、函数sendto()<br>ssize_t  sendto(int  s,  const  void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf用于指向发送信息的缓冲区的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len是发送的信息的长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>to</td>
<td>参数to为存放接收处的信息的指针</td>
</tr>
<tr>
<td>tolen</td>
<td>参数tolen是接收方地址的大小</td>
</tr>
</tbody></table>
<p>说明：如果sendto()函数用于面向连接的网络通信时，套接字类型为SOCK_STREAM或SOCK_SEQPACKET。此时参数to指向NULL，参数tolen为0，若不为此值，就会出现错误信息提示。</p>
<p>2.接收数据、函数recvfrom()</p>
<p>ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>参数s代表套接字描述符</td>
</tr>
<tr>
<td>buf</td>
<td>参数buf指向接收信息的指针</td>
</tr>
<tr>
<td>len</td>
<td>参数len代表缓冲区的最大长度</td>
</tr>
<tr>
<td>flags</td>
<td>参数flags通常会设置为0，代表的是相关控制参数，主要用于控制是否接收数据以及是否预览报文</td>
</tr>
<tr>
<td>from</td>
<td>参数from表示发送此信息处的地址指针</td>
</tr>
<tr>
<td>fromlen</td>
<td>参数fromlen指向发送处地址大小的指针。</td>
</tr>
</tbody></table>
<p>字节序转换函数 </p>
<p>    uint32_t htonl(uint32_t hostlong);<br>    uint16_t htons(uint16_t hostshort);<br>    uint32_t ntohl(uint32_t netlong);<br>    uint16_t ntohs(uint16_t netshort);<br>    说明：在上述的函数中，h代表host；<br>    n代表network s代表short；l代表long</p>
<p>地址转换函数 </p>
<p>    #include &lt;netinet/in.h&gt;<br>    #include &lt;arpa/inet.h&gt;<br>    int inet_aton(const char *cp, struct in_addr *inp);<br>    in_addr_t inet_addr(const char *cp);<br>    char *inet_ntoa(struct in_addr in);</p>
<p>serv.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*服务器端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in s_addr;	//服务器地址结构</span><br><span class="line">	struct sockaddr_in c_addr;	//客户端地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	socklen_t addr_len;		//地址结构长度</span><br><span class="line">	int len;			//接收到的消息字节数</span><br><span class="line">	char buff[128];			//存放接收消息的缓冲区</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/*清空地址结构*/</span><br><span class="line">	memset(&amp;s_addr, 0, sizeof(struct sockaddr_in));</span><br><span class="line">/* 设置地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET;</span><br><span class="line">	s_addr.sin_port = htons(PORT);</span><br><span class="line">	s_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">/* 绑定地址和端口信息 */</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">bind</span>(sock, (struct sockaddr *) &amp;s_addr, sizeof(s_addr))) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"bind error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind address to socket successfuly.\n\r"</span>);</span><br><span class="line">/* 循环接收数据 */</span><br><span class="line">	addr_len = sizeof(c_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (1) &#123;</span><br><span class="line">		len = recvfrom(sock, buff, sizeof(buff) - 1, 0,(struct sockaddr *) &amp;c_addr, &amp;addr_len);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; 0) &#123;//接收失败</span><br><span class="line">			perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(errno);</span><br><span class="line">		&#125;</span><br><span class="line">		buff[len] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"收到来自远端计算机%s，端口号为%d的消息:\n%s\n\r"</span>,inet_ntoa(c_addr.sin_addr), ntohs(c_addr.sin_port), buff);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*客户端*/</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 8886</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;//定义变量</span><br><span class="line">	struct sockaddr_in s_addr;	//套接字地址结构</span><br><span class="line">	int sock;			//套接字描述符</span><br><span class="line">	int addr_len;			//地址结构长度</span><br><span class="line">	int len;			//发送字节长度</span><br><span class="line">	char buff[]=<span class="string">"Hello everyone,Merry Christmas!"</span>;	//发送的消息</span><br><span class="line">/* 创建数据报模式的套接字 */</span><br><span class="line">	<span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;</span><br><span class="line">		perror(<span class="string">"socket error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(errno);</span><br><span class="line">	&#125;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket successful.\n\r"</span>);</span><br><span class="line">/* 设置对方地址和端口信息 */</span><br><span class="line">	s_addr.sin_family = AF_INET; 	//地址族</span><br><span class="line"></span><br><span class="line">		s_addr.sin_port = htons(PORT);</span><br><span class="line">	<span class="keyword">if</span> (argv[1])</span><br><span class="line">		s_addr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"没有输入消息的接受者！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	addr_len = sizeof(s_addr);	//地址结构长度</span><br><span class="line">/*从客户端的buff缓冲区中发送消息到地址结构为s_addr的远端机器*/</span><br><span class="line">	len = sendto(sock, buff, sizeof(buff), 0,(struct sockaddr *) &amp;s_addr, addr_len);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; 0) &#123;			//如果发送失败</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\rsend error.\n\r"</span>);</span><br><span class="line">		<span class="built_in">return</span> 3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"send success.\n\r"</span>);	//发送成功</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/Linux-Lover/UDP/%E7%BB%93%E6%9E%9C.jpg" class="" title="结果">

]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/Linux-Lover/TCP/</url>
    <content><![CDATA[<p>__TCP三次握手，包头中的标志变化</p>
<img src="/Linux-Lover/TCP/TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class="" title="TCP3次握手">


<p>第一次握手：建立连接时，客户端发送 syn 包(tcp协议中syn位置1，序号为X)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p>
<p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN，同时自己也发送一个 SYN 包，即 SYN+ACK包（tcp协议中syn位置1，ack位置1，序号K，确定序号为X+1），此时服务器进入 SYN_RECV 状态；</p>
<p>第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(tcp协议中ack位置1，确认序号Y+1), 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手</p>
<img src="/Linux-Lover/TCP/%E5%8C%85.jpg" class="" title="TCP3次握手">

<p>seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。 </p>
<img src="/Linux-Lover/TCP/TCP.jpg" class="" title="accetp()一直阻塞到客户端连接">

<p>serv.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;netinet/in.h&gt;  // 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include&lt;arpa/inet.h&gt; // 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char sendbuf[256]=<span class="string">"ok"</span>;</span><br><span class="line">   char buf[256] ;</span><br><span class="line">   int s_fd,c_fd;// 服务器和客户套接字标识符</span><br><span class="line">   int s_len,c_len;// 服务器和客户消息长度</span><br><span class="line">   </span><br><span class="line">   struct sockaddr_in s_addr; // 服务器套接字地址</span><br><span class="line">   struct sockaddr_in c_addr;// 客户套接字地址</span><br><span class="line">   </span><br><span class="line">   s_fd = socket(AF_INET,SOCK_STREAM,0); //创建套接字</span><br><span class="line">   </span><br><span class="line">   s_addr.sin_family = AF_INET;//套接字的域</span><br><span class="line">   s_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">   s_addr.sin_port = PORT ;//定义服务器套接字端口</span><br><span class="line">   s_len = sizepf(s_addr);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">bind</span>(s_fd,(struct sockaddr *) &amp;s_addr,s_len);//绑定套接字 </span><br><span class="line">   </span><br><span class="line">   listen(s_fd,10); // 监听状态，守候进程,允许等待队列请求数10 </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"请稍后，等待客户端的发送数据\n"</span>);</span><br><span class="line">   </span><br><span class="line">   /*接收客户端请求*/</span><br><span class="line">   c_len = sizeof(c_addr);</span><br><span class="line">   c_fd = accetp(s_fd,(struct sockaddr*)&amp; c_addr,c_len); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">   &#123;</span><br><span class="line">    	<span class="keyword">if</span>(recv(c_fd,buf,256,0) &gt; 0) //收到客户   </span><br><span class="line">        &#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"收到客户端消息：\n %s\n"</span>,buf);</span><br><span class="line">         send(c_fd,sendbuf,sizeof(sendbuf),0);//回复客户</span><br><span class="line">   		 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	close(c_fd);// 关闭连接</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;		   // 包含套接字函数库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;			// 包含AF_INET相关结构</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;			// 包含AF_INET相关操作的函数</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 3339</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   int sockfd;								// 客户套接字标识符</span><br><span class="line">   int len;									// 客户消息长度</span><br><span class="line">   struct sockaddr_in addr;				// 客户套接字地址</span><br><span class="line">   int newsockfd;</span><br><span class="line">   char buf[256]=<span class="string">"come on!"</span>;//要发送的消息</span><br><span class="line">   int len2;							</span><br><span class="line">   char rebuf[256];  </span><br><span class="line">  </span><br><span class="line">	sockfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">   addr.sin_family = AF_INET;  // 客户端套接字地址中的域</span><br><span class="line">   addr.sin_addr.s_addr=htonl(INADDR_ANY);   </span><br><span class="line">   addr.sin_port = PORT;		// 客户端套接字端口</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   len = sizeof(addr);</span><br><span class="line">  	newsockfd = connect(sockfd,(struct sockaddr *)&amp;addr ,len);//发送连接服务器的请求</span><br><span class="line">  <span class="keyword">if</span> (newsockfd == -1)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">"连接诶失败\n"</span>);</span><br><span class="line">  <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">  len2 = sizeof(buf);</span><br><span class="line">  <span class="keyword">while</span>(1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要发送的数据:"</span>);</span><br><span class="line">    scanf(<span class="string">"%s"</span>,buf);</span><br><span class="line">    send(sockfd,buf,len2,0); //发送消息</span><br><span class="line">  <span class="keyword">if</span>(recv(sockfd,rebuf,256,0) &gt; 0)  //接收到</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"收到服务器消息:\n%s\n"</span>,rebuf);//输出到终端	</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  close(sockfd);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<img src="/Linux-Lover/TCP/%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" class="" title="基本套接字">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>美的面试</title>
    <url>/My-interview-Lover/%E7%BE%8E%E7%9A%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>四大业务：数字化业务、消费者家电、空调业务、机器人自动化</p>
]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Linux-Lover/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>1.计算机网络定义<br>所谓的计算机网络，就是一些互相连接的、自治的计算机的集合。计算机网络有很多种类别。<br>（1）根据不同的作用范围可以将计算机网络理解为广域网（WAN）、城域网（MAN）、局域网（LAN）、个人区域网（PAN）。<br>（2）根据不同的使用者，可以将计算机网络分为公用网和专用网。</p>
<p>2.计算机网络的通信模式<br>计算机网络的通信模式有两种，一种是线路交换，另一种是包交换。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>线路交换</td>
<td>就是我们家家最开始用的电话的网络连接技术，是通过在发送端和接受端之间建立一条特定的线路，进行数据的传输。</td>
</tr>
<tr>
<td>包交换</td>
<td>就是我们现在常用到的计算机的网络通信模式，是通过将所有的计算机放到一个共同的网络连接中，数据的发送端将要传输的数据分割成几份，然后将每一份数据封装成一个包，包中含有接收端的属性信息等，且每个包都是单独传输的。</td>
</tr>
</tbody></table>
<p>OSI 7层协议模型 和各个层次的 关系 </p>


<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
</tr>
<tr>
<td>数据链路层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>传输层</td>
</tr>
<tr>
<td>应用层</td>
</tr>
</tbody></table>
<p>TCP/IP通信协议采用了4层的层级结构，这4层分别为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。</td>
</tr>
<tr>
<td>传输层</td>
<td>在此层中提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据包协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中。这一层负责传送数据，并且确定数据已被送达并接收。</td>
</tr>
<tr>
<td>互联网络层</td>
<td>负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协（IP）。</td>
</tr>
<tr>
<td>网络接口层</td>
<td>对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。</td>
</tr>
</tbody></table>
<p><strong>拥塞控制、流量控制</strong></p>
<p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。<br>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。窗口控制机制</p>
<p>TCP和UDP协议的区别，谈谈增强UDP传输安全性的策略<br>共同点：都是传输层的协议<br>不同点：TCP面向连接（通信前要建立通信的通路），可靠性高<br>      UDP无连接，不可靠（可增加校验机制增加可靠性）</p>
<p>（*）组播的优点： </p>
<ol>
<li>需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。 </li>
<li>由于组播协议是根据接受者的需要，对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。IP协议允许有2亿6千多万个（268435456）组播，所以其提供的服务可以非常丰富。 </li>
<li>此协议和单播协议一样允许在Internet宽带网上传输。</li>
</ol>
<p>对于一个没有设置任何套接口选项的阻塞套接口，调用recv接收对方的数据，对方发送数据前突然断电，recv永远不会返回。</p>
<p><strong>TCP/IP层IP协议的服务是无连接数据报</strong></p>
<p>一台主机从一个网络移到另一个网络.IP地址需要改变，MAC地址不需要改变</p>
<p>经典题目：某公司申请到一个C类的IP地址，但要连接6个子公司，最大的一个子公司有26台计算机，每个子公司在一个网段中，则子网掩码应该为多少？<br>因为有六个子公司，所以必须有三位1，有26台，必须有五个0，所以二进制位11100000，转换为十进制是224</p>
<p>DNS是域名服务器，用来解析域名的（域名与IP之间的解析），如果没有这东西，你必须输入网站的IP地址，有了DNS，你就可以直接输入网址。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻式传感器</title>
    <url>/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>应变式 （丝式、箔式和薄膜式三种）</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%85%AC%E5%BC%8F.jpg" class="" title="应变式">

<p>要把电阻的变化转换为电压或电流的变化，需要转换电路来实现。转换电路常采用直流电桥或交流电桥。</p>
<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<img src="/Circuit-Lover/%E7%94%B5%E9%98%BB%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%A1%A5.jpg" class="">

<p><strong>压阻式传感器是基于半导体材料的压阻效应来工作的传感器</strong></p>
<p>__分为半导体应变式压阻传感器 、扩散型压阻传感器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">与金属电阻应变片相比，半导体应变式具有：体积小、横向效应小、灵敏度高等特点。</span><br><span class="line">将P型杂质扩散到N型硅底层上，形成一层极薄的导电P型层，装上引线接点后，即形成扩散型半导体应变片。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>电阻式传感器应用</th>
</tr>
</thead>
<tbody><tr>
<td>（1）应变式测力与荷重传感器</td>
</tr>
<tr>
<td>（2）应变式压力传感器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32单片机</title>
    <url>/MCU-Lover/STM32%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>时钟系统</strong></p>
<p>晶体振荡器与RC振荡器</p>
<p>注意：RC振荡器成本低，但是受电阻电容温度影响较大。</p>
<img src="/MCU-Lover/STM32%E5%8D%95%E7%89%87%E6%9C%BA/clock.jpg" class="">


<p>四种时钟源</p>
<p>HSI:高速内部时钟，RC振荡器，频率8MHz</p>
<p>HSE:高速外部时钟，4-16MHz</p>
<p>LSI:低速内部时钟，RC振荡器，40Hz,独立看门狗或RTC</p>
<p>LSE:低速内部时钟，32.768Hz,RTC时钟源。</p>
<p>ABP：内核等<br>AHP：外设等</p>
<p><strong>SysTick 定时器</strong></p>
<p>系统嘀嗒校准值固定为9000，当系统嘀嗒时钟设定为9MHz(HCLK/8的最大值)，产生1ms时间基准。<br>滴答定时器，2^24次方，向下递减，为0中断重新赋值。</p>
<p><strong>中断</strong></p>
<p>16个可编程的优先等级(使用了4位中断优先级)；</p>
<p>进入中断<br>进入中断</p>
<p>入堆栈ISR<br>保存现场{PC,PSR,R0-R3,R12,ISR} ISR:当前中断服务寄存器<br>保存完后，ISR进入中断<br>晚来的中断可以ISR进入，不用重新保存现场。</p>
<p>退出中断<br>出栈恢复现场<br>也可以被打断进入新的中断。</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机</title>
    <url>/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机构造:</span><br><span class="line">40引脚双列直插DIP封装, PO, P1, P2, P3,其中P0不仅作为普通的1/0口使用,还可以作为地址/数据线使用【双向口】总共32个输入输出引脚, 2个电源接地, 2个管教接晶振,复位和控制4个: EA 【内外存储选择引脚,EA 为低电平,只访问外部程序存储器】</span><br><span class="line"></span><br><span class="line">工作方式:复位位方式【RST引脚输入高电平有效】,单步执行方式【通过外来脉冲控制,来一个脉冲执行一条指令,借助外部中断功能】,程序执行方式【主要方式,复位后PC指向地址0000H,从此执行复制导址方式:立即寻址,直接寻址,寄存器寻址,寄存器间接寻址,变址寻址,相对寻址,位寻址</span><br><span class="line"></span><br><span class="line">512字节RAM 8字节ROM（EEPROM）</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/51.jpg" class="" width="51">




<p>__晶体与晶振</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">晶体（crystal）也叫做无缘晶体。它是石英晶片，镀上电极，装在支架上，放在外壳里，就是石英晶体振荡器，简称晶体。常见的有两只脚。</span><br><span class="line">晶振（crystal oscillator）也叫做有源晶振。在晶体的基础上，再加上振荡、放大或者整形电路，然后封装到壳子里，就是晶振。常见的有四只脚。</span><br></pre></td></tr></table></figure>

<img src="/MCU-Lover/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%99%B6%E4%BD%93%E4%B8%8E%E6%99%B6%E6%8C%AF.jpg" class="" title="晶体与晶振">


<p>常见问题 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、单片机中的程序计数器PC是16位的寻址范围是64KB怎么来的呀</span><br><span class="line">2 ^ 16，保存指示下一个指令地址</span><br><span class="line"></span><br><span class="line">2、三个周期</span><br><span class="line">时钟周期是单片机的基本时间单位。</span><br><span class="line">机器周期，它是CPU完成一个基本操作所需的时间。</span><br><span class="line">指令周期，是指CPU执行一条指令需要花费的时间。</span><br><span class="line">外接11.0592MHZ晶体，</span><br><span class="line">时钟周期=1/11.0592M</span><br><span class="line">机器周期=12/11.0592M ≈1.085us</span><br><span class="line">指令周期=1个，2个或4个机器周期</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习</title>
    <url>/shell-Lover/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>bash</strong><br>大多数Linux系统默认使用的shell，bash shell 是shell 的一个免费版本，它是最早的 Unix shell，bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。</p>
<p>注意：windows 下 powershell QAQ</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">编写：test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello world '</span></span><br><span class="line">运行 ./test.sh</span><br></pre></td></tr></table></figure>

<p><strong>定义</strong><br>shell是核心程序kernel之外的指令解析器，是一个程序，同时是一种命令语言和程序设计语言。</p>
<p>cat /etc/shells 看系统下的shell<br>echo $SHELL 看当前用户运行的shell</p>



<p>硬连接 ln  source_path target_path<br>软连接 ln -s source_path target_path</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	umask     文件      目录</span><br><span class="line">	0         6         7</span><br><span class="line">	1         5         6</span><br><span class="line">	2         4         5</span><br><span class="line">	3         3         4</span><br><span class="line">	4         2         3</span><br><span class="line">	5         1         2</span><br><span class="line">	6         0         1</span><br><span class="line">	7         0         0</span><br></pre></td></tr></table></figure>
<p><strong>基本概念及变量</strong></p>
<p>管道<br>把一个命令的输出作为另外一个命令的输入<br>ls -l| sort;  ls | sort<br>重定向  &lt; 输入   &gt;输出<br>与管道相关，可以改变程序运行的输入来源和输出地点<br>sort&lt; myfile.txt    //sort 行进行排序<br>sort&lt;myfile.txt &gt;myfile+sort.txt</p>
<p>unset 清除变量<br>unset testvar  ; 测试 echo $testvar;//空行输出<br>readonly的变量，不能被清除</p>



<p>位置变量<br>位置变量表示$0 $1 $2 $3····<br>$0 代表bash文件名称 其他就是命令行参数</p>
<p>bash默认建立了一些标准环境变量，可在/etc/profile中定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	EXINIT 	定义一些vim的初始化参数</span><br><span class="line">	HOME 	echo $HOME</span><br><span class="line">	IFS		在linux系统中字符之间的间隔</span><br><span class="line">	测试echo $IFS </span><br><span class="line">	LOGNAME </span><br><span class="line">	测试 echo $LOGNAME set |grep “LOG”</span><br><span class="line">	MAIL当前登录用户，其邮箱在什么地方存储</span><br><span class="line">	MAILCHECK</span><br><span class="line">	MAILPATH</span><br><span class="line">	TERM	登录服务器，终端类型vt100</span><br><span class="line">	PATH标准变量	</span><br><span class="line">	可以使用set |grep “PATH”来查看path配置路径</span><br><span class="line">	当我们在shell运行一个程序时，shell会从path路径中查找程序。</span><br><span class="line">	TZ	时区</span><br><span class="line">	PS1 提示符 </span><br><span class="line">	echo $PS1</span><br><span class="line">	PS1&#x3D;’[\u@\h \w] \$’  u代表用户名 h主机名 w代表当前目录 </span><br><span class="line">	可以自己更改PS1 比如： PS1&#x3D;”wangbaoming”</span><br><span class="line">	PS2 “&gt; ”  大尖括号+空格 在一行上面运行多个命令 命令打不完 \</span><br><span class="line">	PWD</span><br><span class="line">	SHELL 我当前运行的shell时那个shell解析器</span><br><span class="line">	MANPATH</span><br><span class="line">	TERMINFO</span><br></pre></td></tr></table></figure>

<p>表达式类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$[ ] 表示形式告诉shell对方括号中的表达式求值</span><br><span class="line">eg: echo $[3+9] </span><br><span class="line"></span><br><span class="line">适应不同进制</span><br><span class="line">[base#n]	n表示基数从2到36任意基数</span><br><span class="line">ming@ubuntu:~$ echo $[10#8+191] </span><br><span class="line">199</span><br><span class="line">ming@ubuntu:~$ echo $[16#a+191] </span><br><span class="line">201</span><br></pre></td></tr></table></figure>

<p>shell输入与输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &#39;请输入需要创建的文件路径：&#39; filepath</span><br><span class="line">touch $filepath</span><br><span class="line">echo &#39;创建成功&#39;</span><br><span class="line">ls -l $filepath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一些运算</span><br><span class="line"></span><br><span class="line">-z    空串</span><br><span class="line">-n    非空串</span><br><span class="line">-eq         数值相等。</span><br><span class="line">-ne         数值不相等。</span><br><span class="line">-gt         第一个数大于第二个数。</span><br><span class="line">-lt          第一个数小于第二个数。</span><br><span class="line">-le         第一个数小于等于第二个数。</span><br><span class="line">-ge         第一个数大于等于第二个数。</span><br><span class="line">加法运算：expr 10 + 10</span><br><span class="line">减法运算：expr 20 - 10</span><br><span class="line">加法运算：expr 10 &#x2F; 5</span><br><span class="line">乘法运算：expr 10 \* 5</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>shell Lover</category>
      </categories>
      <tags>
        <tag>shell基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL语言</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>很棒的一个链接：<a href="https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql" target="_blank" rel="noopener">https://cloudlandboy.github.io/myNote/#/backend/mysql/dbandsql</a><br>不会就打开看看QvQ</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>1、<strong>数据库由几个部分组成，这个结构有什么好处。</strong><br>答:①数据库、数据库管理系统（及其开发工具）、数据库管理员、应用系统。<br>三级模式:模式、外模式、内模式<br>两层映像结构:外模式模式映像,模式内模式映像<br>好处：保证了数据与程序的逻辑独立性和物理独立性</p>
<p>2、<strong>数据模型</strong></p>
<p>概念模型：实体、属性、码、实体型、实体集、联系</p>
<p>数据模型由数据结构、数据操纵、数据约束规则三个部分组成。</p>
<p>3、<strong>常见模型</strong><br>层次模型：<br>网状模型：<br>（重点）关系模型：<br>面向对象模型：<br>对象关系模型：<br>半结构化模型：</p>
<p>重点：<br>关系模型数据结构:二维表（关系、元组（行）、属性（列）码、域、分组、关系模式）<br>关系模型数据操纵:插入、删除、更新、查询。<br>关系模型数据完整性约束规则:实体完整性、参照完整性、用户自定义完整性。</p>
<p>4、<strong>关系模型</strong></p>
<p>（1）关系：域、笛卡尔积、关系..<br>扩展：<br>候选码(Candidate Key)：一个或者多个属性的集合，可以唯一确定实体的一个实例；<br>主码(Primary Key):从候选码中，选中用来作为唯一标识的属性或者属性组被称为主码；<br>可选码(Alternative Key):候选码中没有选中的其他码，称为可选码；</p>
<p>（2）关系操作：查询分一类，插入、删除、修改一类</p>
<p>关系数据库语言：关系代数与关系演算(SQL 两者的结合)<br>（3）关系代数</p>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.jpg" class="" title="关系代数">

<p>专门关系运算：选择、投射、连接、除运算。</p>


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%A4%96%E8%BF%9E%E6%8E%A5.jpg" class="" title="外连接是自然连接">

<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E9%99%A4%E6%B3%95.jpg" class="" title="除运算">

<p>（4）关系演算（*）</p>
]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>微波传感器</title>
    <url>/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<h5 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h5><p>微波是0.1m-1m的电磁波，波长相对较长的电磁波。对应的波段频率范围为300 MHz～3000 GHz。 </p>
<h5 id="微波特点"><a href="#微波特点" class="headerlink" title="微波特点"></a>微波特点</h5><p>(1)似光性和似声性<br>(2)分析方法的独特性<br>低频电路不适用<br>(3)共度性<br>电子在真空管内的渡越时间（10-9秒左右）与微波的振荡周期（ 10-9 ～10-15秒）相当的这一特性称共度性，利用该特性可以做成各种微波电真空器件，得到微波振荡源。<br>(4)穿透性<br>(5)信息性<br>(6)非电离性</p>
<h5 id="微波传感器"><a href="#微波传感器" class="headerlink" title="微波传感器"></a>微波传感器</h5><p><strong>原理</strong><br>微波传感器是利用微波特性来检测某些物理量的器件或装置。由发射天线发出微波，此波遇到被测物体时将被吸收或反射，使微波功率发生变化。若利用接收天线，接收到通过被测物体或由被测物体反射回来的微波，并将它转换为电信号，再经过信号调理电路，即可以显示出被测量，实现了微波检测。<br><strong>分类</strong><br>根据微波传感器的原理，微波传感器可以分为反射式和遮断式两类。<br><strong>组成</strong><br>微波传感器通常由微波发射器（即微波振荡器）、 微波天线及微波检测器三部分组成。<br><strong>微波振荡器</strong> 的器件有调速管、磁控管或某些固态器件，小型微波振荡器也可以采用体效应管<br><strong>微波天线</strong> 为了使发射的微波具有尖锐的方向性，天线要具有特殊的结构。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E5%A4%A9%E7%BA%BF.jpg" class="" title="微波天线">
<p><strong>微波检测器</strong><br>一种是将微波变化为电流的视频变化方式<br>一种是与本机振荡器并用而变化为频率比微波低的外差法。（差分方式）</p>
<h5 id="微波传感器应用"><a href="#微波传感器应用" class="headerlink" title="微波传感器应用"></a>微波传感器应用</h5><p><strong>微波液位计</strong></p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E4%BE%A7%E4%BD%8D%E8%AE%A1.jpg" class="" title="微波侧位计">

<p><strong>微波湿度传感器</strong></p>
<p>扩展：<br>一般干燥的物体，如木材、皮革、谷物、 纸张、 塑料等，其ε′在1～5范围内， 而水的ε′则高达64， 因此如果材料中含有少量水分子时，其复合ε′将显著上升， ε″也有类似性质。 使用微波传感器，测量干燥物体与含一定水分的潮湿物体所引起的微波信号的相移与衰减量， 就可以换算出物体的含水量。</p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="微波湿度传感器">

<p><strong>微波测厚仪</strong><br>利用微波在传播过程中遇到被测物体金属表面被反射，且反射波的波长与速度都不变的特性进行测厚的。<br>基本原理：<br>（1）在被测金属物体上下两表面各安装一个终端器。微波信号源发出的微波，经过环行器A、 上传输波导管传输到上终端器，由上终端器发射到被测物体上表面上，微波在被测物体上表面全反射后又回到上终端器，再经过传输导管、环行器A、下传输波导管传输到下终端器。</p>
<p>（2）由下终端器发射到被测物体下表面的微波，经全反射后又回到下终端<br>器，再经过传输导管回到环行器A。因此被测物体的厚度与微波传输过<br>程中的行程长度有密切关系，当被测物体厚度增加时，微波传输的行程<br>长度便减小。 </p>
<img src="/Circuit-Lover/%E5%BE%AE%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E5%BE%AE%E6%B3%A2%E6%B5%8B%E5%8E%9A%E4%BB%AA.jpg" class="" title="微波测厚仪">


<p><strong>微波辐射计（温度传感器）</strong>(*)</p>
<p><strong>微波测定移动物体的速度和距离</strong>(*)</p>
<p><strong>微波无损检测</strong>(*)</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程了解</title>
    <url>/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>1)socket可以看成是用户进程与内核网络协议栈的编程接口。<br>1)socket不仅可以用于本机的进程间通信，还可以用于网络上不同主机的进程间通信。</p>
<img src="/Linux-Lover/Socket%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3/1.jpg" class="">

<h5 id="大端、小端"><a href="#大端、小端" class="headerlink" title="大端、小端"></a>大端、小端</h5><p>0x 12 34 56 78<br>低字节78放高位地址，大端；高字节12放低位位地址<br>低字节78放低位地址，小端；高字节12放高位地址</p>
<p>大端：0x12345678<br>小端：0x87654321<br>#include <iostream><br>using namespace std;<br>int main ()<br>{<br>int i =0x12345678 ;<br>if (<em>(char</em>)&amp;i == 0x12) //地址转化再访问<br>{<br>cout &lt;&lt; “大端” &lt;&lt;endl;<br>}<br>else<br>{<br>cout &lt;&lt; “小端” &lt;&lt;endl;<br>}<br>}</p>
<h5 id="Socket-API基本用法"><a href="#Socket-API基本用法" class="headerlink" title="Socket API基本用法"></a>Socket API基本用法</h5><p>#include &lt;sys/socket.h&gt;</p>
<p><strong>socket函数</strong></p>
<p>int socket(int domain, int type, int protocol);<br>创建一个套接字用于通信</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>domain</td>
<td>指定通信协议族（protocol family）</td>
<td>AF_INET</td>
</tr>
<tr>
<td>type</td>
<td>指定socket类型</td>
<td>流式套接字SOCK_STREAM，数据报套接字SOCK_DGRAM，原始套接字SOCK_RAW</td>
</tr>
<tr>
<td>protocol</td>
<td>协议类型</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>bind函数</strong></p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>绑定一个本地地址到套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要绑定的地址</td>
</tr>
<tr>
<td>len</td>
<td>地址长度</td>
</tr>
</tbody></table>
<p><strong>listen函数</strong></p>
<p>一般来说，listen函数应该在调用socket和bind函数之后，调用函数accept之前调用。<br>int listen(int sockfd, int backlog);<br>参数sockfd 是socket()函数返回的套接字描述符；<br>参数backlog指定在请求队列中允许的最大请求数，</p>
<p>对于给定的监听套接口，内核要维护两个队列：<br>1、已由客户发出并到达服务器，服务器正在等待完成相应的TCP三路握手过程<br>2、已完成连接的队列</p>
<p><strong>accept函数</strong></p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<br>从已完成连接队列返回第一个连接，如果已完成连接队列为空，则阻塞。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>socket函数返回的套接字</td>
</tr>
<tr>
<td>addr</td>
<td>将返回对等方的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>返回对等方的套接字地址长度</td>
</tr>
</tbody></table>
<p><strong>connect函数</strong></p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>建立一个连接至addr所指定的套接字</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sockfd</td>
<td>未连接套接字</td>
</tr>
<tr>
<td>addr</td>
<td>要连接的套接字地址</td>
</tr>
<tr>
<td>addrlen</td>
<td>地址长度</td>
</tr>
</tbody></table>
<h5 id="Socket-API地址复用"><a href="#Socket-API地址复用" class="headerlink" title="Socket API地址复用"></a>Socket API地址复用</h5><p>SO_REUSEADDR：服务器端尽可能使用SO_REUSEADDR，在绑定之前尽可能调用setsockopt来设置SO_REUSEADDR套接字选项。</p>
<p>作用：使用SO_REUSEADDR选项可以使得不必等待TIME_WAIT状态消失就可以重启服务器</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int optval = 1;</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setsockopt bind\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Socket多客户端连接"><a href="#Socket多客户端连接" class="headerlink" title="Socket多客户端连接"></a>Socket多客户端连接</h5>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/Linux-Lover/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h5 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">中断分类</span><br><span class="line">	硬件中断（外部中断）</span><br><span class="line">	外部中断是指由外部设备通过硬件请求的方式产生的中断，也称为硬件中断</span><br><span class="line">	软件中断（内部中断）</span><br><span class="line">	内部中断是由CPU运行程序错误或执行内部程序调用引起的一种中断，也称为软件中断。</span><br></pre></td></tr></table></figure>
<h5 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号是UNIX系统响应某些状况而产生的事件，进程在接收到信号时会采取相应的行动。</span><br><span class="line">信号是因为某些错误条件而产生的，比如内存段冲突、浮点处理器错误或者非法指令等</span><br><span class="line">信号是在软件层次上对中断的一种模拟，所以通常把它称为是软中断</span><br></pre></td></tr></table></figure>
<h5 id="信号和中断的区别"><a href="#信号和中断的区别" class="headerlink" title="信号和中断的区别"></a>信号和中断的区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号与中断的相似点：</span><br><span class="line">（1）采用了相同的异步通信方式；</span><br><span class="line">（2）当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序；</span><br><span class="line">（3）都在处理完毕后返回到原来的断点；</span><br><span class="line">（4）对信号或中断都可进行屏蔽。</span><br><span class="line">信号与中断的区别：</span><br><span class="line">（1）中断有优先级，而信号没有优先级，所有的信号都是平等的；</span><br><span class="line">（2）信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行；</span><br><span class="line">（3）中断响应是及时的，而信号响应通常都有较大的时间延迟。</span><br></pre></td></tr></table></figure>
<h5 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIGABRT	进程停止运行 6</span><br><span class="line">SIGHUP	系统挂断</span><br><span class="line">SIGINT	终端中断  2</span><br><span class="line">SIGPIPE	向没有读者的管道写入数据</span><br><span class="line">SIGQUIT	终端退出   3</span><br><span class="line">SIGTERM	终止 </span><br><span class="line">SIGUSR1	用户定义信号1</span><br><span class="line">SIGUSR2	用户定义信号2</span><br><span class="line">SIGCHLD	子进程已经停止或退出  </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h4 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)忽略信号  </span><br><span class="line">	不采取任何操作、有两个信号不能被忽略：SIGKILL（9号信号）和SIGSTOP。如果应用程序可以忽略这2个信号，系统管理无法杀死、暂停进程，无法对系统进行管理。）。SIGKILL（9号信号）和SIGSTOP信号是不能被捕获的。</span><br><span class="line">2)捕获并处理信号   </span><br><span class="line">	内核中断正在执行的代码，转去执行先前注册过的处理程序。</span><br><span class="line">3)执行默认操作   </span><br><span class="line">	默认操作通常是终止进程，这取决于被发送的信号。</span><br></pre></td></tr></table></figure>

<h5 id="了解常见信号signal函数"><a href="#了解常见信号signal函数" class="headerlink" title="了解常见信号signal函数"></a>了解常见信号signal函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIG_IGN	屏蔽该信号</span><br><span class="line"> signal(2,SIG_IGN);</span><br><span class="line"> //ctrl+c 被屏蔽</span><br><span class="line">SIG_DFL	恢复默认行为</span><br><span class="line"> signal(2,SIG_DFL);</span><br></pre></td></tr></table></figure>
<h5 id="信号发送函数"><a href="#信号发送函数" class="headerlink" title="信号发送函数"></a>信号发送函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）int <span class="built_in">kill</span>(pid_t pid, int siq)</span><br><span class="line">	pid&gt;0 将信号sig发给pid进程</span><br><span class="line">	pid=0 将信号sig发给同组进程</span><br><span class="line">	pid=-1 将信号sig发送给所有进程，调用者进程有权限发送的每一个进程（除了1号、自身）</span><br><span class="line">	pid&lt;-1 将信号sig发送给进程组是pid（绝对值）的每一个进程</span><br><span class="line">    </span><br><span class="line">（2）raise(sig)等价于<span class="built_in">kill</span>(getpid(), sig);</span><br><span class="line"></span><br><span class="line">（3）killpg(pgrp, sig)等价于<span class="built_in">kill</span>(-pgrp, sig);</span><br><span class="line"></span><br><span class="line">（4）pause()函数将进程置为可中断睡眠状态。然后它调用内核函数schedule()，使linux进程调度器找到另一个进程来运行。调用者进程挂起，直到一个信号被捕获</span><br><span class="line"></span><br><span class="line">（5）alarm函数，设置一个闹钟延迟发送信号告诉linux内核n秒中以后，发送SIGALRM信号//alarm(1)</span><br><span class="line"></span><br><span class="line">搭配使用：	</span><br><span class="line">void  myhandle(int num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"recv signal id num : %d \n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGALRM, myhandle) == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"func signal err\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">alarm(1);//调用myhandle</span><br></pre></td></tr></table></figure>
<h5 id="可睡眠中断与不可睡眠中断"><a href="#可睡眠中断与不可睡眠中断" class="headerlink" title="可睡眠中断与不可睡眠中断"></a>可睡眠中断与不可睡眠中断</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sleep(100);//可以中断睡眠，内核让进程睡眠，可以被别的信号唤醒，继续往下运行。</span><br><span class="line">要不可中断睡眠，醒来继续运行sleep。根据sleep会返回剩余秒数。</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">  n = sleep (100);</span><br><span class="line">&#125;<span class="keyword">while</span>(n &gt; 0)；</span><br><span class="line">醒来继续睡。。。</span><br><span class="line">pause();//可中断睡眠</span><br></pre></td></tr></table></figure>
<h5 id="不可重入与可重入函数"><a href="#不可重入与可重入函数" class="headerlink" title="不可重入与可重入函数"></a>不可重入与可重入函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可重入函数每次可能调用效果不一样。</span><br><span class="line">全局变量、mallco函数调用（重新覆盖很恐怖）。</span><br><span class="line"></span><br><span class="line">所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</span><br><span class="line"></span><br><span class="line">启示：尽量不使用全局变量和静态变量的函数。特别是这个变量在程序中随时读写。</span><br></pre></td></tr></table></figure>

<h5 id="信号阻塞、未决、忽略"><a href="#信号阻塞、未决、忽略" class="headerlink" title="信号阻塞、未决、忽略"></a>信号阻塞、未决、忽略</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">信号屏蔽状态字（block）、信号未决状态字（pending）、忽略标志。</span><br><span class="line">注：阻塞和忽略是不同，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">向进程发送SIGINT，内核首先判断信号屏蔽状态字是否阻塞，信号未决状态字（pending相应位制成1；若阻塞解除，信号未决状态字（pending）相应位制成0；表示信号可以抵达了。</span><br><span class="line">block状态字、pending状态字 64bit；</span><br><span class="line">block状态字用户可以读写，pending状态字用户只能读；这是信号设计机制。</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/%E4%BF%A1%E5%8F%B7/1.jpg" class="" title="来源：linux编程王保明">


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigset_t pset; //用来打印的信号集</span><br><span class="line">sigset_t bset; //用来设置阻塞的信号集</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;bset);</span><br><span class="line">sigaddset(&amp;bset, SIGINT);</span><br><span class="line"></span><br><span class="line">sigprocmask()读取或更改进程的信号屏蔽状态（block） </span><br><span class="line">eg:</span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;bsetbset,NUU);//阻塞</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;bset,NULL);//解除阻塞</span><br><span class="line">sigpending(&amp;pset);//获取未决字信息</span><br></pre></td></tr></table></figure>

<h5 id="可靠信号、不可靠信号"><a href="#可靠信号、不可靠信号" class="headerlink" title="可靠信号、不可靠信号"></a>可靠信号、不可靠信号</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不可靠信号</span><br><span class="line">unix系统，进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理</span><br><span class="line">可靠信号</span><br><span class="line">linux优化，信号的发送和安装也出现了新版本：信号发送函数sigqueue()及信号安装函数sigaction()</span><br><span class="line">扩展：</span><br><span class="line">非实时信号都不支持排队，都是不可靠信号</span><br><span class="line">实时信号都支持排队，都是可靠信号</span><br></pre></td></tr></table></figure>
<h5 id="信号的高级用法"><a href="#信号的高级用法" class="headerlink" title="信号的高级用法"></a>信号的高级用法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sigaction函数注册信号处理函数</span><br><span class="line"></span><br><span class="line">sigqueue新的信号发送函数</span><br><span class="line">原型:int sigqueue(pid_t pid, int sig, const union sigval value);</span><br><span class="line"></span><br><span class="line">和<span class="built_in">kill</span>函数相比Int <span class="built_in">kill</span>(pid_t pid, int siq)多了参数</span><br><span class="line">但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解守护进程</title>
    <url>/Linux-Lover/%E8%A7%A3%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">守护进程是在后台运行不受控端控制的进程，通常情况下守护进程在系统启动时自动运行。</span><br><span class="line">守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</span><br></pre></td></tr></table></figure>
<h5 id="了解会话期"><a href="#了解会话期" class="headerlink" title="了解会话期"></a>了解会话期</h5> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 远程登录服务器，登录成功之后，linux服务器和终端之间建立一个会话期，会话期默认启动shell程序。</span><br><span class="line">注：</span><br><span class="line">shell是进程组， ps -ef | grep xx 也是进程组。。。都在终端中，如果想脱离终端，必须建立子进程代替父进程，该子进程为未来守护进程，调用setsid创建新的会话期。</span><br></pre></td></tr></table></figure>
<h5 id="手动创建守护进程步骤"><a href="#手动创建守护进程步骤" class="headerlink" title="手动创建守护进程步骤"></a>手动创建守护进程步骤</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)调用fork(),创建新进程，它会是将来的守护进程</span><br><span class="line">2)在父进程中调用<span class="built_in">exit</span>，保证子进程不是进程组组长</span><br><span class="line">3)调用setsid创建新的会话期</span><br><span class="line">4)将当前目录改为根目录 （如果把当前目录作为守护进程的目录，当前目录不能被卸载，它作为守护进程的工作目录了。</span><br><span class="line">5）将标准输入、标准输出、标准错误重定向到/dev/null</span><br></pre></td></tr></table></figure>
<h5 id="调用api创建守护进程"><a href="#调用api创建守护进程" class="headerlink" title="调用api创建守护进程"></a>调用api创建守护进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line">nochdir：=0将当前目录更改至“/”</span><br><span class="line">noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”</span><br><span class="line">例子:</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">int setup_daemon(int nochdir, int noclose);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    mydaemon(1, 1);</span><br><span class="line">    //man daemon 可以看到</span><br><span class="line">    //0表示改变重定向   1表示不改变</span><br><span class="line">    //daemon(1, 1);  //调用函数</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test ...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) ;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mydaemon(int nochdir, int noclose) //自建函数</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == -1)</span><br><span class="line">        ERR_EXIT(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; 0)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    setsid();</span><br><span class="line">    <span class="keyword">if</span> (nochdir == 0)</span><br><span class="line">        <span class="built_in">chdir</span>(<span class="string">"/"</span>);//系统调用函数改变当前路径 </span><br><span class="line">		<span class="keyword">if</span> (noclose == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        <span class="keyword">for</span> (i=0; i&lt;3; ++i)</span><br><span class="line">            close(i);</span><br><span class="line">        open(<span class="string">"/dev/null"</span>, O_RDWR);  </span><br><span class="line">        dup(0); //标准输出 也指向/dev/null  //    dup2(0, 1);</span><br><span class="line">        dup(0); //标准错误输出，也指向/dev/null //    dup2(0, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>来源：Linux应用编程王保明</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程概念</title>
    <url>/Linux-Lover/%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程是操作系统分配的内存、CPU时间片等资源的基本单位,是资源分配的最小单位(线程是CPU执行单位)。</span><br><span class="line">进程是操作系统对资源的一种抽象，一个进程由三部分组成:</span><br><span class="line">1）进程控制块PCB：用于描述进程情况及控制进程运行所需的全部信息。</span><br><span class="line">2）代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</span><br><span class="line">3）数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</span><br><span class="line">分式操作系统 </span><br><span class="line">基于时间片轮转，每一个进程有自己的地址空间和执行状态。</span><br></pre></td></tr></table></figure>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作系统经典三态:就绪	等待、（阻塞）、运行等</span><br><span class="line">还有其他挂起、僵尸进程等。。。</span><br><span class="line">Linux内核中的进程状态：</span><br><span class="line">▽	运行状态</span><br><span class="line">▽	可中断睡眠状态7</span><br><span class="line">▽	不可中断睡眠状态</span><br><span class="line">▽	暂停状态</span><br><span class="line">▽	僵死状态</span><br></pre></td></tr></table></figure>
<h5 id="进程调度及调度算法"><a href="#进程调度及调度算法" class="headerlink" title="进程调度及调度算法"></a>进程调度及调度算法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先来先服务调度算法</span><br><span class="line">短进程优先调度算法</span><br><span class="line">高优先级优先调度算法</span><br><span class="line">时间片轮转法（公平）</span><br></pre></td></tr></table></figure>

<h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程描述信息（进程标识符）</span><br><span class="line">进程控制信息（进程当前状态等）</span><br><span class="line">资源信息（I/O设备号、缓冲、内存等）</span><br><span class="line">现场保护信息（寄存器、PC、PSW、栈指针）</span><br></pre></td></tr></table></figure>
<h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、分配一个内部标识，在内核中建立进程结构.</span><br><span class="line">复制父进程的环境。</span><br><span class="line">2、为进程分配资源，包括所有元素（程序、数据、用户栈等，复制父进程地址空间的内容到该进程地址空间中。</span><br><span class="line">3、置该进程的状态为就绪，插入就绪队列。</span><br></pre></td></tr></table></figure>
<h5 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关闭软中断:因为进程即将终止而不再处理任何软中断信号；</span><br><span class="line">回收资源：释放进程分配的所有资源，如关闭所有已打开文件，释放进程相应的数据结构等；</span><br><span class="line">写记帐信息：将进程在运行过程中所产生的记帐数据（其中包括进程运行时的各种统计信息）记录到一个全局记帐文件中；</span><br><span class="line">置该进程为僵死状态:向父进程发送子进程死的软中断信号，将终止信息status送到指定的存储单元中；</span><br><span class="line">转进程调度:因为此时CPU已经被释放，需要由进程调度进行CPU再分配。</span><br></pre></td></tr></table></figure>
<h5 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">避免僵尸进程</span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line">signal(SIGCHLD, SIG_IGN);//子进程信号，忽略</span><br></pre></td></tr></table></figure>

<h5 id="1：n-的机制"><a href="#1：n-的机制" class="headerlink" title="1：n 的机制"></a>1：n 的机制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、从子进程获得父进程id容易。</span><br><span class="line">2、把子进程id返回给父进程，以便控制</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程获取标识</title>
    <url>/Linux-Lover/%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程ID</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"UID=%ld\n"</span>,(long)getuid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"EUID=%ld\n"</span>,(long)geteuid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">用户ID  创建者信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int flag1,flag2;</span><br><span class="line">flag1=setuid(0);</span><br><span class="line">flag2=setgid(500);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag1=%d\n,flag2=%d\n"</span>,flag1,flag2);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">用户组ID  用户组信息</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"group ID=%d\n"</span>,(long)getgid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"effective group ID=%d\n"</span>,(long)getegid());</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/Linux-Lover/%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>什么是线程</strong></p>
<p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”<br>一切进程至少都有一个执行线程  </p>
<p><strong>进程与线程</strong></p>
<p>进程是资源竞争的基本单位<br>线程是程序执行的最小单位<br>线程共享进程数据，但也拥有自己的一部分数据<br>    线程ID<br>    程序计数器<br>    寄存器组<br>    栈<br>    errno</p>
<p>一个进程内部的线程可以共享资源<br>    代码段<br>    数据段<br>    打开文件和信号</p>
<p>fork和创建新线程的区别<br>    当一个进程执行一个fork调用的时候，会创建出进程的一个新拷贝，新进程将拥有它自己的变量和它自己的PID。这个新进程的运行时间是独立的，它在执行时几乎完全独立于创建它的进程<br>    在进程里面创建一个新线程的时候，新的执行线程会拥有自己的堆栈（因此也就有自己的局部变量），但要与它的创建者共享全局变量、文件描述符、信号处理器和当前的工作目录状态</p>
<p>pthread_create函数<br>    功能：创建一个新的线程<br>pthread_exit函数<br>    功能：线程终止<br>pthread_join函数<br>    功能：等待线程结束<br>pthread_cancel函数<br>    功能：取消一个执行中的线程</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>void *</title>
    <url>/C-C-Lover/id/</url>
    <content><![CDATA[<p>C语言中void *为不确定类型指针.</p>
<p>void* 可以用来声明指针。<br>例如: void <em>a;<br>(1) void</em>可以接受任何的t值:void *a= NULL；<br>   int  *b=NULL；<br>   a= b; 任何类型的指针都可以直接赋值给它,无需进行强制类型转换</p>
<p>(2) void<em>可以赋值给任何类型的变量但是需要进行强制转换:<br>例如：int a = NULL;void*b;a = (int</em>) b:</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件</title>
    <url>/Linux-Lover/%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="文件自身信息"><a href="#文件自身信息" class="headerlink" title="文件自身信息"></a>文件自身信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//索引节点所包含信息存在结构体<span class="built_in">stat</span></span><br><span class="line">struct <span class="built_in">stat</span></span><br><span class="line">&#123;</span><br><span class="line">dev_t stdev; /*文件使用设备号*/</span><br><span class="line">ino_t st_ino;  /*索引节点*/</span><br><span class="line">mode_t st_mode; /*访问模式*/</span><br><span class="line">nlink_t st_nlink;/*硬链接*/</span><br><span class="line">uidt st_uid; /*所有者用户ID*/</span><br><span class="line">gid_t st_gid; /*用户组ID*/</span><br><span class="line">dev_t st_rdev;/*设备文件设备号 */</span><br><span class="line">off_t st_size; /*文件大小 字节单位/</span><br><span class="line">blksize_t st_blksize; /*系统磁盘块大小*/</span><br><span class="line">blkcnt_t st blocks; /*文件磁盘块大小*/</span><br><span class="line">time_t st_atime; /*最后一次访问时间*/</span><br><span class="line">time_t st_mtime; /*最后一次修改时间*/</span><br><span class="line">time_t st_ctime; /*最后一次修改文件状态时间*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">根据处理的不同：</span><br><span class="line">缓冲区文件、非缓冲区文件（系统I/O，二进制文件）</span><br><span class="line"></span><br><span class="line">缓冲：缓冲区的大小由各个具体的C 版本确定，一般为512 字节。</span><br><span class="line">全缓冲(文件把缓冲区写满才写到文件里)</span><br><span class="line">行缓冲（<span class="built_in">printf</span>）</span><br><span class="line">无缓冲（内核调用函数）</span><br><span class="line">根据其存放数据的作用的不同：</span><br><span class="line">其分为普通文件、目录文件、链接文件、设备文件和管道文件</span><br></pre></td></tr></table></figure>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IO操作分两类</span><br><span class="line">基于文件描述符的IO操作、基于数据流的IO操作</span><br><span class="line"></span><br><span class="line">文件描述符</span><br><span class="line">打开磁盘文件一次，内核创建一个文件表项，文件表项包含文件状态信息、存储内容缓存、当前文件路径等。</span><br><span class="line">例如：table[0]=a、table[1]=b、table[3]=c</span><br><span class="line">a,b,c文件表项，描述符为0,1，2 。可以用des[3] = &#123;0,1,2&#125;保存访问磁盘文件。</span><br><span class="line">头文件<span class="comment">#include&lt;unistd.h&gt;。linux系统提供，open（）、close、read（）、write（）、lseek（）等</span></span><br><span class="line">eg:ssize_t <span class="built_in">read</span>(int fp,char *buf,size_t count)</span><br><span class="line">off_t lseek(int fildes,off_t,int <span class="built_in">whence</span>)</span><br><span class="line">参数<span class="built_in">whence</span>:</span><br><span class="line">SEEK_SET:文件开头</span><br><span class="line">SEEK_CUR:文件偏移量</span><br><span class="line">SEEK_END:文件结尾</span><br><span class="line"></span><br><span class="line">数据流概述</span><br><span class="line">标准I/O库函数，stdio.h头文件</span><br><span class="line">fopen()、fread()、fclose()、fgetc(0）、fscanf()等</span><br><span class="line">eg: FILE open （const char * path ,const char *mode）</span><br><span class="line">char *fgets(char *s ,int size,FILE *stream);</span><br><span class="line">int fputs(char *s FILE *stream);</span><br><span class="line"></span><br><span class="line">size_t fread(void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">size_t fwrite(const void *ptr,size_t size ,size nmemb,FILE *stream);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库安全性</title>
    <url>/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h5 id="数据库安全概述"><a href="#数据库安全概述" class="headerlink" title="数据库安全概述"></a>数据库安全概述</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据库安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</span><br><span class="line">数据库不安全因素:</span><br><span class="line">(1)非授权用户对数据库进行破坏</span><br><span class="line">(2)数据库重要或者敏感数据泄露</span><br><span class="line">(3)安全环境的脆弱性</span><br></pre></td></tr></table></figure>
<h5 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安全标准：TCSEC标准、CC标准(TCSEC相互总结互补发展而来)</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/1.jpg" class="" title="TCSEC标准">


<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/2.jpg" class="" title="CC标准">

<h5 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）用户身份鉴别</span><br><span class="line">	静态鉴别、动态鉴别、生物鉴别、智能卡鉴别。</span><br><span class="line">（2）存取控制 （自主存取控制和强制存取控制，定义用户权限和合法权限检查机制）</span><br><span class="line">	授权:授予和收回</span><br><span class="line">    </span><br><span class="line">	GRANT  &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	TO &lt;用户&gt;</span><br><span class="line">	WITH GRANT OPTION ;（能传递权限，但不能形成循环传递）</span><br><span class="line"></span><br><span class="line">	REVOKE &lt;权限&gt;</span><br><span class="line">	ON  &lt;对象&gt;</span><br><span class="line">	FROM &lt;用户&gt;</span><br><span class="line"></span><br><span class="line">（3）视图机制</span><br><span class="line"></span><br><span class="line">（4）审计</span><br><span class="line">审计功能把用户对数据库的所有操作自动记录下来放入审计日志(auditlog)中。</span><br><span class="line">审计员可以利用审计日志监控数据库中的各种行为,重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。</span><br><span class="line">AUDIT ALTER，PDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line">NOAUDIT ALTER ,UPDATA</span><br><span class="line">ON SC ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（5）数据加密：传输加密、存储加密</span><br><span class="line">其他安全性保护：推理控制、隐蔽信道、数据隐私保护。</span><br></pre></td></tr></table></figure>
<img src="/MySql-Lover/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/3.jpg" class="" title="视图例子">]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>进程创建、等待、结束</title>
    <url>/Linux-Lover/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork 系统调用"></a>fork 系统调用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一次调用，二次返回？</span><br><span class="line">答：如果成功创建一个子进程，对于父进程来说返回子进程ID</span><br><span class="line">如果成功创建一个子进程，对于子进程来说返回值为0</span><br><span class="line">问题的本质是：两次返回，是在各自的进程空间中返回的。</span><br><span class="line">子进程和父进程各有自己的内存空间 （fork：代码段、数据段、堆栈段、PCB进程控制块的copy）。</span><br><span class="line">fork返回值大于零的是父进程，为什么这样设计:？</span><br><span class="line">答：因为父进程求子进程的pid比较困难，子进程求父进程的id比较容易</span><br></pre></td></tr></table></figure>
<h5 id="fork-c"><a href="#fork-c" class="headerlink" title="fork.c"></a>fork.c</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">    //子进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the child process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">    //父进程</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in the parent process!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="vfork-与fork区别"><a href="#vfork-与fork区别" class="headerlink" title="vfork 与fork区别"></a>vfork 与fork区别</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vfork函数vfork函数与fork函数相同,都是系统调用函数,两者的区别是在创建子进程时, fork函数会复制所有的父送源,包括进程环境、内荐资源等。而vfork函数在创建子进程时,不会复制父进程的所有资源,父子进程共享空间，可以修改父进程内存空间中的值。</span><br><span class="line">注意：在使用vfork函数时,父进程会被阻塞,需要学进程调用_exit函数退出子进程,不能使用<span class="built_in">exit</span>退出.</span><br></pre></td></tr></table></figure>
<h5 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">int gvar=2;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int var=5;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"process id:%ld\n"</span>,(long)getpid());//getpid 获取当前进程id</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"gvar=%d var=%d\n"</span>,gvar,var);</span><br><span class="line">	<span class="keyword">if</span>((pid=vfork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"error!"</span>);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		gvar--;</span><br><span class="line">		var++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		_exit(0);//退出子程序</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the parent process id:%ld\ngvar=%d var=%d\n"</span>,(long)getpid(),gvar,var);</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行简要结果 ： //当前</span><br><span class="line">	process id:2825</span><br><span class="line">	gvar=2 var=5</span><br><span class="line">	the child process id:2826</span><br><span class="line">	gvar=1 var=6//子进程  共享变量的修改</span><br><span class="line">	the parent process id:2825//父进程</span><br><span class="line">	gvar=1 var=6</span><br></pre></td></tr></table></figure>
<h5 id="exec调用函数"><a href="#exec调用函数" class="headerlink" title="exec调用函数"></a>exec调用函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       <span class="comment">#include &lt;unistd.h&gt; </span></span><br><span class="line">       extern char **environ;</span><br><span class="line">       int execl(const char *path, const char *arg, ...); </span><br><span class="line">       int execlp(const char *file, const char *arg, ...); </span><br><span class="line">       int execle(const char *path, const char *arg,</span><br><span class="line">                  ..., char * const envp[]);    </span><br><span class="line">       int execv(const char *path, char *const argv[]);</span><br><span class="line">       int execvp(const char *file, char *const argv[]);</span><br><span class="line">参数说明：</span><br><span class="line">	path参数表示你要启动程序的名称包括路径名</span><br><span class="line">	arg参数表示启动程序所带的参数</span><br><span class="line">	返回值:成功返回0,失败返回-1</span><br><span class="line">函数名说明： </span><br><span class="line">    l代表可变参数列表，p代表在path环境变量中搜索file文件。envp代表环境变量。</span><br><span class="line">例子1：</span><br><span class="line">----------------execve.c-----------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">/*	execve(<span class="string">"new"</span>,argv,environ);</span><br><span class="line">	puts(<span class="string">"正常情况下无法输出此信息"</span>);</span><br><span class="line">*/</span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create child process failed!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	       execve(<span class="string">"new"</span>,argv,environ);//文件名字+当前路径+环境变量</span><br><span class="line">           // execve(<span class="string">"./new"</span>,NULL,NULL);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		puts(<span class="string">"正常情况下输出此信息"</span>); //不想舍去放在父进程</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------new2.c----------------</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	puts(<span class="string">"welcome to mrsoft"</span>);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">例子2：用execlp调用vi,打开了new2.c</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;2)</span><br><span class="line">	&#123;</span><br><span class="line">	 	 <span class="built_in">printf</span>(<span class="string">"vi的等效用法： %s filename\n"</span>,argv[0]);</span><br><span class="line">		<span class="built_in">return</span> 1;</span><br><span class="line"> 	 &#125;</span><br><span class="line">	  execlp(<span class="string">"/bin/vi"</span>,<span class="string">"vi"</span>,argv[1],(char*)NULL);//文件路径+操作变量名+操作的文件+NULL</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">运行时输入命令：./execlp ./new2.c</span><br></pre></td></tr></table></figure>

<h5 id="wait等待函数"><a href="#wait等待函数" class="headerlink" title="wait等待函数"></a>wait等待函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	父进程没有调用等待函数，子进程会变成僵尸进程。</span><br><span class="line">	僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程。</span><br><span class="line">	孤儿进程：如果父亲进程先结束，子进程会托孤给1号进程</span><br><span class="line">-------------------</span><br><span class="line">    子进程结束，内核会向父进程发送SIGCHLD信号，子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）</span><br><span class="line">    如果存在子进程,进程时的结束状态有(status)如下两种可能: </span><br><span class="line">	进程正常结束：status和PID，status存在子进程退出码（子进程main返回参数或者exti返回参数）当中。</span><br><span class="line"></span><br><span class="line">   信号引起子进程结束：若发送的信号被进程捕获,就不会起到终止进程作用;若信号没有被进程捕误,则会使进程非正常结束。此时参数status返回的状态值为接收到的信号 ,存在最后一个字节中。</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line">void exit_s(int status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(WIFEXITED(status)) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"normal exit,status=%d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"signal exit!status=%d\n"</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid,pid1;</span><br><span class="line">	int status;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child process error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the child process!\n"</span>);</span><br><span class="line">		pid1=getpid();</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,9);//结束   信号退出</span><br><span class="line">	//	<span class="built_in">kill</span>(pid1,17);//进入父进程  <span class="built_in">wait</span> erro</span><br><span class="line">		<span class="built_in">kill</span>(pid1,19);//终止   直接退出</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">wait</span>(&amp;status)!=pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this is a parent process!\nwait error!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(0);</span><br><span class="line">	&#125;</span><br><span class="line">	exit_s(status);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">扩展：</span><br><span class="line">宏定义</span><br><span class="line">WIFEXITED(status)	如果子进程正常结束，返回一个非零值</span><br><span class="line">WEXITSTATUS(status)	如果WIFEXITED非零，返回子进程退出码</span><br><span class="line">WIFSIGNALED(status)	子进程因为捕获信号而终止，返回非零值</span><br><span class="line">WTERMSIG(status)	如果WIFSIGNALED非零，返回信号代码</span><br><span class="line">WIFSTOPPED(status)	如果子进程被暂停，返回一个非零值</span><br><span class="line">WSTOPSIG(status)	如果WIFSTOPPED非零，返回一个信号代码</span><br><span class="line">waitip()也用于等待特定进程。调用<span class="built_in">wait</span>或者waitpid函数查询子进程退出状态，此方法父进程会被挂起。</span><br><span class="line">如果不想让父进程挂起，可以在父进程中加入一条语句：</span><br><span class="line">signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</span><br></pre></td></tr></table></figure>
<h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 与_exit()</span><br><span class="line">相同：无论调用成功与否，无返回信息。</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">1）_exit是一个系统调用，<span class="built_in">exit</span>是一个c库函数</span><br><span class="line">2）<span class="built_in">exit</span>会执行清除I/O缓存，可能会丢失临时文件，建议不用。（前面例子，不做说明）</span><br><span class="line">3）<span class="built_in">exit</span>会执行调用终止处理程序</span><br><span class="line"></span><br><span class="line">扩展：atexit（）</span><br><span class="line">代码:</span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello1...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void func2()</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">"hello2...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">atexit(func1);//输出func1</span><br><span class="line">atexit(func2);//输出func2</span><br><span class="line">puts(<span class="string">"hello...\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line">运行：</span><br><span class="line">hello...</span><br><span class="line">hello2...</span><br><span class="line">hello1...</span><br></pre></td></tr></table></figure>


<h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进程终止的5种方式</span><br><span class="line">正常退出</span><br><span class="line">1)从main函数返回</span><br><span class="line">2)调用<span class="built_in">exit</span></span><br><span class="line">3)调用_exit</span><br><span class="line">异常退出</span><br><span class="line">4)调用abort   产生SIGABOUT信号</span><br><span class="line">5)由信号终止  ctrl+c SIGINT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/Data-Structure-and-Algorithms-Lover/d/</url>
    <content><![CDATA[<h5 id="LeetCode-总结"><a href="#LeetCode-总结" class="headerlink" title="LeetCode 总结"></a>LeetCode 总结</h5><h5 id="二叉树最大路径和"><a href="#二叉树最大路径和" class="headerlink" title="二叉树最大路径和"></a>二叉树最大路径和</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">&#125;;</span><br><span class="line">int OneSideMax(TreeNode *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootroot-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value + OneSideMax(root-&gt;right);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">        int a = OneSideMax(root-&gt;left);</span><br><span class="line">        int b = OneSideMax(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;     </span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> root-&gt;value + b;</span><br><span class="line">        &#125;</span><br><span class="line">  		  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">return</span> root-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*判断树是否为镜像,判断优先考虑递归QAQ*/</span><br><span class="line">bool isSym(struct TreeNode *root1 ,struct TreeNode *root2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == NULL &amp;&amp; root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==NULL || root2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root1-&gt;left,root2-&gt;right)&amp;&amp;isSym(root1-&gt;right,root2-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetric(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isSym(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">输出镜像树</span><br><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct TreeNode* Swap(struct TreeNode* root)</span><br><span class="line">&#123;   </span><br><span class="line">     <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(root-&gt;left);</span><br><span class="line">    Swap(root-&gt;right);</span><br><span class="line">    struct TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left  =  root-&gt;right ;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">return</span>  Swap(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树还原"><a href="#二叉树还原" class="headerlink" title="二叉树还原"></a>二叉树还原</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*前序遍历和中序遍历的结果还原一棵二叉树*/</span><br></pre></td></tr></table></figure>
<h5 id="N树"><a href="#N树" class="headerlink" title="N树"></a>N树</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构框架</title>
    <url>/Data-Structure-and-Algorithms-Lover/%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>记言：被华为的笔试题弄晕了，才发现自己的数据结构和算法是多么的苍白无力，但我会变强的QAQ。<br>2019-4-15 ming</p>
<p>资料学习：在Github上有份资料值得推荐。<br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/</a> 向dalao递茶.jpg</p>
<p>遍历框架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*数组遍历*/</span><br><span class="line">void traverse（int [] arr）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i ; i &lt;arr.length ; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		//迭代 arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*链表遍历*/</span><br><span class="line">class ListNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	<span class="keyword">for</span> (ListNode p = head ; p != null ; p = p.next)&#123;</span><br><span class="line">    	</span><br><span class="line">        //迭代访问p.data</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head)&#123;</span><br><span class="line">	//递归head.data;</span><br><span class="line">	traverse(head.next);</span><br><span class="line">&#125;</span><br><span class="line">/*二叉树遍历*/</span><br><span class="line">class TreeNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode left ,right;</span><br><span class="line">&#125;</span><br><span class="line">void traverse (TreeNode root)&#123;</span><br><span class="line">	//递归root.data  先序</span><br><span class="line">    //cout &lt;&lt; root.data &lt;&lt; endl;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*N叉树遍历*/</span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	int data;</span><br><span class="line">    TreeNode [] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void traverse(TreeNode root)&#123;</span><br><span class="line">	//c++ 11 标准</span><br><span class="line">	<span class="keyword">for</span>(TreeNode clid : root.children)&#123;</span><br><span class="line">    	//cout &lt;&lt; child.data &lt;&lt; endl;</span><br><span class="line">    	traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure and Algorithms Lover</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB的基本常识</title>
    <url>/Circuit-Lover/PCB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h4 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">频率：10M-100M </span><br><span class="line">线框：10mile（0.254mm=10mil）</span><br><span class="line">电源：20-30v //电源线加粗抗干扰</span><br><span class="line">价钱：80-100元</span><br><span class="line">DIP 双直插式</span><br><span class="line">QFP 方扁封装</span><br><span class="line">孔的类型</span><br><span class="line">孔有三大类别：过孔（Vai）、 插件孔（Pad孔） 、无铜安装孔（Npth）</span><br><span class="line">过孔（via）：只是起电气导通作用不用插器件焊接，其表面可以做开窗（焊盘裸露）、盖油或者塞油。</span><br><span class="line">插件孔（Pad孔）：需要插器件焊接的引脚孔，焊盘表面必须裸露出来</span><br><span class="line">无铜安装孔（Npth）:螺丝孔或器件塑料固定脚，没有电气性能，起定位固定作用。</span><br></pre></td></tr></table></figure>
<h4 id="AD软件操作"><a href="#AD软件操作" class="headerlink" title="AD软件操作"></a>AD软件操作</h4><h6 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q  精度转化mile---mm</span><br><span class="line">1 电路规划（板子大小）</span><br><span class="line">快捷键TVT打安装孔（双击属性：Board cutout 板剪切块）copper镀铜  polygon cutout多边形剪切</span><br><span class="line">2 二维s</span><br><span class="line">3 三维</span><br><span class="line">shitf+右键旋转</span><br><span class="line">ctrl+中键  放大</span><br><span class="line">N +  S  +  A  显示预拉线</span><br><span class="line">N +  H +  A      隐藏预拉线（N键）</span><br><span class="line">shitf +F查找类似</span><br><span class="line">先按3切换到三维界面，然后按住SHIFT不放，按鼠标右键调整视图角度</span><br></pre></td></tr></table></figure>
<h5 id="一块PCB的生成基本过程"><a href="#一块PCB的生成基本过程" class="headerlink" title="一块PCB的生成基本过程"></a>一块PCB的生成基本过程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.原理图 （满足输入左边，输出右边）</span><br><span class="line">2.一键生成PCB</span><br><span class="line">3.自动布线</span><br><span class="line">4.手工布线</span><br><span class="line">5.规则检查</span><br><span class="line">6.泪滴</span><br><span class="line">7.敷铜（放置多边形敷铜（G键））</span><br><span class="line">8.规则检查</span><br><span class="line">9.信号检查</span><br><span class="line">10.生成物料清单</span><br><span class="line">11.联系淘宝卖家 （嘉立创）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>超声波传感器</title>
    <url>/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p><strong>超声波分类</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">振动在弹性介质内的传播称为波动，简称波。</span><br><span class="line">低于16 Hz的机械波，称为次声波；</span><br><span class="line">在16~2×10^4 Hz之间，称为声波；</span><br><span class="line">高于2×10^4 Hz的机械波，称为超声波,</span><br><span class="line">在3×10^8~3×10^11Hz之间的波，称为微波。</span><br><span class="line">波类型和传递介质</span><br><span class="line">① 纵波：质点振动方向与波的传播方向一致的波，它能在固体、液体和气体介质中传播；</span><br><span class="line">② 横波：质点振动方向垂直于传播方向的波，它只能在固体介质中传播； </span><br><span class="line">③ 表面波：质点的振动介于横波与纵波之间，沿着介质表面传播，其振幅随深度增加而迅速衰减的波，表面波只在固体的表面传播。</span><br></pre></td></tr></table></figure>
<p><strong>超声波应用</strong><br>(1)超声波用于高效清洗<br>当弱的声波信号作用于液体中时，会对液体产生一定的负压，即液体体积增加，液体中分子空隙加大，形成许多微小的气泡；而当强的声波信号作用于液体时，则会对液体产生一定的正压，即液体体积被压缩减小，液体中形成的微小气泡被压碎。经研究证明：超声波作用于液体中时，液体中每个气泡的破裂会产生能量极大的冲击波，相当于瞬间产生几百度的高温和高达上千个大气压的压力，这种现象被称之为“空化作用”，超声波清洗正是利用液体中气泡破裂所产生的冲击波来达到清洗和冲刷工件内外表面的作用。超声清洗多用于半导体、机械、玻璃、医疗仪器等行业。<br>(2)超声波焊接(主要三要素：时间、压力、振幅)<br>压电陶瓷或磁致伸缩材料在高电压窄脉冲作用下，可得到较大功率的超声波，可以被聚焦，能用于集成电路及塑料的焊接。<br>注：金属也行。<br>(3)超声波在医学检查中的应用<br>胎儿的B超影像…</p>
<p><strong>超声波传感器</strong><br>超声物位传感器：单换能器、双换能器<br>只要测得超声波脉冲从发射到接收的时间间隔，便可以求得待测的物位。 </p>
<p><strong>超声侧厚传感器</strong><br>双晶直探头中的压电晶片发射超声振动脉冲，超声脉冲到达试件底面时，被反射回来，并被另一只压电晶片所接收。</p>
<p><strong>超声波流量传感器</strong><br>目前应用较广的主要是超声波传播时间差法.超声波在流体中传播时，在静止流体和流动流体中的传播速度是不同的，利用这一特点可以求出流体的速度，再根据管道流体的截面积， 便可知道流体的流量。</p>
<img src="/Circuit-Lover/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8.jpg" class="" title="超声波传感器">


<p><strong>超声波传感器的应用</strong><br>超声波流量计<br>超声波侧厚<br>超声波探伤<br>超声波报警器</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程常识</title>
    <url>/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h5 id="计算机常识QAQ"><a href="#计算机常识QAQ" class="headerlink" title="计算机常识QAQ"></a>计算机常识QAQ</h5><img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/1.jpg" class="" title="计算机系统硬件组成（linux王保明）">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽贯穿整个系统的一组电子管道称为总线</span><br><span class="line">片内总线</span><br><span class="line">系统总线：数据总线DB、地址总线CB、控制总线CB</span><br><span class="line">外部总线</span><br><span class="line"></span><br><span class="line">CPU：运算寄存器ALU、控制器、寄存器（状态寄存器、通用寄存器）</span><br><span class="line">取指、译码、执行、写回、跳转。pc指针多32位。</span><br><span class="line"></span><br><span class="line">什么是操作系统</span><br><span class="line">操作系统：有效地管理计算机系统中的资源，合理地管理计算机系统的工作流程，方便用户使用的程序的集合。</span><br><span class="line"></span><br><span class="line">操作系统五大任务</span><br><span class="line">(1)文件管理</span><br><span class="line">(2)处理器管理</span><br><span class="line">(3)内存管理</span><br><span class="line">(4)设备管理</span><br><span class="line">(5)作业管理</span><br></pre></td></tr></table></figure>

<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/2.jpg" class="">

<h5 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">体系结构:linux内核被划分为多个子系统。基本服务都集成到内核中,例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。（收包和发包产生大量中断，放在内核最有效率）。</span><br><span class="line">主要子系统：</span><br><span class="line">（1）系统调用接口</span><br><span class="line">（2）进程管理</span><br><span class="line">（3）内存管理：其中，为每个子程序提供了一个2^32虚拟内存。</span><br><span class="line">为n个进程提供访问的物理空间、段式管理和页式管理就行了。linux进程并发模型.</span><br><span class="line">（4）虚拟文件系统（VFS）：虚拟文件系统 在 系统调用层接口（SCI ）和内核所支持的文件系统之间提供了一个交换层。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展： Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供MMU的处理器上运行。Linux 内核的uClinux移植提供了对非 MMU 的支持</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/Linux%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86/3.jpg" class="">


]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux应用编程</tag>
      </tags>
  </entry>
  <entry>
    <title>联发科面试</title>
    <url>/My-interview-Lover/%E5%8F%91%E7%A7%91%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>容器使用应用场景小记🕵️</title>
    <url>/C-C-Lover/%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>vector与deque的比较：</p>
<p>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。</p>
<p>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p>
<p>三：deque支持头部的快速插入与快速移除，这是deque的优点。</p>
<p>四：list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>五：set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>六：map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/MySql-Lover/%E5%8A%A1/</url>
    <content><![CDATA[<h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</span><br><span class="line">事务的 ACID 特性：原子性、一致性、隔离性、持续性。</span><br><span class="line">事务是并发控制的基本单位。</span><br><span class="line">并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</span><br><span class="line">脏读：就是指当一个事务对数据进行了修改但还没有提交到数据库时，另一个事务访问并使用了这个数据。</span><br><span class="line">不可重复读：在一个事务内两次读数据之间，第二个事务访问该数据并进行了修改。</span><br><span class="line">丢失修改：两个事务读入同一数据并修改，T2提交的结果破坏了T1提交的结果。例如T1读A修改为A-1，T2也读A修改为A-1（实际上应该是读A-1，修改 为A-2）</span><br><span class="line">&lt;部分来源牛客网&gt;</span><br></pre></td></tr></table></figure>

<p>SHOW ENGINES;#开启事务<br>SET autocommit=0;<br>START TRANSACTION；<br>#处理<br>UPDATA account set  balance =100 where usename = ‘ming’;<br>ROLLBACK ;</p>
<p>__savepoint保存回滚</p>
<p>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点S<br>ELECT * FROM account;</p>
<p>扩展知识点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">恢复的实现技术:建立冗余数据,利用冗余数据实施数据库恢复。</span><br><span class="line">建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySql Lover</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>少用全局变量</title>
    <url>/C-C-Lover/%E5%B0%91%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>全局变量</td>
<td>在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</td>
</tr>
<tr>
<td>局部变量</td>
<td>在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。</td>
</tr>
</tbody></table>
<p>__注意</p>
<p>全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。<br>滥用全局变量会造成不必要的常量频繁使用，特别当这个常量没有用宏定义“正名”时，代码阅读起来将万分吃力。</p>
<p>__有什么对策？</p>
<ol>
<li>能不用全局变量尽量不用。</li>
<li>如果不可避免需要用到，那能藏多深就藏多深。<br>1)如果只有某.c文件用，就static到该文件中，顺便把结构体定义也收进来；<br>2)如果只有一个函数用，那就static到函数里面去；<br>3)如果非要开放出去让人读取，那就用函数return出去，这样就是只读属性了；<br>4)如果非要遭人蹂躏赋值，好吧，我开放函数接口让你传参赋值<br>5)实在非要extern我，我还可以严格控制包含我.h档的对象，而不是放到公共的includes.h中被人围观，丢人现眼。<br>6）当一个模块里面的全局变量超过3个(含)时，就用结构体包起来吧。要归0便一起归0，省得丢三落四的。</li>
</ol>
<p>公众号：C/C++技术文章<br>参考资料：<br>【1】佚名. 全局变量、局部变量、静态全局变量、静态局部变量的区别<br>【2】佚名. 嵌入式C编程经验之全局变量猛于虎<br>【3】《C11标准文档》</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>华为面试</title>
    <url>/My-interview-Lover/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>自振荡产生正弦波、方波、三角波</title>
    <url>/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/</url>
    <content><![CDATA[<h4 id="振荡电路知识"><a href="#振荡电路知识" class="headerlink" title="振荡电路知识"></a>振荡电路知识</h4><h5 id="1、振荡条件"><a href="#1、振荡条件" class="headerlink" title="1、振荡条件"></a>1、振荡条件</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t1.jpg" class="">
<h5 id="2、起振、稳幅"><a href="#2、起振、稳幅" class="headerlink" title="2、起振、稳幅"></a>2、起振、稳幅</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t2.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(1)无输入源，起振信号源来自哪里？</span><br><span class="line">答：电器内部噪声以及电源接通扰动。</span><br><span class="line">(2)稳幅作用？</span><br><span class="line">答：信号输出幅度达到一定程度时，会失真。必须通过调幅限制，使得振幅平衡回到AF = 1。</span><br></pre></td></tr></table></figure>
<p>3、基本组成部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▽放大电路</span><br><span class="line">▽反馈电路</span><br><span class="line">▽选频网络</span><br><span class="line">▽稳幅环节</span><br></pre></td></tr></table></figure>
<p>移相式正弦振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">扩展知识点：</span><br><span class="line">1. 电阻上的电压电流同相位</span><br><span class="line">2. 电感上的电流落后电压90°相位</span><br><span class="line">3. 电容上的电流超前电压90°相位</span><br></pre></td></tr></table></figure>
<p>RC振荡电路</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注：Rf为热敏电阻。</span><br></pre></td></tr></table></figure>
<h4 id="课设设计：100Hz与5000Hz"><a href="#课设设计：100Hz与5000Hz" class="headerlink" title="课设设计：100Hz与5000Hz"></a>课设设计：100Hz与5000Hz</h4><h5 id="原理设计"><a href="#原理设计" class="headerlink" title="原理设计"></a>原理设计</h5><p>正弦波发生</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t6.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f0=1/(2π√R1R2C1C2)  </span><br><span class="line">①可以修改 R1 R2 C1 C2 来产生100Hz 和 5000Hz</span><br><span class="line">通过调节R1，R2，C1，C2的值，使得f0=100Hz。先取C1=100nF，C2=100nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=16K,R2=16K。</span><br><span class="line">为了方便调试，16k采用20k滑动变阻器。</span><br><span class="line">②通过调节R1，R2，C1，C2的值，使得f0=5000Hz。先取C1=1nF，C2=1nF，然后再确定R1，R2，考虑到要得到精确的输出值，计算得出R1=1K,R2≈640Ω。</span><br><span class="line">为了方便调试， 640Ω采用1k滑动变阻器</span><br></pre></td></tr></table></figure>
<p>正弦波转方波、三角波</p>
<img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t7.jpg" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正弦波转方波：过零比较器</span><br><span class="line">方波转三角波: 积分放大器</span><br></pre></td></tr></table></figure>
<h5 id="proteus仿真"><a href="#proteus仿真" class="headerlink" title="proteus仿真"></a>proteus仿真</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t8.jpg" class="">

<h5 id="实物演示"><a href="#实物演示" class="headerlink" title="实物演示"></a>实物演示</h5><img src="/Circuit-Lover/%E8%87%AA%E6%8C%AF%E8%8D%A1%E4%BA%A7%E7%94%9F%E6%AD%A3%E5%BC%A6%E6%B3%A2%E3%80%81%E6%96%B9%E6%B3%A2%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%A2/t9.jpg" class="">

<h5 id="课设总结"><a href="#课设总结" class="headerlink" title="课设总结"></a>课设总结</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我在这次课程设计中遇到，一直都调不出理想的波形，检查了很多东西，像接线问题、电路问题、电源问题、示波器问题地线问题等等，所以我总结出，对于要求精度很高的电路，一旦出现实际问题时，应该具备以下三个点：</span><br><span class="line">1.重新审查电路原理图，计算相关数据，运行仿真结果。</span><br><span class="line">2.元件器件的损坏或性能的影响，因为在这个放大电路中稍有偏差，结果就会相差很大，此次个人觉得时间较为紧迫，选择附近的元件卖家，结果性能远远达不到所需的要求。</span><br><span class="line">3.要有足够的耐心和冷静的思考，当图形出现差异时，冷静的思考是必不可少的。</span><br><span class="line">通过这次课程设计,我懂得了要完成一个电路的设计,理论基础是根基,实践操作是完成实物的重要部分,而创新能力则决定了一个电路的价值,因为设计一个电路,决不是简单地按课本的电路图进行焊接成型,我们要进行电路各个元件参数的计算,这个涉及我们所掌握的理论知识,元件的计算是设计中较为重要的一部分,计算准了,则设计出来的电路误差不大,否则,设计出来的电路性能指标跟要求相差甚远。</span><br><span class="line">最困难的是当电路出现错误是,如何检测出错误之处,如何排除错误,它考验了我们如何运用理论知识和实际的调试的能力, 这也是我大三这一年最需要注重和提高的地方。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>传感器的特点</title>
    <url>/Circuit-Lover/%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>1.什么叫传感器? </p>
<p>能够感受规定的被测量并按照一定规律转化成可用输出信号的器件或装置。</p>
<p>2、传感器共性是什么？<br>传感器的共性就是利用物理规律或物质的物理、生物、化学特性，将非电量信号（位移、速度、力等）输入转换成电量（电压、电流、电容等）输出。</p>
<p>3、传感器由哪些部分组成？<br>传感器一般是由敏感元件、转化元件和变换电路三部分组成。</p>
<p>4、改善传感器？<br>（1）差动技术<br>（2）平均技术<br>（3）补偿与修正<br>（4）干扰抑制<br>（5）稳定性处理</p>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>cvte面试</title>
    <url>/My-interview-Lover/te%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>My interview Lover</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>文件夹系统目录</title>
    <url>/Linux-Lover/%E5%A4%B9%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><strong>文件夹系统目录</strong></p>
<table>
<thead>
<tr>
<th>文件目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。</td>
</tr>
<tr>
<td>/boot</td>
<td>Ubuntu内核和启动文件，比如vmlinuz-xxx。grub引导装载程序。</td>
</tr>
<tr>
<td>/cdrom</td>
<td>光盘</td>
</tr>
<tr>
<td>/dev</td>
<td>设备驱动文件  sda *磁盘驱动文件</td>
</tr>
<tr>
<td>/etc</td>
<td>存放一些系统配置文件，比如用户账号和密码文件，各种服务的起始地址。</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹，一般创建用户账户的时候，默认的用户主文件夹都会放到此目录下。</td>
</tr>
<tr>
<td>/lib</td>
<td>存放库文件</td>
</tr>
<tr>
<td>/media</td>
<td>此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到这个目录中。</td>
</tr>
<tr>
<td>/mnt</td>
<td>用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。</td>
</tr>
<tr>
<td>/opt</td>
<td>可选的文件和程序存放目录，给第三方软件放置的目录。</td>
</tr>
<tr>
<td>/root</td>
<td>root用户目录，也就是系统管理员目录。</td>
</tr>
<tr>
<td>/sbin</td>
<td>和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。</td>
</tr>
<tr>
<td>/run</td>
<td>运行有关的信息</td>
</tr>
<tr>
<td>/snap</td>
<td>包管理工具</td>
</tr>
<tr>
<td>/srv</td>
<td>服务相关目录。比如网络服务。</td>
</tr>
<tr>
<td>/sys</td>
<td>记录内核信息，虚拟文件系统。</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时目录</td>
</tr>
<tr>
<td>/var</td>
<td>存放一些变化的文件，比如日志文件</td>
</tr>
<tr>
<td>/usr</td>
<td>usr不是user的缩写，而是UNIX Software Resource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！  du -sh</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，数据放置到内存中，存放系统运行信息</td>
</tr>
</tbody></table>
<p>__ 其他:__<br> Cat /proc/cpuinfo   cpu信息<br> ls /sys/bus/platform  设备树（device 、 driver）<br>正常情况，应该是Owner可以读写，all可读，root可以修改可执行权限才对。<br>正常情况，对于目录，应该权限设定为744，对于文件默认权限应该设定为644。<br>用户私有文件，权限应该设定为600。</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘文件、内存命令</title>
    <url>/Linux-Lover/%E5%86%85%E5%AD%98%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ls /dev/sd*</p>
<p>df：列出文件系统的整体磁盘使用量。主要查看个文件系统的使用量，<br>du:评估文件系统的磁盘使用量，主要查看单个文件的大小。<br>eg:du -h –max-depth=1  显示一层</p>
<p>磁盘的挂载和卸载mount和umount命令</p>
<p>sudo umount media/ming/MING    </p>
<p>mkdir udisk</p>
<p>sudo mount /dev/sdb1  /media/ming/udisk</p>
<p>sudo mount -o iocharset=utf8  /dev/sdb1 /media/ming/udisk //中文显示</p>
<p>分区挂载不能进行分区操作<br>sudo fdisk /dev/sdb</p>
<p>磁盘格式化<br>mkfs -t vfat /dev/sdx</p>
<p>3、磁盘格式化</p>
<p>   磁盘分区创建好以后就可以格式化磁盘，使用命令mkfs。如：<br>sudo mkfs -t vfat/dev/sdx<br>   把U盘拔了重插上去，防止报错</p>
<p>4、free  -h 查看内存 </p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>静态动态库的调用</title>
    <url>/C-C-Lover/%E6%80%81%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>动态库的调用？<br>GUC -T多轴运动控制器 dll。四轴参考手册<br>点位运动、Jog模式、电子齿轮运动（运动）、插补运动（联动）。<br>LIBS+=../lib/gts.dll<br>静态库、动态库存在于代码生成可执行文件的“链接”阶段。<br>.lib文件称作静态链接库，.dll文件称作动态链接库。（linux系统下对应的文件为.a文件及.so文件）<br>简单讲，静态库就是直接将需要的代码连接进可执行程序；<br>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。<br>做成静态库可执行文件本身比较大，但不必附带动态库；<br>做成动态库可执行文件本身比较小，但需要附带动态库。<br>LIBS += -LE:/project/QT/usbcan_info -lControlCAN   //通讯卡接口<br>LIBS  += ../lib/gts.dll<br>__declspec(dllexport)<br>Loadlibrary(“DllTestDll”)<br>SubFunc sub=(SubFunc)GetProcAddress(hDll“Sub”)<br>Freelibrary(hModule)</p>
<p>#ifdef __cplusplus<br>extern “C”<br>{<br>#endif<br>void func(void );</p>
<p>#ifdef __cplusplus<br>}<br>#endif</p>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C字符串常用函数</title>
    <url>/C-C-Lover/%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>字符串连接函数 strcat、strncat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char  a[10] = <span class="string">"123"</span>;</span><br><span class="line">char b[] = <span class="string">"456"</span>;</span><br><span class="line"></span><br><span class="line">strcat(a,b);//123456</span><br><span class="line">strncat(a,b,2);//1235</span><br></pre></td></tr></table></figure>

<p>字符串复制函数 strcpy、strncpy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strcpy(a,b);//123456</span><br><span class="line">strncpy(a,b,2);//1235</span><br></pre></td></tr></table></figure>
<p>字符串比较strcmp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcmp(str1,str2);</span><br></pre></td></tr></table></figure>
<p>字符长度strlen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strlen(str);</span><br></pre></td></tr></table></figure>
<p>字符分解strtok</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strtok函数的作用是把字符串以规定的字符分割开：</span><br><span class="line">p &#x3D; strtok(buf, &quot;@&quot;); </span><br><span class="line">p为指针，buf也是指针，这句代码的意思就是把buf中的字符串以&quot;@&quot;为分隔符分割保存到指针p中。</span><br><span class="line">再次调用strtok函数时，不需要再写buf。即：</span><br><span class="line">p &#x3D; strtok(NULL, &quot;@&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++ Lover</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 操作随记</title>
    <url>/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令模式</span><br><span class="line"></span><br><span class="line">移动：首行gg 末行G</span><br><span class="line"></span><br><span class="line">复制：yy  粘贴p</span><br><span class="line"></span><br><span class="line">剪切：dd      留空剪切：D</span><br><span class="line"></span><br><span class="line">撤销：u   恢复：crtl +  r</span><br><span class="line"></span><br><span class="line">编辑模式（输入模式）</span><br><span class="line"></span><br><span class="line">i a     esc</span><br><span class="line"></span><br><span class="line">末行模式（尾行模式）。</span><br><span class="line"></span><br><span class="line">:w</span><br><span class="line"></span><br><span class="line">:q</span><br><span class="line"></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line">:q！</span><br><span class="line"></span><br><span class="line">：x   保存退出！！！！</span><br><span class="line"></span><br><span class="line">/ 查找</span><br><span class="line"></span><br><span class="line">：s/     g</span><br><span class="line"></span><br><span class="line">:%s/    g</span><br><span class="line"></span><br><span class="line">查看当前已经打开的文件名称：“:files”</span><br><span class="line">： esc    进入 退出</span><br></pre></td></tr></table></figure>
<img src="/Linux-Lover/vim%20%E6%93%8D%E4%BD%9C%E9%9A%8F%E8%AE%B0/vim.jpg" class="">]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随记命令(1)</title>
    <url>/Linux-Lover/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl +C    终止 <span class="built_in">cd</span> `</span><br><span class="line"></span><br><span class="line">df  -h      磁盘大小</span><br><span class="line"></span><br><span class="line">free -m     内存大小</span><br><span class="line"></span><br><span class="line">head -n  **.txt  文件头几行   默认10</span><br><span class="line"></span><br><span class="line">tail - n <span class="comment">##  ** .txt 文件末尾两行</span></span><br><span class="line"></span><br><span class="line">less 查看文件     ：q退出</span><br><span class="line"></span><br><span class="line"><span class="comment">#wc -lwc 统计文件内容信息（包含行数、单词数、字节数）</span></span><br><span class="line"></span><br><span class="line">         -l：表示lines，行数</span><br><span class="line"></span><br><span class="line">         -w：表示words，单词数  依照空格来判断单词数量</span><br><span class="line"></span><br><span class="line">         -c：表示bytes，字节数</span><br><span class="line"></span><br><span class="line">date 输出的形式：2018年3月24日星期六15:54:28</span><br><span class="line"></span><br><span class="line">date +%F 输出形式：2018-03-24</span><br><span class="line"></span><br><span class="line">date <span class="string">"+%F %T"</span>  ==输出的形式：2018-03-24 16:01:00</span><br><span class="line"></span><br><span class="line">==<span class="comment">#date “+%Y-%m-%d %H:%M:%S”</span></span><br><span class="line"></span><br><span class="line">date -d   <span class="string">"-1 day"</span>  <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"></span><br><span class="line">前天 -  后天 +</span><br><span class="line"></span><br><span class="line">cal  作用：用来操作日历的</span><br><span class="line"></span><br><span class="line">cal -1 本月</span><br><span class="line"></span><br><span class="line">cal -3 上 中 下</span><br><span class="line"></span><br><span class="line">cal   -y  2019 年份月历</span><br><span class="line"></span><br><span class="line">clear     / ctrl +L  清除终端</span><br><span class="line"></span><br><span class="line">ls   /  | wc<span class="_">-l</span>   管道的过滤使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls / |grep y</span></span><br><span class="line"></span><br><span class="line">hostname -f </span><br><span class="line"></span><br><span class="line">id  （包含用户id，用户组id，附加组id…）</span><br><span class="line"></span><br><span class="line">whoami   查看当前用户</span><br><span class="line"></span><br><span class="line">ps -ef 服务器进程   ps -ef  |grep http</span><br><span class="line"></span><br><span class="line">top 处理机资源占用情况</span><br><span class="line"></span><br><span class="line">du -sh 目录 查看目录大小</span><br><span class="line"></span><br><span class="line">service 服务名称  start stop  restart</span><br><span class="line"></span><br><span class="line">find  / -name      http    查找</span><br><span class="line"></span><br><span class="line">find  / -name      *.cof </span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 2986   killall 名称   杀死进程</span><br><span class="line"></span><br><span class="line">ifconfig      inet addr就是网卡的ip地址。</span><br><span class="line"></span><br><span class="line">reboot  启动</span><br><span class="line"></span><br><span class="line">shutdown   重启</span><br><span class="line"></span><br><span class="line">uptime 计算开机到现在的额时间</span><br><span class="line"></span><br><span class="line">uname  操作系统名称</span><br><span class="line"></span><br><span class="line">netstat -tnlp</span><br><span class="line"></span><br><span class="line">       -t：表示只列出tcp协议的连接；</span><br><span class="line"></span><br><span class="line">       -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</span><br><span class="line"></span><br><span class="line">       -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</span><br><span class="line"></span><br><span class="line">       -p：表示显示发起连接的进程pid和进程名称；</span><br><span class="line"></span><br><span class="line">man   cp 查看帮助文档</span><br><span class="line"></span><br><span class="line">软链接 （符号链接） ln -s   <span class="built_in">source</span>  target  </span><br><span class="line"></span><br><span class="line">硬链接 （实体链接）ln       <span class="built_in">source</span>  target</span><br><span class="line"></span><br><span class="line">Ctrl+s  阻止输入</span><br><span class="line"></span><br><span class="line">Ctrl+q  允许输入</span><br><span class="line"></span><br><span class="line">Ctrl + a/Home 切换到命令行开始</span><br><span class="line"></span><br><span class="line">Ctrl + e/End 切换到命令行末尾</span><br><span class="line"></span><br><span class="line"><span class="built_in">history</span> 显示你所有执行过的编号+历史命令</span><br><span class="line"></span><br><span class="line">!$ 显示系统最近的一条参数</span><br><span class="line">比如 cat /etc/sysconfig/network-scripts/ifconfig-eth0，想用 vim 编辑。</span><br><span class="line">一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命令。其实完全可以用 vim !$来代替</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>cron /crontab 计划任务</title>
    <url>/Linux-Lover/ron-crontab-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>分 时 日  月  星期</p>
<p>四个符号：</p>
<p>*：表示取值范围中的每一个数字</p>
<p>-：做连续区间表达式的，要想表示1~7，则可以写成：1-7</p>
<p>/：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：*/10</p>
<p>,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6</p>
<p>问题1：每月1、10、22日的4:45重启network服务</p>
<p>45 4  1,10,22  * *  service network restart</p>
<p>问题2：每周六、周日的1:10重启network服务</p>
<p>10 1  *  * 6,0   service network restart</p>
<p>问题3：每天18:00至23:00之间每隔30分钟重启network服务</p>
<p>*/30 18-23  *  * *   service network restart</p>
<p>问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启</p>
<p>3,15 8-11  */2  * *   reboot</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>解压磁盘</title>
    <url>/Linux-Lover/%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<p>bzip2</p>
<p>bzip2 -z xxx</p>
<p>bzip2 -d xxx.gz</p>
<p>tar</p>
<p>tar -vcjf xxx xxx   bz2</p>
<p>tar -vxjf xxxx</p>
<p>tar -vczf xxx xxx  压缩gz</p>
<p>tar -vxzf xxxx  解压</p>
<p>tar -vxzf xxxx（目录） -C xxx(路径)</p>
<p>rar</p>
<p>rar -a xxx.rar xxx   压缩</p>
<p>rar -x xxx.rar   解压</p>
<p>zip</p>
<p>zip -rv xxx.zip xxx   压缩</p>
<p>unzip -v xxx.zip   解压</p>
<p><strong>扩展硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">sudo fdisk - l</span><br><span class="line">sudo fdisk /dev/sda</span><br><span class="line">删除 分区：d</span><br><span class="line">新增 分区：n</span><br><span class="line">保存操作：w</span><br><span class="line">重启：reboot</span><br><span class="line">挂载磁盘</span><br><span class="line">在 home 下新建work作为这块磁盘挂载点</span><br><span class="line"><span class="comment"># mkdir  sda2</span></span><br><span class="line"><span class="comment"># sudo mount   /dev/sda2    /home/sda2</span></span><br><span class="line">设置开机磁盘自动挂载</span><br><span class="line"><span class="comment"># vi /etc/fstab</span></span><br><span class="line">添加行  /dev/sda2     /home/work   ext4   defaults, 0 1</span><br><span class="line">此时，磁盘已经挂好，查看挂好的磁盘</span><br><span class="line">参考：https://blog.csdn.net/u010801439/article/details/77676668</span><br></pre></td></tr></table></figure>
<p><strong>/dev/sda 磁盘不足</strong></p>
<p>#sudo apt-get autoclean<br> #sudo apt-get clean<br>#sudo apt-get autoremove<br>执行完后直接将/usr下释放了1G左右的空间。<br>整合碎片使用<br>参考：<a href="https://blog.csdn.net/itas109/article/details/83341149" target="_blank" rel="noopener">https://blog.csdn.net/itas109/article/details/83341149</a></p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>设备地址</title>
    <url>/Linux-Lover/%E5%A4%87%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>电脑与板子连接路由（电脑连接Wifi）</p>
<p>192.168.0.128</p>
<p>192.168.0.255</p>
<p>255.255.255.0</p>
<p>00:0c:29:e3:61:25</p>
<p>板子</p>
<p>setenv ipaddr 192.168.0.50</p>
<p>setenv ethaddr 00:04:9f:04:d2:35</p>
<p>setenv gatewayip 192.168.0.1</p>
<p>setenv netmask 255.255.255.0</p>
<p>setenv serverip 192.168.0.128</p>
<p>saveenv</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>我的常用网站</title>
    <url>/Mechanic-Lover/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>米思米：<a href="https://www.misumi.com.cn/" target="_blank" rel="noopener">https://www.misumi.com.cn/</a></p>
<p>GABCAD:<a href="https://grabcad.com/" target="_blank" rel="noopener">https://grabcad.com/</a></p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>man手册</title>
    <url>/Linux-Lover/an%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h5 id="man"><a href="#man" class="headerlink" title="man"></a>man</h5><table>
<thead>
<tr>
<th align="center">代号</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Standard commands (标准命令)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">System calls (系统调用)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Libary functions （库函数）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Special device (设备说明)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">File formats (文件格式)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Game and toys (游戏娱乐)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">Miscellaneous (杂项)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Administrative commands(管理员命令)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">other  (存放内核文档)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32系统架构</title>
    <url>/MCU-Lover/m32%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>截图放博客，懒得翻文档 Q_Q</p>
<img src="/MCU-Lover/m32%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/stm32.jpg" class="">

<p>ICode 总线<br>DCode 总线：该总线将Cortex™-M3内核的DCode总线与闪存存储器的数据接口相连接(常量加载和调试访问)。<br>系统总线<br>DMA 总线<br>总线矩阵<br>AHB/APB 桥(APB)：两个AHB/APB桥在AHB和2个APB总线间提供同步连接。APB1操作速度限于36MHz，APB2操作于全速(最高72MHz)。</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32最小系统</title>
    <url>/MCU-Lover/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>值得参考：<a href="https://www.21ic.com/jichuzhishi/mcu/questions/2017-06-07/723582.html" target="_blank" rel="noopener">https://www.21ic.com/jichuzhishi/mcu/questions/2017-06-07/723582.html</a></p>
<img src="/MCU-Lover/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/stm32.jpg" class="">

<p>stm32低电平复位</p>
<p>PA9 PA10对应连接RXD TXD<br>烧录： 最小系统板boot0 置1 boot1置0<br>启动：最小系统板boot0 置0 boot1置0</p>
]]></content>
      <categories>
        <category>MCU Lover</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>555概念及使用</title>
    <url>/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="常见波形"><a href="#常见波形" class="headerlink" title="常见波形"></a>常见波形</h5><img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/555-2.jpg" class="">
<h5 id="单稳态触发器"><a href="#单稳态触发器" class="headerlink" title="单稳态触发器"></a>单稳态触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单稳态触发器----用于脉冲波形的变换和定时、延时 (74121、MC14528)</span><br><span class="line">Tw = 0.7 RC</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/3.jpg" class="" title="波形变换">
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/4.jpg" class="" title="定时">
<h5 id="多谐振荡器"><a href="#多谐振荡器" class="headerlink" title="多谐振荡器"></a>多谐振荡器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">多谐振荡器----用于产生脉冲，没有稳定状态，只有两个暂稳态，从而产生自激振荡，无需外触发。</span><br><span class="line">T=0.7(R1C1+R2C2)</span><br></pre></td></tr></table></figure>

<h5 id="施密特触发器"><a href="#施密特触发器" class="headerlink" title="施密特触发器"></a>施密特触发器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">施密特触发器----用于脉冲波形的变换，尤其是将模拟量转换成数字波形</span><br><span class="line">具有回差：有两个触发翻转电平。输入信号增加时，在VT+处翻转；输入信号减小时，在VT- 处翻转。VT+-VT-称为回差电压，用ΔVT表示，所以其传输特性呈回线状。</span><br><span class="line">无记忆功能：施密特触发器的稳态要靠外加触发电压维持，信号撤除会导致电路状态的改变。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/5.jpg" class="">
<h5 id="555定时器"><a href="#555定时器" class="headerlink" title="555定时器"></a>555定时器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以经过内部链接构成施密特触发器。</span><br><span class="line">它的作用可以整流，整幅，以及整波。</span><br></pre></td></tr></table></figure>
<img src="/Circuit-Lover/555%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/1.jpg" class="">

<table>
<thead>
<tr>
<th align="center">引脚</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1脚</td>
<td align="left">外接电源负端VSS或接地，一般情况下接地。</td>
</tr>
<tr>
<td align="center">2脚</td>
<td align="left">低触发端TL，该脚电压小于1/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">3脚</td>
<td align="left">输出端OUT。</td>
</tr>
<tr>
<td align="center">4脚</td>
<td align="left">直接清零端RST。当此端接低电平时，则时基电路不工作</td>
</tr>
<tr>
<td align="center">5脚</td>
<td align="left">CO为控制电压端。若此脚外接电压，则可改变内部两个比较器的基准电压，当该脚不用时，应将该脚串入一只0.01μF（103）瓷片电容接地，以防引入高频干扰。</td>
</tr>
<tr>
<td align="center">6脚</td>
<td align="left">高触发端TH，该脚电压大于2/3 VCC时有效。</td>
</tr>
<tr>
<td align="center">7脚</td>
<td align="left">放电端。该端与放电管T的集电极相连</td>
</tr>
<tr>
<td align="center">8脚</td>
<td align="left">双极型时基电路VCC的范围是4.5 -16V，CMOS型时基电路VCC的范围为3-18V，一般用5V。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>Solidworks与PCB的结合</title>
    <url>/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<p>偶然的一次发现QAQ</p>
<p>PCB电路板与solidworks的完美结合</p>
<img src="/Mechanic-Lover/Solidworks%E4%B8%8EPCB%E7%9A%84%E7%BB%93%E5%90%88/solidworks.jpg" class="">


<p>转载[<a href="https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]" target="_blank" rel="noopener">https://wenku.baidu.com/view/138bd7b9700abb68a982fbca.html]</a></p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数电概念</title>
    <url>/Circuit-Lover/%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单片机51、32、合泰芯片基本了解之后？以前觉得没怎么在意，为什么32芯片和合泰，使用时要使能相应的时钟？而51却不用？</span><br><span class="line"></span><br><span class="line">可是随着电子产品集成度越来越高，功耗和发热越来越严重</span><br><span class="line">芯片厂商非常无奈也在开始想办法避免这个问题，而最直接</span><br><span class="line">的思路当然就是用多少功能就使能多少功能，对每个外设的</span><br><span class="line">时钟都设置了开关，让用户可以精确地控制，关闭不需要的设备</span><br><span class="line">，达到节省供电的目的。</span><br><span class="line">其实这样还有一个好处就是，不是每个外设都需要系统时钟那么高的频率。</span><br><span class="line"></span><br><span class="line">仅仅理解为节省资源的方式感觉还不够，后来思考下，才发现答案就来自数电中的锁存器和触发器，然后，又开始复习了。。。QAQ</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
  <entry>
    <title>继SolidWorks之后另一款3D软件的preo简单的学习</title>
    <url>/Mechanic-Lover/%E7%BB%A7SolidWorks%E4%B9%8B%E5%90%8E%E5%8F%A6%E4%B8%80%E6%AC%BE3D%E8%BD%AF%E4%BB%B6%E7%9A%84preo%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>1.组件中零件激活了之后要取消，直接ctrl+A即可。</p>
<p>2.颜色RGB</p>
<p>255  0  0  红色</p>
<p>248  255  247  白色</p>
<p>0     0    0  黑色</p>
<p>银白色  红(192) 绿(192) 蓝(192)。</p>
<p>染色过程中，高级的层次会覆盖掉低级的颜色</p>
<p>例如：总装配体&gt;子装配体&gt;零件</p>
<p>3.通过不定向，横截面的设置获取“正视于的效果”，配合参考选取视图。</p>
<p>4.仿真看着很单调，不过可以通过数据或者数学方程式驱动运动的轨迹，存在一个数据文档里；</p>
<p>钣金加工工艺（综合冷加工工艺）</p>
<p>下料 、成型、压铆，攻牙、焊接等</p>
<p>表面处理：喷粉，电镀等；</p>
<p>机床的知识<br>NC：数字控制，简称数控。<br>CNC：计算机数字控制，简称也是数控。NC是以前的数控，CNC是目前的数控，NC已经淘汰。另外，人们经常把加工中心叫做CNC。<br>DNC：在线加工。也就是一边传输程序，一边加工，用电脑控制数控机床在线加工。<br>2019-1-9 ming</p>
]]></content>
      <categories>
        <category>Mechanic Lover</category>
      </categories>
      <tags>
        <tag>3D建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统分类</title>
    <url>/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="Linux系统分类"><a href="#Linux系统分类" class="headerlink" title="Linux系统分类"></a>Linux系统分类</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一般来说，linux系统基本分为两大类</span><br><span class="line">Redhat系列:Redhat、Centos、Fedora等</span><br><span class="line">Debian系列:Debian、Ubuntu等</span><br></pre></td></tr></table></figure>

<h5 id="Redhat系列"><a href="#Redhat系列" class="headerlink" title="Redhat系列"></a>Redhat系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">商业用途，企业版，一般付费。</span><br><span class="line">rmp:包安装工具</span><br><span class="line">yum:程序与程序之间存在非常复杂的依赖关系。RPM无法解决软件包的依赖关系。</span><br></pre></td></tr></table></figure>

<h5 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">社区维护，桌面版，一般免费。</span><br><span class="line">dpkg:包安装工具</span><br><span class="line">apt-get:会解决和安装模块的依赖问题</span><br></pre></td></tr></table></figure>
<h5 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h5><img src="/Linux-Lover/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB/example.jpg" class="">


<p>了解RTOS<br>实时操作系统，实时性。</p>
<p>“硬实时”操作系统任务必须在确定的时间完成。<br>“软实时”操作系统能让绝大多数任务在确定时间完成。</p>
<p>操作需求</p>
<p>连接需求：不同协议<br>组网需求：自发现自连接<br>管理需求：不同传感器接入和算法管理。</p>
<p>参考Huawei LiteOS</p>
]]></content>
      <categories>
        <category>Linux Lover</category>
      </categories>
      <tags>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>模电概念</title>
    <url>/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h6 id="放大电路"><a href="#放大电路" class="headerlink" title="放大电路"></a>放大电路</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">放大电路模型:电压放大电路、电流放大电路</span><br><span class="line">放大电路的性能：输入电阻、输出电阻、增益、频率响应及带宽。</span><br></pre></td></tr></table></figure>
<h6 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同相电路</span><br><span class="line">反相电路</span><br><span class="line">求和电路</span><br><span class="line">求差电路</span><br><span class="line">差分电路</span><br><span class="line">积分电路</span><br><span class="line">微分电路</span><br><span class="line">·····</span><br></pre></td></tr></table></figure>
<h5 id="晶体三极管及其基本放大电路（BJT）"><a href="#晶体三极管及其基本放大电路（BJT）" class="headerlink" title="晶体三极管及其基本放大电路（BJT）"></a>晶体三极管及其基本放大电路（BJT）</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/4.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">外部条件：发射结正偏，集电结反偏</span><br><span class="line">共发射极、共基极、共集电极</span><br></pre></td></tr></table></figure>
<h5 id="场效应三极管及其放大电路"><a href="#场效应三极管及其放大电路" class="headerlink" title="场效应三极管及其放大电路"></a>场效应三极管及其放大电路</h5><img src="/Circuit-Lover/3157%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/3.jpg" class="">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">沟道中只有一种类型的载流子参与导电，所以场效应管也称为单极型三极管。</span><br><span class="line">共源极、共栅极、共源极</span><br></pre></td></tr></table></figure>
<h4 id="模拟开关与多路复用器区别"><a href="#模拟开关与多路复用器区别" class="headerlink" title="模拟开关与多路复用器区别"></a>模拟开关与多路复用器区别</h4><p>对信号通路进行选择，或者档位切换，想问模拟通道开关和多路复用器有什么区别？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">模拟开关和多路复用器件其实在电气上，或者架构上，原理上没什么区别。</span><br><span class="line">多路复用的话主要用在通道数比较多的场合，例如：4输入1输出，16输入1输出。</span><br><span class="line">模拟/数字开关主要用于通道数目比较小的。低导通电阻，根据应用需求不同；模拟开关可以分为音频模拟开关、视频模拟开关。</span><br></pre></td></tr></table></figure>
<h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><h5 id="MOS、NMOS、PMOS、COMS概念"><a href="#MOS、NMOS、PMOS、COMS概念" class="headerlink" title="MOS、NMOS、PMOS、COMS概念"></a>MOS、NMOS、PMOS、COMS概念</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MOS管导通特性，相当于开关闭合。</span><br><span class="line">NMOS的特性，Vgs大于一定的值就会导通，适合用于源极接地时的情况，只要栅极电压达到4V或10V就可以了。导通电阻小，且容易制造，市场广泛应用。</span><br><span class="line">PMOS的特性，Vgs小于一定的值就会导通，适合用于源极接VCC时的情况。导通电阻大，价格贵，替换种类少，通常还是使用NMOS。</span><br><span class="line">CMOS的产生？</span><br><span class="line">一、阈值损</span><br><span class="line">NMOS 传输高电平有阈值损（Vtn），低电平则没有；</span><br><span class="line">PMOS 传输低电平有阈值损（Vtp），高电平则没有。</span><br><span class="line">CMOS 互补结构则利用了上述“互补”特性，传输高低电平时都没有阈值损。</span><br><span class="line">二、线性</span><br><span class="line">NMOS 或 PMOS 单管。</span><br><span class="line">利用两管导通电流的“互补”特性，使得导通电流特性呈“高线性”。</span><br><span class="line">三、功耗</span><br><span class="line">主要差别在功耗上，NMOS和PMOS工作时至少有一个导通，而CMOS导通的时间很短，功耗明显降低</span><br></pre></td></tr></table></figure>
<h4 id="CMOS-与-TTL"><a href="#CMOS-与-TTL" class="headerlink" title="CMOS 与 TTL"></a>CMOS 与 TTL</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMOS是场效应晶体管，TTL是双极晶体管2。</span><br><span class="line">COMS具有较宽的逻辑电平范围（5-15V），TTL只能在5V下工作。</span><br><span class="line">CMOS的高低电平差异较大，抗干扰能力强，TTL差小，抗干扰能力差。</span><br><span class="line">CMOS功耗很小，TTL功耗大（1-5mA/门）</span><br><span class="line">CMOS的工作频率略低于TTL，但其高速CMOS几乎与TTL相同。</span><br><span class="line">TTL高电平3.6~5V，低电平0V~2.4V_</span><br><span class="line">CMOS电平VCC可达到12V_</span><br><span class="line">CMOS电路的高电平输出约为0.9VCC，低电平输出约为0.1VCC。</span><br><span class="line">CMOS电路不使用的输入端不能挂起，会引起逻辑混乱。</span><br><span class="line">TTL电路不使用的输入端空旷为高电平_</span><br><span class="line">另外，由于CMOS集成电路的电源电压变化范围大，对电源的要求不如TTL集成电路严格。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Circuit Lover</category>
      </categories>
  </entry>
</search>
